=================================== RESUMEN DEL PROYECTO ===================================

--- INICIO DEL ARCHIVO: README.md ---

<<<<<<< HEAD
# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).
=======
# App-Poker
poker
>>>>>>> 382eb947e0e9e79948d26fb03166f34db02ddb93


-------------------------------------

--- INICIO DEL ARCHIVO: index.html ---

<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1a202c" />
    <title>Poker Replayer Interactivo</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

--------------------------------------

--- INICIO DEL ARCHIVO: package.json ---

{
  "name": "poker-replayer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@kurkle/color": "^0.4.0",
    "@supabase/supabase-js": "^2.58.0",
    "chart.js": "^4.5.0",
    "pinia": "^3.0.3",
    "uuid": "^13.0.0",
    "vite-plugin-pwa": "^1.0.3",
    "vue": "^3.5.21",
    "vue-chartjs": "^5.3.2",
    "vue-i18n": "^11.1.12"
  },
  "devDependencies": {
    "@pinegrow/vite-plugin": "^3.0.69",
    "@vitejs/plugin-vue": "^6.0.1",
    "sharp": "^0.34.4",
    "vite": "^7.1.6"
  }
}


----------------------------------------

--- INICIO DEL ARCHIVO: public/icons/all-in-icon.svg ---

<svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="triangleGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#ff4444;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#cc0000;stop-opacity:1" />
    </linearGradient>
  </defs>
  <polygon points="60,11 109,101 11,101" fill="url(#triangleGradient)" stroke="#000000" stroke-width="5" rx="6" ry="6" />
  <text x="60" y="71" text-anchor="middle" font-family="Arial Black, sans-serif" font-size="22" font-weight="bold" fill="#ffffff">All-in</text>
</svg>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: public/vite.svg ---

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

-------------------------------------------

--- INICIO DEL ARCHIVO: src/App.vue ---

<template>
  <div v-if="authStore.user" id="main-container">
    <main>
      <KeepAlive>
        <component :is="views[currentView]" @switch-view="switchToView" />
      </KeepAlive>
    </main>

    <!-- Menú "Más" (Overlay) -->
    <div v-if="showMoreMenu" class="more-menu-overlay" @click="showMoreMenu = false">
      <div class="more-menu-panel" @click.stop>
        <button @click="navigateTo('SavedHandsView')">{{ $t('nav.savedHands') }}</button>
        <button @click="navigateTo('ChartsView')">{{ $t('nav.charts') }}</button>
        <button @click="navigateTo('CommunityView')">Viajes</button>
        <button @click="navigateTo('SavedTripsView')">Viajes Guardados</button>
        <button @click="navigateTo('SettingsView')">{{ $t('nav.settings') }}</button>
        <button @click="authStore.signOut()" class="logout-btn">Salir</button>
      </div>
    </div>

    <!-- Barra de Navegación Inferior -->
    <nav>
      <button @click="switchToView('CurrentHandView')" :class="{ active: currentView === 'CurrentHandView' }">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 7.5l-2.25-1.313M21 7.5v2.25m0-2.25l-2.25 1.313M3 7.5l2.25-1.313M3 7.5l2.25 1.313M3 7.5v2.25m9 3l2.25-1.313M12 12.75l-2.25 1.313M12 12.75V15m0 6.75l2.25-1.313M12 21.75V19.5m0 2.25l-2.25-1.313m0-16.875L12 2.25l2.25 1.313M21 14.25v2.25l-2.25 1.313m-13.5 0L3 16.5v-2.25" /></svg>
        <span>{{ $t('nav.currentHand') }}</span>
      </button>
      <button @click="switchToView('LiveSessionView')" :class="{ active: currentView === 'LiveSessionView' }">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        <span>{{ $t('nav.liveSession') }}</span>
      </button>
      <button @click="switchToView('SavedSessionsView')" :class="{ active: currentView === 'SavedSessionsView' }">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 12h16.5m-16.5 3.75h16.5M3.75 19.5h16.5M5.625 4.5h12.75a1.875 1.875 0 010 3.75H5.625a1.875 1.875 0 010-3.75z" /></svg>
        <span>{{ $t('nav.savedSessions') }}</span>
      </button>
      <button @click="switchToView('SummaryView')" :class="{ active: currentView === 'SummaryView' }">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" /></svg>
        <span>{{ $t('nav.summary') }}</span>
      </button>
      <button @click="showMoreMenu = !showMoreMenu" :class="{ active: showMoreMenu }">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM12.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0zM18.75 12a.75.75 0 11-1.5 0 .75.75 0 011.5 0z" /></svg>
        <span>Más</span>
      </button>
    </nav>

  </div>
  <AuthView v-else />
  <RotateDeviceOverlay v-if="isLandscape" />
</template>

<script setup>
import { ref, shallowRef, onMounted, onUnmounted } from 'vue';
import { useTripStore } from './store/useTripStore';
import { useAuthStore } from './store/useAuthStore';
import RotateDeviceOverlay from './components/RotateDeviceOverlay.vue';
import CurrentHandView from './views/CurrentHandView.vue';
import SavedHandsView from './views/SavedHandsView.vue';
import LiveSessionView from './views/LiveSessionView.vue';
import SavedSessionsView from './views/SavedSessionsView.vue';
import ChartsView from './views/ChartsView.vue';
import SettingsView from './views/SettingsView.vue';
import SummaryView from './views/SummaryView.vue';
import CommunityView from './views/CommunityView.vue';
import SavedTripsView from './views/SavedTripsView.vue';
import AuthView from './views/AuthView.vue';

const authStore = useAuthStore();
const currentView = ref('CurrentHandView');
const tripStore = useTripStore();
const showMoreMenu = ref(false);
const isLandscape = ref(false);

const views = shallowRef({
  CurrentHandView,
  SavedHandsView,
  LiveSessionView,
  SavedSessionsView,
  ChartsView,
  SettingsView,
  SummaryView,
  CommunityView,
  SavedTripsView,
});

function switchToView(viewName) {
  if (viewName === undefined) {
    currentView.value = 'CurrentHandView';
    return;
  }
  
  if (viewName === 'CommunityView' && currentView.value !== 'SavedTripsView') {
      tripStore.resetCurrentTrip();
  }

  currentView.value = viewName;
  showMoreMenu.value = false;
}

function navigateTo(viewName) {
  switchToView(viewName);
}

onMounted(() => {
  const mediaQuery = window.matchMedia('(orientation: landscape)');
  isLandscape.value = mediaQuery.matches;
  mediaQuery.addEventListener('change', (e) => {
    isLandscape.value = e.matches;
  });
});
</script>

<style scoped>
#main-container {
  width: 100%;
}

main {
  width: 100%;
}

nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 70px;
  background-color: #2d3748;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: space-around;
  align-items: center;
  z-index: 1000;
  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
}

nav button {
  background-color: transparent;
  border: none;
  color: #a0aec0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  height: 100%;
  flex-grow: 1;
  font-size: 0.75rem;
}

nav button svg {
  width: 24px;
  height: 24px;
}

nav button.active {
  color: var(--primary-color);
}

@media (hover: hover) and (pointer: fine) {
  nav button:not(.active):hover {
      background-color: rgba(74, 85, 104, 0.2);
  }
}

.more-menu-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.6);
  z-index: 1001;
  display: flex;
  justify-content: center;
  align-items: flex-end;
}

.more-menu-panel {
  background-color: #2d3748;
  width: 100%;
  max-width: 500px;
  border-top-left-radius: 12px;
  border-top-right-radius: 12px;
  padding: 1rem;
  padding-bottom: 90px;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  animation: slide-up 0.3s ease-out;
}

.more-menu-panel button {
  width: 100%;
  padding: 1rem;
  font-size: 1.1rem;
  text-align: left;
  background-color: #4a5568;
  border: none;
}

.more-menu-panel button.logout-btn {
  border-top: 1px solid var(--border-color);
  margin-top: 0.5rem;
  color: #fc8181;
}

@keyframes slide-up {
  from { transform: translateY(100%); }
  to { transform: translateY(0); }
}
</style>

---------------------------------------

--- INICIO DEL ARCHIVO: src/api/index.js ---

import { supabase } from '@/supabase';
import { useAuthStore } from '@/store/useAuthStore';

/**
 * ============================================================================
 * ARCHIVO CENTRAL DE OPERACIONES DE BASE DE DATOS
 * ============================================================================
 */

// Función auxiliar para obtener el usuario actual de forma segura
const getCurrentUser = async () => {
  console.log('[DEBUG] getCurrentUser: Starting...');

  // First, try to get user from authStore (reactive and up-to-date)
  const authStore = useAuthStore();
  if (authStore.user) {
    console.log('[DEBUG] getCurrentUser: User found in authStore, ID:', authStore.user.id);
    return authStore.user;
  }

  console.log('[DEBUG] getCurrentUser: No user in authStore, falling back to Supabase calls...');

  try {
    // Add short timeout to prevent hanging
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Session retrieval timeout')), 3000)
    );

    const sessionPromise = supabase.auth.getSession();
    const { data: { session }, error } = await Promise.race([sessionPromise, timeoutPromise]);
    console.log('[DEBUG] getCurrentUser: getSession returned, session exists:', !!session, 'error:', error ? error.message : 'none');

    if (error) {
      console.error("[DEBUG] getCurrentUser: Error from getSession:", error);
      return null;
    }
    if (!session?.user) {
      console.warn("[DEBUG] getCurrentUser: No session or user found");
      return null;
    }
    console.log('[DEBUG] getCurrentUser: User authenticated via getSession, ID:', session.user.id, 'email:', session.user.email);
    return session.user;
  } catch (timeoutError) {
    console.error('[DEBUG] getCurrentUser: Timeout or error getting session:', timeoutError.message);
    // As fallback, try to get user directly
    console.log('[DEBUG] getCurrentUser: Attempting fallback with getUser...');
    try {
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      if (userError) {
        console.error('[DEBUG] getCurrentUser: getUser error:', userError);
        return null;
      }
      if (user) {
        console.log('[DEBUG] getCurrentUser: Fallback successful, user ID:', user.id);
        return user;
      }
    } catch (fallbackError) {
      console.error('[DEBUG] getCurrentUser: Fallback failed:', fallbackError.message);
    }
    return null;
  }
};


// ----------------------------------------------------------------------------
// API para Sesiones de Juego (sesiones_juego)
// ----------------------------------------------------------------------------

export const apiFetchSessions = async () => {
  const user = await getCurrentUser();
  if (!user) return [];

  const { data, error } = await supabase
    .from('sesiones_juego')
    .select('*')
    .eq('usuario_id', user.id)
    .order('fecha', { ascending: false });

  if (error) {
    console.error("Error en apiFetchSessions:", error);
    throw error;
  }
  return data;
};

export const apiAddSession = async (sessionData) => {
  const user = await getCurrentUser();
  if (!user) throw new Error("Usuario no autenticado");

  const dataToInsert = { ...sessionData, usuario_id: user.id };
  
  const { data, error } = await supabase
    .from('sesiones_juego')
    .insert(dataToInsert)
    .select()
    .single();

  if (error) {
    console.error("Error en apiAddSession:", error);
    throw error;
  }
  return data;
};

export const apiDeleteSession = async (sessionId) => {
  const { error } = await supabase
    .from('sesiones_juego')
    .delete()
    .eq('id', sessionId);

  if (error) {
    console.error("Error en apiDeleteSession:", error);
    throw error;
  }
};

// ----------------------------------------------------------------------------
// API para Manos Guardadas (manos_guardadas)
// ----------------------------------------------------------------------------

export const apiFetchHands = async (date = null, limit = null, offset = 0) => {
  console.log('[DEBUG] apiFetchHands: Starting with params - date:', date, 'limit:', limit, 'offset:', offset);
  const user = await getCurrentUser();
  console.log('[DEBUG] apiFetchHands: User obtained:', user ? `ID: ${user.id}` : 'not authenticated');

  console.log('[DEBUG] apiFetchHands: Building query...');
  let query = supabase
    .from('manos_guardadas')
    .select('*');

  // Re-enable user filter - ensure RLS policy allows select for authenticated users
  if (user) {
    query = query.eq('usuario_id', user.id);
    console.log('[DEBUG] apiFetchHands: Added user filter for ID:', user.id);
  } else {
    console.log('[DEBUG] apiFetchHands: No user filter applied');
  }

  if (date) {
    const startDate = new Date(date);
    startDate.setHours(0, 0, 0, 0);
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 1);
    query = query.gte('fecha_creacion', startDate.toISOString()).lt('fecha_creacion', endDate.toISOString());
    console.log('[DEBUG] apiFetchHands: Added date filter from', startDate.toISOString(), 'to', endDate.toISOString());
  }

  query = query.order('fecha_creacion', { ascending: false });
  console.log('[DEBUG] apiFetchHands: Added ordering by fecha_creacion desc');

  if (limit !== null && limit !== undefined) {
    query = query.range(offset || 0, (offset || 0) + limit - 1);
    console.log('[DEBUG] apiFetchHands: Added range from', offset || 0, 'to', (offset || 0) + limit - 1);
  }

  console.log('[DEBUG] apiFetchHands: Executing query...');

  // Add timeout to prevent hanging
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Query timeout after 10 seconds')), 10000)
  );

  const queryPromise = query;
  const { data, error } = await Promise.race([queryPromise, timeoutPromise]);

  console.log('[DEBUG] apiFetchHands: Query completed - error:', error ? `${error.message} (code: ${error.code})` : 'none', 'data count:', data ? data.length : 'null');

  if (error) {
    console.error("[DEBUG] apiFetchHands: Full error object:", error);
    throw error;
  }

  console.log('[DEBUG] apiFetchHands: Returning data array of length:', data?.length || 0);
  return data;
};

export const apiAddHand = async (handData) => {
  const user = await getCurrentUser();
  if (!user) throw new Error("Usuario no autenticado");

  const dataToInsert = { ...handData, usuario_id: user.id };

  const { data, error } = await supabase
    .from('manos_guardadas')
    .insert(dataToInsert)
    .select()
    .single();

  if (error) {
    console.error("Error en apiAddHand:", error);
    throw error;
  }
  return data;
};

export const apiDeleteHand = async (handId) => {
  const { error } = await supabase
    .from('manos_guardadas')
    .delete()
    .eq('id', handId);

  if (error) {
    console.error("Error en apiDeleteHand:", error);
    throw error;
  }
};

// ----------------------------------------------------------------------------
// API para Viajes de Poker (viajes_poker y relacionadas)
// ----------------------------------------------------------------------------

export const apiFetchTrips = async () => {
    const user = await getCurrentUser();
    if (!user) return [];

    const { data: viajes, error: viajesError } = await supabase
        .from('viajes_poker')
        .select(`*, participantes_viaje(*), resultados_diarios_viaje(*)`)
        .eq('creador_id', user.id)
        .order('fecha_creacion', { ascending: false });

    if (viajesError) {
        console.error("Error en apiFetchTrips:", viajesError);
        throw viajesError;
    }

    return viajes.map(viaje => {
        const dailyResults = {};
        const tripDays = [];
        viaje.resultados_diarios_viaje.forEach(r => {
            const fecha = r.fecha;
            if (!dailyResults[fecha]) {
                dailyResults[fecha] = {};
                tripDays.push(fecha);
            }
            const participante = viaje.participantes_viaje.find(p => p.id === r.participante_id);
            if (participante) {
                dailyResults[fecha][participante.id] = {
                    result: r.resultado,
                    hours: r.horas_jugadas,
                    stake: r.stake
                };
            }
        });
        
        return { ...viaje, players: viaje.participantes_viaje.map(p => ({
            id: p.id,
            name: p.nombre_jugador,
            individualBankroll: p.aportacion_banca,
            participation: p.porcentaje_participacion
        })), tripDays: tripDays.sort(), dailyResults };
    });
};

// *** FUNCIÓN COMPLETAMENTE REESCRITA PARA SIMPLIFICAR ***
export const apiAddOrUpdateTrip = async (tripData) => {
    const user = await getCurrentUser();
    if (!user) throw new Error("Usuario no autenticado");
    
    let tripId = tripData.id;

    // PASO 1: Insertar o actualizar el viaje principal.
    const tripPayload = {
        creador_id: user.id,
        ciudad: tripData.city,
        casino: tripData.casino,
        moneda: tripData.currency,
        tipo_reparto: tripData.repartoType,
        activo: tripData.isTripActive,
        fecha_viaje: new Date().toISOString().split('T')[0],
    };

    if (tripId) { // Es una actualización
        tripPayload.id = tripId;
        const { error } = await supabase.from('viajes_poker').update(tripPayload).eq('id', tripId);
        if (error) throw new Error(`Error actualizando el viaje principal: ${error.message}`);
    } else { // Es una inserción
        const { data, error } = await supabase.from('viajes_poker').insert(tripPayload).select('id').single();
        if (error) throw new Error(`Error creando el viaje principal: ${error.message}`);
        tripId = data.id;
    }

    // PASO 2: Borrar participantes y resultados antiguos para evitar duplicados.
    await supabase.from('resultados_diarios_viaje').delete().eq('viaje_id', tripId);
    await supabase.from('participantes_viaje').delete().eq('viaje_id', tripId);
    
    // PASO 3: Insertar los nuevos participantes.
    const participantsPayload = tripData.players.map(p => ({
        viaje_id: tripId,
        nombre_jugador: p.name,
        aportacion_banca: p.individualBankroll || 0,
        porcentaje_participacion: p.participation || 0
    }));

    const { data: newParticipants, error: participantsError } = await supabase
        .from('participantes_viaje')
        .insert(participantsPayload)
        .select('id, nombre_jugador');
        
    if (participantsError) throw new Error(`Error guardando participantes: ${participantsError.message}`);

    // PASO 4: Insertar los nuevos resultados diarios.
    const resultsPayload = [];
    Object.entries(tripData.dailyResults).forEach(([date, dailyData]) => {
        Object.entries(dailyData).forEach(([frontendPlayerId, resultData]) => {
            const playerFrontend = tripData.players.find(p => p.id === frontendPlayerId);
            const participantBackend = newParticipants.find(p => p.nombre_jugador === playerFrontend.name);
            if (participantBackend) {
                resultsPayload.push({
                    viaje_id: tripId,
                    participante_id: participantBackend.id,
                    fecha: date,
                    resultado: resultData.result || 0,
                    horas_jugadas: resultData.hours || 0,
                    stake: resultData.stake || ''
                });
            }
        });
    });

    if (resultsPayload.length > 0) {
        const { error: resultsError } = await supabase.from('resultados_diarios_viaje').insert(resultsPayload);
        if (resultsError) throw new Error(`Error guardando resultados diarios: ${resultsError.message}`);
    }

    return tripId; // Devolvemos el ID del viaje guardado/actualizado.
};

export const apiDeleteTrip = async (tripId) => {
    const { error } = await supabase.from('viajes_poker').delete().eq('id', tripId);
    if (error) {
        console.error("Error en apiDeleteTrip:", error);
        throw error;
    }
};

--------------------------------------------

--- INICIO DEL ARCHIVO: src/assets/vue.svg ---

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>

----------------------------------------------

--- INICIO DEL ARCHIVO: src/components/ActionPanel.vue ---

<template>
  <div class="action-panel-wrapper">
    
    <div class="actions-grid">
      <div class="grid-turn-info">{{ $t('actionPanel.turnOf') }} <strong>{{ gameStore.activePlayer?.name }}</strong></div>
      <button @click="gameStore.performAction('fold')" class="grid-fold btn-fold">{{ $t('actionPanel.fold') }}</button>
      <button @click="handleCheckCall" :disabled="isCallDisabled" class="grid-call btn-call">{{ checkOrCallLabel.toUpperCase() }}</button>
      
      <button @click="handleBetRaise" :disabled="isRaiseDisabled" class="grid-raise btn-raise">{{ betOrRaiseLabel.toUpperCase() }}</button>
      
      <input type="number" v-model="displayRaiseAmount" class="grid-input" />
      <div v-if="isAllIn" class="all-in-indicator">▲</div>
      
      <input 
        type="range" 
        :min="minRaiseValue" 
        :max="maxSliderValue"
        :step="gameStore.bigBlind"
        v-model.number="raiseAmount"
        class="grid-slider"
        @wheel="handleWheelScroll"
        :style="sliderStyle" 
      />

      <div class="grid-quick-bets">
        <button @click="setRaiseAmountByPot(0.25)">25%</button>
        <button @click="setRaiseAmountByPot(0.33)">33%</button>
        <button @click="setRaiseAmountByPot(0.50)">50%</button>
        <button @click="setRaiseAmountByPot(0.75)">75%</button>
        <button @click="setRaiseAmountByPot(1)">{{ $t('actionPanel.pot') }}</button>
        <button @click="setRaiseAmountByPot(1.5)">150%</button>
        <button @click="setRaiseAmountToAllIn" class="btn-allin">{{ $t('actionPanel.allIn') }}</button>
      </div>

      <select class="grid-color-select" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)">
        <option value="#28563a">Verde</option>
        <option value="#3a4c8a">Azul</option>
        <option value="#8a3a3a">Rojo</option>
        <option value="#553c9a">Morado</option>
        <option value="#b7791f">Oro</option>
        <option value="#1A202C">Negro</option>
        <option value="#4A5568">Gris</option>
      </select>
      <button class="grid-bbs-toggle" @click="gameStore.toggleDisplayMode()">
        {{ gameStore.displayInBBs ? gameStore.currency : 'BBs' }}
      </button>
      <button @click="gameStore.saveCurrentHand()" class="grid-save btn-save-hand">Guardar Mano</button>
      <button @click="gameStore.navigateHistory(-1)" class="grid-prev btn-nav" v-if="gameStore.gamePhase !== 'replay'">◀</button>
      <button @click="gameStore.navigateHistory(1)" class="grid-next btn-nav" v-if="gameStore.gamePhase !== 'replay'">▶</button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue';
import { useI18n } from 'vue-i18n';
import { useGameStore } from '../store/game';

const { t } = useI18n();

const props = defineProps({ modelValue: String });
const emit = defineEmits(['update:modelValue']);
const gameStore = useGameStore();

const amountToCall = computed(() => {
  if (!gameStore.activePlayer) return 0;
  return gameStore.currentBet - gameStore.activePlayer.betThisRound;
});

const checkOrCallLabel = computed(() => {
  if (amountToCall.value <= 0) return t('actionPanel.check');
  if (gameStore.displayInBBs) {
    const bbValue = (amountToCall.value / gameStore.bigBlind).toFixed(1);
    return `${t('actionPanel.call')} ${bbValue} BB`;
  }
  return `${t('actionPanel.call')} ${amountToCall.value}`;
});

const maxSliderValue = computed(() => {
    if (!gameStore.activePlayer) return 0;
    return gameStore.activePlayer.stack + gameStore.activePlayer.betThisRound;
});

const minRaiseValue = computed(() => {
  if (!gameStore.activePlayer) return 0;
  const raiseDifference = gameStore.currentBet - (gameStore.lastRaiseAmount || 0);
  const min = gameStore.currentBet + Math.max(raiseDifference, gameStore.bigBlind);
  return Math.min(min, maxSliderValue.value);
});

const raiseAmount = ref(minRaiseValue.value);
watch(minRaiseValue, (newVal) => {
    if(raiseAmount.value < newVal) {
        raiseAmount.value = newVal;
    }
});
watch(() => gameStore.activePlayerIndex, () => {
    raiseAmount.value = minRaiseValue.value;
});

const displayRaiseAmount = computed({
  get() {
    if (gameStore.displayInBBs) {
      return (raiseAmount.value / gameStore.bigBlind).toFixed(1);
    }
    return raiseAmount.value;
  },
  set(newValue) {
    if (gameStore.displayInBBs) {
      raiseAmount.value = Math.round(parseFloat(newValue) * gameStore.bigBlind);
    } else {
      raiseAmount.value = parseInt(newValue) || 0;
    }
  }
});

const sliderStyle = computed(() => {
  if (!gameStore.activePlayer) return {};
  const min = minRaiseValue.value;
  const max = maxSliderValue.value;
  const current = raiseAmount.value;
  if (max <= min) {
    return { '--slider-fill-percentage': '100%' };
  }
  const percentage = ((current - min) / (max - min)) * 100;
  return {
    '--slider-fill-percentage': `${percentage}%`
  };
});

const betOrRaiseLabel = computed(() => (gameStore.currentBet > 0 ? t('actionPanel.raise') : t('actionPanel.bet')));
const isCallDisabled = computed(() => !gameStore.activePlayer || amountToCall.value > gameStore.activePlayer.stack);
const isRaiseDisabled = computed(() => !gameStore.activePlayer || raiseAmount.value < minRaiseValue.value || raiseAmount.value > maxSliderValue.value);
const isAllIn = computed(() => gameStore.activePlayer && raiseAmount.value >= gameStore.activePlayer.stack);

function handleCheckCall() {
  const action = amountToCall.value > 0 ? 'call' : 'check';
  gameStore.performAction(action);
}
function handleBetRaise() {
  const action = gameStore.currentBet > 0 ? 'raise' : 'bet';
  gameStore.performAction(action, raiseAmount.value);
}

function setRaiseAmountByPot(multiplier) {
  if (!gameStore.activePlayer) return;
  
  let betValue = Math.round(gameStore.totalPot * multiplier);
  betValue = Math.max(minRaiseValue.value, betValue);
  betValue = Math.min(maxSliderValue.value, betValue);

  raiseAmount.value = betValue;
}

function setRaiseAmountToAllIn() {
  if (!gameStore.activePlayer) return;
  raiseAmount.value = maxSliderValue.value;
}


function handleWheelScroll(event) {
  // event.preventDefault(); // <-- ELIMINADO PARA SOLUCIONAR EL [VIOLATION]
  const step = gameStore.bigBlind;
  let newValue;
  if (event.deltaY < 0) {
    newValue = raiseAmount.value + step;
  } else {
    newValue = raiseAmount.value - step;
  }
  newValue = Math.max(minRaiseValue.value, newValue);
  newValue = Math.min(maxSliderValue.value, newValue);
  raiseAmount.value = newValue;
}
</script>

<style scoped>
.action-panel-wrapper {
  --btn-red: #f95f41;
  --btn-green: #70b75b;
  --btn-orange: #e39e49;
  --btn-purple: #a955cd;
  --btn-grey: #4A5568;
  --slider-color-active: #FAB76B;
  --slider-color-inactive: #1A202C;

  background-color: #2d3748;
  border-radius: 12px;
  padding: clamp(10px, 1.5vw, 20px);
  width: 90%;
  margin-left: 5%;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  border: clamp(2px, 0.4vw, 3px) solid var(--border-color);
  color: white;
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
}

.actions-grid {
 width: 100%;
 display: grid;
 gap: clamp(8px, 1.2vw, 15px);
 align-items: center;
 grid-template-columns: repeat(6, 1fr); /* Aumentado a 6 columnas */
 grid-template-rows: auto auto auto;
 grid-template-areas:
   "fold       call       turn-info  turn-info    color-select bbs-toggle"
   "raise      input      slider     slider       slider       slider"
   "quick-bets quick-bets quick-bets save-hand    prev-action  next-action";
}


.grid-turn-info { grid-area: turn-info; text-align: center; font-size: clamp(1rem, 2.5vmin, 1.4rem); }
.grid-fold { grid-area: fold; }
.grid-call { grid-area: call; }
.grid-raise { grid-area: raise; }
.grid-input { grid-area: input; }
.grid-slider { grid-area: slider; }
.grid-quick-bets { grid-area: quick-bets; }
.grid-color-select { grid-area: color-select; }
.grid-bbs-toggle { grid-area: bbs-toggle; }
.grid-save { grid-area: save-hand; }
.grid-prev { grid-area: prev-action; }
.grid-next { grid-area: next-action; }
 
.grid-fold, .grid-call, .grid-raise, .grid-input, .grid-color-select, .grid-bbs-toggle, .grid-save, .btn-nav {
  height: clamp(50px, 8vmin, 65px);
  font-size: clamp(1.5rem, 2.2vmin, 1.3rem);
  font-weight: bold;
  border-radius: 8px;
  color: white;
  cursor: pointer;
  box-sizing: border-box;
  padding: 1 22px;
  border: 1px solid #000;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 0.5%;
}

.grid-input { background-color: #1A202C; text-align: center; width: 100%; }
.all-in-indicator { display: none; }

.grid-quick-bets { display: grid; grid-template-columns: repeat(auto-fit, minmax(40px, 1fr)); gap: 5px; }
.grid-quick-bets button {
  padding: clamp(6px, 1.5vmin, 12px);
  font-size: clamp(0.8rem, 1.8vmin, 1rem);
  border-radius: 6px;
  background-color: var(--btn-grey);
  color: white;
  cursor: pointer;
  border: 1px solid #000;
}

.grid-color-select, .grid-bbs-toggle { background-color: #718096; }
.btn-fold { background-color: var(--btn-red); }
.btn-call { background-color: var(--btn-green); }
.btn-raise { background-color: var(--btn-orange); }
.btn-allin { background-color: var(--btn-purple) !important; grid-column: 1 / -1; }
.btn-save-hand { background-color: var(--btn-green); }
.btn-nav { background-color: #718096; }
button:disabled, .grid-slider:disabled { background-color: #718096 !important; cursor: not-allowed; opacity: 0.6; }
 
 .grid-slider { -webkit-appearance: none; appearance: none; width: 90%; height: clamp(12px, 2.2vmin, 16px); background: transparent; outline: none; border-radius: 8px; }
.grid-slider::-webkit-slider-runnable-track { width: 100%; height: 100%; cursor: pointer; border-radius: 8px; border: 1px solid #000; background: linear-gradient(to right, var(--slider-color-active) var(--slider-fill-percentage), var(--slider-color-inactive) var(--slider-fill-percentage)); }
.grid-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; border: 1px solid #000; height: calc(clamp(12px, 2.2vmin, 16px) + 14px); width: clamp(15px, 2.5vmin, 20px); border-radius: 4px; background: #E2E8F0; cursor: pointer; margin-top: calc(clamp(12px, 2.2vmin, 16px) / -2 + -7px); }

/* Media query para compactar el layout en contenedores más estrechos que el diseño ideal */
@media (max-width: 900px) {
  .actions-grid {
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto auto auto 1fr auto;
    grid-template-areas:
     "turn-info  turn-info"
     "fold       call"
     "raise      input"
     "slider     slider"
     "quick-bets quick-bets"
     "save-hand  save-hand"
     "prev-action next-action"
     "bbs-toggle color-select";
 }
}

/* Media query para mover el panel a la derecha en móviles horizontales */
@media screen and (orientation: landscape) and (max-height: 600px) {
  .action-panel-wrapper {
    margin-left: auto;
    margin-right: 0;
  }
}
</style>

----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/CardPicker.vue ---

<template>
  <div class="modal-overlay" @click.self="gameStore.closeCardPicker()">
    <div class="card-picker-content">
      <div v-for="suit in deck" :key="suit.name" class="suit-row">
        <div
          v-for="card in suit.cards"
          :key="card.id"
          class="card"
          :class="[suit.colorClass, { disabled: gameStore.usedCards.has(card.id) }]"
          @click="selectCard(card)"
        >
          {{ card.rank }}
          <span class="suit-icon" v-html="suit.icon"></span>
        </div>
      </div>
      <button class="close-btn" @click="gameStore.closeCardPicker()">Cerrar</button>
    </div>
  </div>
</template>

<script setup>
import { useGameStore } from '../store/game';

const gameStore = useGameStore();

const ranks = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];
const suits = [
  { name: 'Spades', id: 'S', icon: '&spades;', colorClass: 'black' },
  { name: 'Hearts', id: 'H', icon: '&hearts;', colorClass: 'red' },
  { name: 'Clubs', id: 'C', icon: '&clubs;', colorClass: 'green' },
  { name: 'Diamonds', id: 'D', icon: '&diams;', colorClass: 'blue' },
];

const deck = suits.map(suit => ({
  ...suit,
  cards: ranks.map(rank => ({
    id: rank + suit.id,
    rank: rank,
  }))
}));

function selectCard(card) {
  if (gameStore.usedCards.has(card.id)) return;
  gameStore.assignCard(card.id);
}
</script>

<style scoped>
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex; justify-content: center; align-items: center; z-index: 2000;
  padding: 1rem;
}
.card-picker-content {
  background-color: #1a202c;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.suit-row {
  display: flex;
  gap: 0.5rem;
}
.card {
  width: 50px; height: 70px;
  border: 1px solid #4A5568;
  border-radius: 6px;
  display: flex; flex-direction: column;
  justify-content: center; align-items: center;
  font-family: 'Arial Black', sans-serif; font-size: 1.8rem; font-weight: bold;
  cursor: pointer;
  color: white;
  user-select: none;
  transition: transform 0.1s, box-shadow 0.1s;
}
.card:hover {
  transform: scale(1.05);
  box-shadow: 0 0 15px #f6e05e;
}
.suit-icon {
  font-size: 1.2rem;
  line-height: 1;
}
.card.black { background-color: #2d3748; }
.card.red { background-color: #c53030; }
.card.green { background-color: #2f855a; }
.card.blue { background-color: #2b6cb0; }

.card.disabled {
  background-color: #4a5568;
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}
.card.disabled:hover {
  transform: none;
  box-shadow: none;
}
.close-btn {
  margin-top: 1rem;
  padding: 10px;
  font-size: 1rem;
}

@media (max-width: 768px) {
  .card-picker-content {
    padding: 0.75rem;
    gap: 0.5rem;
  }
  .suit-row {
    gap: 0.25rem;
  }
  .card {
    width: clamp(28px, 6vw, 40px); /* Ancho fluido */
    height: clamp(40px, 8.4vw, 56px); /* Alto fluido */
    font-size: clamp(1rem, 3vw, 1.5rem); /* Fuente fluida */
    border-radius: 4px;
  }
  .suit-icon {
    font-size: clamp(0.7rem, 2vw, 1rem);
  }
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/ChipStack.vue ---

<template>
  <div class="chip-stack-container">
    <div v-if="stackDetails.count > 0" class="chip-stack">
      <div
        v-for="i in stackDetails.count"
        :key="i"
        class="chip"
        :style="{
          backgroundColor: stackDetails.color,
          bottom: (i - 1) * 3 + 'px', // Reducimos el espaciado para un stack más compacto
          zIndex: stackDetails.count - i,
          '--chip-color': stackDetails.color, // Pasamos el color como variable CSS
        }"
      ></div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  amount: {
    type: Number,
    required: true,
  },
  bigBlind: {
    type: Number,
    required: true,
  },
});

const chipDenominations = [
  { value: 1000, color: '#D6A2E8' },
  { value: 500, color: '#82589F' },
  { value: 100, color: '#1A202C' },
  { value: 25, color: '#2F855A' },
  { value: 5, color: '#C53030' },
  { value: 1, color: '#E2E8F0' },
];

const stackDetails = computed(() => {
  if (props.amount <= 0) {
    return { color: 'transparent', count: 0 };
  }

  const primaryChip = chipDenominations.find(chip => props.amount >= chip.value) || chipDenominations[chipDenominations.length - 1];
  const betInBBs = props.amount / props.bigBlind;

  // --- LÓGICA DE CANTIDAD DE FICHAS AJUSTADA ---
  let count;
  if (betInBBs <= 1) {       // Apuestas mínimas (ciegas, limps)
    count = 2;
  } else if (betInBBs <= 5) { // Apuestas de continuación pequeñas
    count = 4;
  } else if (betInBBs <= 15) { // Subidas estándar, 3-bets
    count = 6;
  } else if (betInBBs <= 40) { // Apuestas grandes en el turn/river
    count = 8;
  } else if (betInBBs <= 100) { // Botes muy grandes
    count = 10;
  } else {                   // All-ins enormes
    count = 12; // Máximo de 12 fichas para mantenerlo visualmente limpio
  }

  return {
    color: primaryChip.color,
    count: count,
  };
});
</script>

<style scoped>
/* --- ESTILOS 3D COMPLETAMENTE NUEVOS --- */
.chip-stack-container {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  height: 30px;
  width: 45px;
  /* La perspectiva es clave para el efecto 3D */
  perspective: 500px;
}

.chip-stack {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
}

.chip {
  position: absolute;
  width: 15px;
  height: 25px;
  border-radius: 50%;
  box-sizing: border-box;
  left: 15px; /* Centrado en el contenedor de 45px */
  
  /* --- EFECTO 3D Y REALISMO --- */

  /* 1. Inclinación para dar perspectiva */
  transform: rotateX(70deg); 
  
  /* 2. Sombra proyectada por la ficha */
  box-shadow: 0 10px 8px rgba(0, 0, 0, 0.4);

  /* 3. Grosor y color del borde de la ficha */
  border-bottom: 5px solid color-mix(in srgb, var(--chip-color) 70%, black);

  /* 4. Reflejo de luz en la parte superior para dar volumen */
  background-image: radial-gradient(
    circle at 50% 10%, 
    rgba(255, 255, 255, 0.6), 
    transparent 70%
  );
}

/* Detalle de las franjas en la cara de la ficha */
.chip::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 85%;
  height: 85%;
  border-radius: 50%;
  /* Usamos un borde discontinuo para un look clásico */
  border: 2px dashed color-mix(in srgb, var(--chip-color) 60%, white);
  opacity: 0.8;
}
</style>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/ConfigurationModal.vue ---

<template>
  <div class="modal-overlay">
    <div class="modal-content">
      <h3>Selecciona tu Posición (Hero)</h3>
      <div class="positions-grid">
        <button
          v-for="pos in positions"
          :key="pos"
          @click="selectedPosition = pos"
          :class="{ selected: selectedPosition === pos }"
        >
          {{ pos }}
        </button>
      </div>
      <button class="confirm-btn" @click="$emit('confirm', selectedPosition)" :disabled="!selectedPosition">
        Confirmar e Iniciar Mano
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';

defineProps({
  positions: Array,
});
defineEmits(['confirm']);

const selectedPosition = ref(null);
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: 1rem;
}
.modal-content {
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  width: 100%;
  max-width: 500px;
  text-align: center;
}
h3 {
  margin-top: 0;
  font-size: 1.5rem;
}
.positions-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
  gap: 10px;
  margin: 2rem 0;
}
.positions-grid button {
  padding: 15px;
  font-size: 1rem;
  font-weight: bold;
  background-color: var(--btn-grey, #4A5568);
  border: 2px solid transparent;
}
.positions-grid button.selected {
  background-color: var(--primary-color);
  border-color: #f6e05e;
}
.confirm-btn {
  width: 100%;
  padding: 15px;
  font-size: 1.2rem;
  font-weight: bold;
}

@media (max-width: 480px) {
  .modal-content {
    padding: 1.5rem;
  }
  .positions-grid button {
    padding: 12px;
    font-size: 0.9rem;
  }
  .confirm-btn {
    padding: 12px;
    font-size: 1.1rem;
  }
}
</style>

-----------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/DisplayOptions.vue ---

<template>
  <!-- Se ha eliminado la lógica de arrastre y el posicionamiento absoluto -->
  <div class="display-options-wrapper">
    <h3>Opciones Replay</h3>
    <div class="options-row">
      <label for="table-color-select">Color Mesa:</label>
      <select id="table-color-select" class="option-item" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)">
        <option value="#28563a">Verde</option>
        <option value="#3a4c8a">Azul</option>
        <option value="#8a3a3a">Rojo</option>
        <option value="#553c9a">Morado</option>
        <option value="#b7791f">Oro</option>
        <option value="#1A202C">Negro</option>
        <option value="#4A5568">Gris</option>
      </select>
    </div>
     <div class="options-row">
       <label>Modo Display:</label>
      <button class="option-item" @click="gameStore.toggleDisplayMode()">
        {{ gameStore.displayInBBs ? gameStore.currency : 'BBs' }}
      </button>
    </div>
    <div class="options-row">
       <label>Controles:</label>
      <button class="option-item" @click="gameStore.navigateHistory(-1)">◀</button>
      <button class="option-item" @click="gameStore.toggleReplay()">
        {{ gameStore.isReplaying ? '⏸️' : '▶️' }}
      </button>
      <button class="option-item" @click="gameStore.navigateHistory(1)">▶</button>
    </div>
     <div class="options-row">
       <label for="replay-speed-select">Velocidad:</label>
       <select id="replay-speed-select" class="option-item" @change="gameStore.setReplaySpeed($event.target.value)">
        <option value="2000">1x</option>
        <option value="1000">2x</option>
        <option value="500">4x</option>
      </select>
    </div>
  </div>
</template>

<script setup>
// Se eliminan los imports que ya no son necesarios (ref, onMounted, onUnmounted)
import { useGameStore } from '../store/game';

// Las props y emits se mantienen igual
defineProps({
  modelValue: String
});
defineEmits(['update:modelValue']);

const gameStore = useGameStore();

// Se ha eliminado toda la lógica de JavaScript relacionada con el arrastre del panel.
</script>

<style scoped>
/* Estilos completamente nuevos para que el componente se comporte como un panel fijo */
.display-options-wrapper {
  background-color: #2d3748;
  border-radius: 12px;
  padding: clamp(10px, 1.5vw, 20px);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  border: clamp(2px, 0.4vw, 3px) solid var(--border-color);
  color: white;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: clamp(10px, 1.5vh, 20px);
  align-items: center;
  justify-content: center; /* Centra el contenido verticalmente */
  width: 100%; /* Ocupa todo el ancho de su celda en el grid */
  height: 100%; /* Ocupa toda la altura de su celda en el grid */
}

h3 {
  margin: 0 0 1rem 0;
  font-size: clamp(1.2rem, 3vmin, 1.6rem);
  font-weight: bold;
  color: white;
  text-align: center;
}

.options-row {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.options-row label {
  font-weight: bold;
  color: #a0aec0;
  flex-shrink: 0;
}

.option-item {
  height: clamp(35px, 6vmin, 50px);
  padding: 0 10px;
  font-size: clamp(0.9rem, 2.5vmin, 1.2rem);
  font-weight: bold;
  border: 1px solid #000;
  border-radius: 8px;
  background-color: #718096;
  color: white;
  cursor: pointer;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

select.option-item {
  flex-grow: 1;
}

button.option-item {
  min-width: 50px;
}
</style>

-------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/EndSessionModal.vue ---

<template>
  <div class="modal-overlay" @click.self="cancel">
    <div class="modal-content">
      <h3>Finalizar Sesión</h3>
      
      <div class="summary">
        <div class="summary-item"><span>Buy-in Inicial:</span> <span>{{ sessionStore.currency }}{{ sessionStore.initialStack }}</span></div>
        <div class="summary-item"><span>Rebuys/Add-ons:</span> <span>{{ sessionStore.currency }}{{ sessionStore.totalRebuys }}</span></div>
        <div class="summary-item"><span>Gastos (propinas, etc.):</span> <span>- {{ sessionStore.currency }}{{ sessionStore.totalExpenses }}</span></div>
        <hr>
        <div class="summary-item total-investment"><span>Inversión Total:</span> <span>{{ sessionStore.currency }}{{ totalInvestment }}</span></div>
      </div>

      <div class="final-stack-input">
        <label for="final-stack">Introduce tu Stack Final:</label>
        <div class="input-group">
          <span>{{ sessionStore.currency }}</span>
          <input id="final-stack" type="number" v-model.number="finalStack" placeholder="Stack al finalizar" ref="inputRef">
        </div>
      </div>
      
      <div class="result-display" :class="resultClass">
        <h4>Resultado de la Sesión</h4>
        <p>{{ sessionResult >= 0 ? '+' : '' }}{{ sessionStore.currency }}{{ sessionResult.toFixed(2) }}</p>
      </div>

      <div class="modal-actions">
        <button class="btn-cancel" @click="cancel" :disabled="isSaving">Cancelar</button>
        <button class="btn-confirm" @click="confirm" :disabled="finalStack === null || finalStack < 0 || isSaving">
          {{ isSaving ? 'Guardando...' : 'Confirmar y Guardar' }}
        </button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useSessionStore } from '../store/useSessionStore';

const props = defineProps({
  isSaving: {
    type: Boolean,
    default: false,
  },
});

const emit = defineEmits(['confirm', 'cancel']);
const sessionStore = useSessionStore();

const finalStack = ref(null);
const inputRef = ref(null);

const totalInvestment = computed(() => sessionStore.initialStack + sessionStore.totalRebuys);
const sessionResult = computed(() => {
  if (finalStack.value === null || finalStack.value < 0) return 0;
  return finalStack.value - totalInvestment.value - sessionStore.totalExpenses;
});

const resultClass = computed(() => {
  if (sessionResult.value > 0) return 'profit';
  if (sessionResult.value < 0) return 'loss';
  return 'even';
});

function confirm() {
  emit('confirm', finalStack.value);
}

function cancel() {
  if (props.isSaving) return;
  emit('cancel');
}

onMounted(() => {
  inputRef.value?.focus();
});
</script>

<style scoped>
.modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.8);display:flex;justify-content:center;align-items:center;z-index:2000; padding: 1rem;}
.modal-content{background-color:#2d3748;padding:2rem;border-radius:12px;border:1px solid var(--border-color);width:100%;max-width:450px;text-align:center}
h3{margin-top:0;font-size:1.8rem}
.summary{text-align:left;margin:1.5rem 0;font-size:1.1rem}
.summary-item{display:flex;justify-content:space-between;padding:.5rem 0}
.total-investment{font-weight:700;border-top:1px solid var(--border-color);margin-top:.5rem;padding-top:.5rem}
.final-stack-input{margin:1.5rem 0}
.final-stack-input label{display:block;margin-bottom:.5rem;font-weight:700}
.input-group{display:flex;align-items:center;background-color:#1a202c;border-radius:6px;border:1px solid var(--border-color)}
.input-group span{padding:0 15px;font-size:1.2rem;color:#a0aec0}
.input-group input{flex-grow:1;background:0 0;border:none;font-size:1.5rem;padding:15px;color:#fff;outline:0}
.result-display{margin:1.5rem 0;padding:1rem;border-radius:8px}
.result-display h4{margin:0 0 .5rem}
.result-display p{margin:0;font-size:2.5rem;font-weight:700}
.result-display.profit{background-color:rgba(47,133,90,.3);color:#68d391}
.result-display.loss{background-color:rgba(197,48,48,.3);color:#fc8181}
.result-display.even{background-color:rgba(74,85,104,.3);color:#a0aec0}
.modal-actions{display:flex;gap:1rem;margin-top:2rem}
.modal-actions button{flex-grow:1;padding:15px;font-size:1.1rem;font-weight:700}
.btn-cancel{background-color:#718096}
.btn-confirm{background-color:#48bb78}

@media (max-width: 480px) {
  .modal-content {
    padding: 1.5rem;
  }
  h3 {
    font-size: 1.5rem;
  }
  .summary {
    font-size: 1rem;
  }
  .input-group input {
    font-size: 1.2rem;
    padding: 12px;
  }
  .result-display p {
    font-size: 2rem;
  }
  .modal-actions button {
    padding: 12px;
    font-size: 1rem;
  }
}
</style>

--------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/HelloWorld.vue ---

<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>


---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/Player.vue ---

<template>
  <div class="player-container" :style="seatStyle" :class="{ 'is-9-max': playerCount >= 9 }">

    <div class="player-cards">
        <div class="card-placeholder" @click="handleCardClick(player.id, 0)">
          <PlayingCard v-if="player.cards[0]" :cardId="player.cards[0]" />
          <svg v-else width="100%" height="100%" viewBox="0 0 100 140" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="100" height="140" rx="8" fill="#4A5568"/>
            <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="white" font-size="60" font-weight="bold">+</text>
          </svg>
        </div>
        <div class="card-placeholder" @click="handleCardClick(player.id, 1)">
          <PlayingCard v-if="player.cards[1]" :cardId="player.cards[1]" />
          <svg v-else width="100%" height="100%" viewBox="0 0 100 140" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="100" height="140" rx="8" fill="#4A5568"/>
            <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="white" font-size="60" font-weight="bold">+</text>
          </svg>
        </div>
    </div>
    
    <div class="player-seat" :class="{ faded: !player.inHand, active: isActivePlayer, 'is-hero': player.name === 'Hero' }">
      
      <div v-if="player.isDealer" class="dealer-button" :style="dealerButtonStyle">D</div>

      <div class="player-info-panel">
        <div class="player-info">
          <div class="player-name">
            <span v-if="player.tag" class="player-tag" :style="{ backgroundColor: player.tag }"></span>
            <div v-if="gameStore.isPreActionPhase" class="editable-name-wrapper">
              <input
                type="text"
                :value="player.name"
                @change="gameStore.updatePlayerName(player.id, $event.target.value)"
                class="player-input player-name-input"
              />
              <span class="player-position-static">({{ player.position }})</span>
            </div>
            <span v-else>{{ player.name }} ({{ player.position }})</span>
          </div>
          <div class="player-stack">
            <div v-if="gameStore.isPreActionPhase" class="stack-input-wrapper">
              <span>{{ gameStore.currency }}</span>
              <input
                type="number"
                :value="player.stack"
                @change="gameStore.updatePlayerStack(player.id, $event.target.value)"
                class="player-input player-stack-input"
              />
            </div>
            <span v-else>
              <span v-if="!gameStore.displayInBBs">{{ gameStore.currency }}{{ player.stack }}</span>
              <span v-else>{{ (player.stack / gameStore.bigBlind).toFixed(1) }} BBs</span>
            </span>
          </div>
        </div>
      </div>
      
      <button v-if="gameStore.isPreActionPhase" @click="gameStore.toggleNotesPanel(player.id)" class="edit-notes-btn" ref="editBtnRef">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
        </svg>
      </button>

      <div v-if="!gameStore.isPreActionPhase && player.notes" class="notes-display-wrapper">
        <svg class="notes-display-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
        </svg>
        <div class="notes-tooltip">{{ player.notes }}</div>
      </div>
    </div>

    <div v-if="isNotesPanelOpen" class="notes-panel" :style="notesPanelStyle" ref="notesPanelRef">
      <textarea
        :value="player.notes"
        @input="gameStore.updatePlayerNotes(player.id, $event.target.value)"
        placeholder="Notas sobre el jugador..."
      ></textarea>
      <div class="tags-container">
        <div
          v-for="color in tagColors"
          :key="color"
          class="tag-selector"
          :class="{ selected: player.tag === color }"
          :style="{ backgroundColor: color }"
          @click="gameStore.updatePlayerTag(player.id, color)"
        ></div>
      </div>
    </div>

    <div v-if="player.betThisRound > 0" class="bet-box" :style="betBoxStyle">
      <ChipStack :amount="player.betThisRound" :bigBlind="gameStore.bigBlind" />
      <div class="bet-info">
        <div class="bet-amount-container">
          <div class="bet-amount-text">
            <span v-if="!gameStore.displayInBBs">{{ gameStore.currency }}{{ player.betThisRound }}</span>
            <span v-else>{{ (player.betThisRound / gameStore.bigBlind).toFixed(1) }}</span>
          </div>
        </div>
        <img v-if="player.isAllIn" src="/icons/all-in-icon.svg" alt="All-in" class="all-in-icon" />
      </div>
    </div>

  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useGameStore } from '../store/game'
import PlayingCard from './PlayingCard.vue';
import ChipStack from './ChipStack.vue';

const notesPanelRef = ref(null);
const editBtnRef = ref(null);

const tagColors = ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef'];

const props = defineProps({
  player: Object,
  playerCount: Number,
  index: Number,
  heroIndex: Number,
})

const gameStore = useGameStore();

const isNotesPanelOpen = computed(() => gameStore.openNotesPanelPlayerId === props.player.id);

function handleCardClick(playerId, cardIndex) {
  if (gameStore.gamePhase === 'replay') return;
  const target = { type: 'player', id: playerId, cardIndex: cardIndex };
  if (props.player.cards[cardIndex]) {
    gameStore.unassignCard(target);
  } else {
    gameStore.openCardPicker(target);
  }
}

function handleClickOutside(event) {
  if (isNotesPanelOpen.value && notesPanelRef.value && !notesPanelRef.value.contains(event.target) && editBtnRef.value && !editBtnRef.value.contains(event.target)) {
    gameStore.closeNotesPanel();
  }
}

onMounted(() => {
  document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
});

const isActivePlayer = computed(() => gameStore.activePlayerIndex === props.player.id);

// --- LÓGICA DE POSICIONAMIENTO DE ASIENTOS (MODIFICADA PARA RESPONSIVE) ---
// Las coordenadas ahora son porcentajes del radio de la mesa (ej: x: 50 es el borde derecho).
// La posición [0] es siempre la inferior central (la vista del Héroe).
const PREDEFINED_LAYOUTS = {
  2: [ { x: 50, y: -10 }, { x: -50, y: -10 } ],
  3: [ { x: 0, y: 50 }, { x: -50, y: -25 }, { x: 45, y: -25 } ],
  4: [ { x: 0, y: 50 }, { x: -50, y: 0 }, { x: 0, y: -50 }, { x: 50, y: 0 } ],
  5: [ { x: 0, y: 50 }, { x: -45, y: 25 }, { x: -35, y: -40 }, { x: 35, y: -40 }, { x: 45, y: 25 } ],
  6: [ { x: 0, y: 50 }, { x: -48, y: 20 }, { x: -48, y: -40 }, { x: 0, y: -55 }, { x: 48, y: -40 }, { x: 48, y: 20 } ],
  7: [ { x: 0, y: 50 }, { x: -40, y: 35 }, { x: -50, y: -25 }, { x: -20, y: -50 }, { x: 20, y: -50 }, { x: 50, y: -25 }, { x: 40, y: 35 } ],
  8: [ { x: 2, y: 53 }, { x: -33, y: 50 }, { x: -55, y: -10 }, { x: -28, y: -48 }, { x: 0, y: -52 }, { x: 30, y: -48 }, { x: 55, y: -10 }, { x: 35, y: 50 } ],
  9: [ { x: 0, y: 50 }, { x: -30, y: 50 }, { x: -50, y: 5 }, { x: -45, y: -50 }, { x: -14, y: -60 }, { x: 16, y: -60 }, { x: 45, y: -50 }, { x: 50, y: 5 }, { x: 30, y: 50 } ],
};

const seatCoordinates = computed(() => {
  // Si el jugador tiene coordenadas personalizadas, úsalas
  if (props.player.x !== null && props.player.y !== null) {
    return { x: props.player.x, y: props.player.y };
  }
  // El visualIndex [0] es siempre el Héroe en la parte inferior.
  const visualIndex = (props.index - props.heroIndex + props.playerCount) % props.playerCount;
  if (PREDEFINED_LAYOUTS[props.playerCount]) {
    return PREDEFINED_LAYOUTS[props.playerCount][visualIndex];
  }
  // Fallback para 10+ jugadores (aunque la UI actual no lo permite, es bueno tenerlo)
  return { x: 0, y: 0 };
});

// --- ESTILO DE ASIENTO (MODIFICADO PARA RESPONSIVE) ---
const seatStyle = computed(() => {
  const { x, y } = seatCoordinates.value; // x e y ya son porcentajes
  return {
    // Posiciona el centro del contenedor del jugador en las coordenadas calculadas
    top: `calc(50% + ${y}%)`,
    left: `calc(50% + ${x}%)`,
    // Luego, usa transform para mover el elemento por la mitad de su propio tamaño
    // para que quede perfectamente centrado en ese punto.
    transform: 'translate(-50%, -50%)',
  };
});


const dealerButtonStyle = computed(() => {
  return {
    bottom: '-40px',
    left: '57%',
    transform: 'translateX(-50%)'
  };
});
const betBoxStyle = computed(() => {
  // El visualIndex [0] es siempre el Héroe en la parte inferior.
  const visualIndex = (props.index - props.heroIndex + props.playerCount) % props.playerCount;

  // Lógica de posicionamiento de fichas por asiento individual
  switch (visualIndex) {
    case 0: // Asiento del Héroe (inferior central)
      return { top: '-13%', left: '60%', transform: 'translateX(-50%)' };
    case 1: // Jugador a la derecha del Héroe
      return { top: '20%', right: '-60%', transform: 'translateY(-50%)' };
    case 2:
      return { top: '80%', right: '-70%', transform: 'translateY(-50%)' };
    case 3:
      return { bottom: '-10%', left: '130%', transform: 'translateX(-50%)' };
    case 4: // Jugador en el top
      return { bottom: '-35%', left: '50%', transform: 'translateX(-50%)' };
    case 5: // Jugador en el top
      return { bottom: '-35%', left: '50%', transform: 'translateX(-50%)' };
    case 6: // Asiento a la izquierda (superior)
      return { top: '95%', left: '-50%', transform: 'translateY(-50%)' };
    case 7: // Asiento a la izquierda (inferior)
      return { top: '70%', left: '-55%', transform: 'translateY(-50%)' };
    case 8:
      return { top: '-15%', left: '50%', transform: 'translateX(-50%)' };
    default: // Fallback por si acaso
      return { top: '0', left: '105%' };
  }
});
const notesPanelStyle = computed(() => {
  return { top: '10%', left: '50%', transform: 'translateX(-50%)' };
});
</script>

<style scoped>
/* --- ESTILOS BASE (ESCRITORIO) --- */
.player-container {
  position: absolute;
  z-index: 5;
  /* El tamaño del jugador es un porcentaje del tamaño de la mesa, haciéndolo responsive */
  width: 18%; 
  max-width: 150px; /* Evita que sea demasiado grande en pantallas enormes */
  height: 50%;
}

.player-seat {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 110%;
  height: 60px;
  background: none;
  border: none;
  transition: all 0.3s ease;
}

.player-info-panel {
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, rgba(45, 55, 72, 0.95) 0%, rgba(26, 32, 44, 0.95) 100%);
  border: 1px solid rgba(74, 85, 104, 0.5);
  border-radius: 8px;
  padding: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.05);
  text-align: center;
  z-index: 10;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.player-cards {
  position: absolute;
  top: 6px;
  left: 62%;
  transform: translateX(-50%);
  display: flex;
  justify-content: center;
  gap: 5%;
  width: 100%;
  z-index: 1;
}

.card-placeholder {
  width: 70%; 
  height: auto;
  aspect-ratio: 100 / 140; 
  cursor: pointer;
  position: relative;
}

.player-name {
  font-weight: 700;
  /* Usamos clamp para un tamaño de fuente fluido */
  font-size: clamp(0.7rem, 1.2vw, 1.1em);
  color: #E2E8F0;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  margin-bottom: 4px;
}

.player-stack {
  font-family: 'Roboto Mono', monospace;
  font-size: clamp(0.8rem, 1.4vw, 1.2em);
  font-weight: 700;
  color: #FFFFFF;
  background-color: rgba(0,0,0,0.3);
  border-radius: 4px;
  padding: 2px 6px;
}

.active .player-info-panel {
  border-color: #f6e05e;
  box-shadow: 0 0 30px rgba(246, 224, 94, 0.5), 0 4px 15px rgba(0, 0, 0, 0.4);
}

.faded {
  opacity: 0.5;
}

.dealer-button {
  position: absolute;
  width: 15px;
  height: 15px;
  background: linear-gradient(145deg, #ffffff, #e6e6e6);
  color: #333;
  border-radius: 50%;
  font-weight: bold;
  font-size: 0.75rem;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 1px solid rgba(0,0,0,0.2);
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  z-index: 15;
}

.bet-box {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: -0px;
  z-index: 9;
}

.bet-info {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-top: -8px; /* <--- ¡AQUÍ ESTÁ LA MAGIA! AJUSTA ESTE VALOR */
}

.bet-info {
  display: flex;
  align-items: center;
  gap: 5px;
}

.bet-amount-text {
  background-color: rgba(0,0,0,0.8);
  border: 1px solid #000;
  padding: 0.5px 4px;
  border-radius: 6px;
  font-size: 0.6em;
  font-weight: bold;
  color: white;
  white-space: nowrap;
}

.all-in-icon {
  width: 40px;
  height: 40px;
}

.is-hero .player-info-panel {
  border-color: #68d391;
  animation: hero-glow 2s infinite ease-in-out;
}

@keyframes hero-glow {
  0%, 100% {
    box-shadow: 0 0 8px #68d391, 0 0 10px #68d391 inset, 0 4px 15px rgba(0, 0, 0, 0.4);
  }
  50% {
    box-shadow: 0 0 20px #68d391, 0 0 15px #68d391 inset, 0 4px 15px rgba(0, 0, 0, 0.4);
  }
}

.player-input {
  background-color: #1a202c;
  border: 1px solid var(--border-color);
  color: var(--text-color);
  border-radius: 4px;
  text-align: center;
  padding: 2px 4px;
  max-width: 100%;
}
.player-name-input {
  font-size: 0.9em;
  width: 70px;
}
.player-stack-input {
  font-size: 1em;
  width: 70px;
  -moz-appearance: textfield;
}
.player-stack-input::-webkit-outer-spin-button,
.player-stack-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.stack-input-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.editable-name-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
}
.player-position-static {
  font-size: 0.9em;
  color: #a0aec0;
}

.edit-notes-btn, .notes-display-wrapper {
  position: absolute;
  top: -4px;
  right: -26px;
  z-index: 15;
}

.edit-notes-btn {
  background: rgba(45, 55, 72, 0.9);
  border: 3px solid rgba(74, 85, 104, 0.5);
  border-radius: 50%;
  width: 30px;
  height: 30px;
  padding: 2px;
  cursor: pointer;
  color: #cbd5e0;
}
.edit-notes-btn:hover {
  background: rgba(74, 85, 104, 1);
  color: white;
}
.notes-panel {
  position: absolute;
  width: 220px;
  background-color: #2d3748;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px;
  z-index: 20;
  display: flex;
  flex-direction: column;
  gap: 10px;
  box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}
.notes-panel textarea {
  width: 100%;
  height: 100px;
  resize: vertical;
  background-color: #1a202c;
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 5px;
  font-family: inherit;
  font-size: 0.9rem;
}
.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.tag-selector {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid transparent;
  transition: transform 0.1s;
}
.tag-selector:hover {
  transform: scale(1.1);
}
.tag-selector.selected {
  border-color: white;
  box-shadow: 0 0 5px white;
}
.player-tag {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
  border: 1px solid rgba(0,0,0,0.5);
}
.notes-display-wrapper {
  position: absolute;
  top: -4px;
  left: -8px;
  z-index: 15;
}
.notes-display-icon {
  width: 24px;
  height: 24px;
  color: #a0aec0;
  cursor: pointer;
  background-color: rgba(45, 55, 72, 0.9);
  border-radius: 50%;
  padding: 2px;
  border: 1px solid rgba(74, 85, 104, 0.5);
}
.notes-display-wrapper .notes-tooltip {
  visibility: hidden;
  opacity: 0;
  width: 200px;
  background-color: #1a202c;
  color: #fff;
  text-align: left;
  border-radius: 6px;
  padding: 8px;
  position: absolute;
  z-index: 25;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  transition: opacity 0.3s;
  font-size: 0.9rem;
  font-weight: normal;
  white-space: pre-wrap;
  border: 1px solid var(--border-color);
  box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}
.notes-display-wrapper:hover .notes-tooltip {
  visibility: visible;
  opacity: 1;
}

/* --- MEDIA QUERY PARA MÓVIL/TABLET EN HORIZONTAL --- */
@media screen and (max-width: 900px) and (orientation: landscape) {
  .player-container {
    width: 20%; /* Aumentamos el ancho relativo para que no se vea tan pequeño */
    height: 45%;
    max-width: 120px; /* Limitamos el ancho máximo en píxeles */
  }
  .player-seat {
    height: 45px; /* Reducimos aún más la altura del panel */
  }
  .player-info-panel {
    padding: 2px; /* Menos padding */
    border-radius: 6px;
  }
  .player-cards {
    top: -55%; /* Subimos las cartas para que se solapen con el panel */
    gap: 2%;
  }
  .dealer-button {
    width: 18px;
    height: 18px;
    font-size: 0.7rem;
    bottom: -25px; /* Acercamos el botón de dealer */
  }
  .bet-box {
    transform: scale(0.75) translateY(-50%); /* Hacemos más pequeña la info de apuesta */
  }
  /* Ocultamos elementos no esenciales para maximizar el espacio */
  .edit-notes-btn, .notes-display-wrapper, .player-tag, .player-position-static {
    display: none;
  }
}
/* --- ESTILOS PARA 9+ JUGADORES (MÁS COMPACTO) --- */
.is-9-max .player-seat {
  height: 50px;
}

.is-9-max .player-info-panel {
  padding: 4px;
}

.is-9-max .player-name {
  font-size: clamp(0.6rem, 1.1vw, 0.9em);
}

.is-9-max .player-stack {
  font-size: clamp(0.7rem, 1.3vw, 1em);
}

.is-9-max .player-cards {
  top: -20px;
  gap: 1%;
  width: 80%;
  left: 50%;
}

.is-9-max .card-placeholder {
  width: 65%;
}

@media screen and (max-width: 900px) and (orientation: landscape) {
  .is-9-max .player-seat {
    height: 40px;
    bottom: 10px;
  }
  .is-9-max .player-cards {
    top: -50%;
  }
    .is-9-max .player-name, .is-9-max .player-stack {
    font-size: 0.7rem;
  }
}

/* --- ESTILOS PARA 9 JUGADORES (MÁS COMPACTO) --- */
.is-9-max .player-seat {
  height: 50px;
  width: 100%;
}

.is-9-max .player-info-panel {
  padding: 4px;
}

.is-9-max .player-name {
  font-size: clamp(0.6rem, 1.1vw, 0.9em);
  gap: 4px;
}

.is-9-max .player-stack {
  font-size: clamp(0.7rem, 1.3vw, 1em);
}

.is-9-max .player-cards {
  top: 15px; /* Sube un poco las cartas */
  left: 60%;
  width: 90%;
  gap: 2%;
}

.is-9-max .card-placeholder {
  width: 60%;
}

.is-9-max .edit-notes-btn {
  width: 26px;
  height: 26px;
  top: -8px;
  right: -25px;
}

.is-9-max .dealer-button {
  width: 15px;
  height: 15px;
  font-size: 0.9rem;
  bottom: -30px;
  top: 54px;
}

@media screen and (max-width: 900px) and (orientation: landscape) {
  .is-9-max .player-seat {
    height: 40px;
  }
  .is-9-max .player-cards {
    top: -60%;
  }
}
</style>

-----------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/PlayingCard.vue ---

<template>
  <div class="playing-card" :class="suitDetails.colorClass">
    <span class="rank">{{ rank }}</span>
    <span class="suit-icon" v-html="suitDetails.icon"></span>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  cardId: {
    type: String,
    required: true,
  }
});

const rank = computed(() => props.cardId ? props.cardId.slice(0, -1) : '');
const suit = computed(() => props.cardId ? props.cardId.slice(-1) : '');

const suitDetails = computed(() => {
  switch (suit.value) {
    case 'S': return { icon: '&spades;', colorClass: 'black' };
    case 'H': return { icon: '&hearts;', colorClass: 'red' };
    case 'C': return { icon: '&clubs;', colorClass: 'green' };
    case 'D': return { icon: '&diams;', colorClass: 'blue' };
    default: return { icon: '', colorClass: 'disabled' };
  }
});
</script>



<style scoped>
.playing-card {
  width: 100%;
  height: 100%;
  border: 1px solid #4A5568;
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-family: 'Arial Black', sans-serif;
  font-weight: bold;
  color: white;
  user-select: none;
  box-sizing: border-box;
}

.rank {
  font-size: 1.1rem;
  line-height: 0.7;
}

.suit-icon {
  font-size: 1rem;
  line-height: 1;
}

.playing-card.black { background-color: #2d3748; }
.playing-card.red { background-color: #c53030; }
.playing-card.green { background-color: #2f855a; }
.playing-card.blue { background-color: #2b6cb0; }
.playing-card.disabled { background-color: #4a5568; }
</style>

----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/PokerTable.vue ---

<template>
  <div class="poker-table-container">
    <div class="poker-table" :style="{ backgroundColor: tableColor }">
      
      <div class="center-content" :style="{ '--board-x': gameStore.tableLayout.board.x + '%', '--board-y': gameStore.tableLayout.board.y + '%' }">
        <div class="pot">
          Bote: 
          <span v-if="!gameStore.displayInBBs">{{ gameStore.currency }}{{ gameStore.totalPot }}</span>
          <span v-else>{{ (gameStore.totalPot / gameStore.bigBlind).toFixed(1) }}</span>
        </div>

        <div class="board">
          <div 
            v-for="(card, index) in 5" 
            :key="`board-${index}`" 
            class="card-placeholder"
            :class="{ locked: !isBoardCardClickable(index) }"
            @click="handleBoardCardClick(index)"
          >
            <PlayingCard v-if="gameStore.board[index]" :cardId="gameStore.board[index]" />
            <svg v-else width="100%" height="100%" viewBox="0 0 100 140" fill="none" xmlns="http://www.w3.org/2000/svg">
              <rect width="100" height="140" rx="8" fill="#374151"/>
              <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="white" font-size="60" font-weight="bold">+</text>
            </svg>
          </div>
        </div>
      </div>

      <Player
        v-for="(player, index) in gameStore.players"
        :key="player.id"
        :player="player"
        :player-count="gameStore.players.length"
        :index="index"
        :hero-index="heroIndex" 
      />
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useGameStore } from '../store/game';
import Player from './Player.vue';
import PlayingCard from './PlayingCard.vue';

const gameStore = useGameStore();
const tableColor = ref('#28563a');

const clickablePhases = computed(() => ['flop', 'turn', 'river', 'showdown']);

function isBoardCardClickable(index) {
  if (gameStore.gamePhase === 'replay' || gameStore.gamePhase === 'showdown') {
    return true;
  }
  if (index <= 2) {
    return clickablePhases.value.includes(gameStore.gamePhase);
  }
  if (index === 3) {
    return gameStore.gamePhase === 'turn' || gameStore.gamePhase === 'river';
  }
  if (index === 4) {
    return gameStore.gamePhase === 'river';
  }
  return false;
}

function handleBoardCardClick(index) {
  if (!isBoardCardClickable(index) || gameStore.gamePhase === 'replay') return;
  const target = { type: 'board', id: index };
  if (gameStore.board[index]) {
    gameStore.unassignCard(target);
  } else {
    gameStore.openCardPicker(target);
  }
}

const heroIndex = computed(() => {
  const index = gameStore.players.findIndex(p => p.name === 'Hero');
  return index !== -1 ? index : 0;
});
</script>

<style scoped>
.poker-table-container {
  width: 90%;
  height: 90%;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 0;
  min-width: 0;
}

.poker-table {
  position: relative;
  width: 90%;
  max-width: 100%;
  max-height: 100%;
  aspect-ratio: 16 / 9;
  border-radius: 50%;
  border-style: solid;
  border-color: #5a3a22;
  border-width: clamp(8px, 1.2vmin, 15px);
  box-shadow: inset 0 0 clamp(15px, 2.5vmin, 30px) rgba(0, 0, 0, 0.6);
  transition: background-color 0.3s ease;
  right: -15px;
  top: 10px;
}

.center-content {
  position: absolute;
  top: calc(50% + var(--board-y, 0%));
  left: calc(50% + var(--board-x, 0%));
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: clamp(5px, 1.5vh, 15px);
  width: 55%;
}

.pot {
  font-size: clamp(0.9rem, 2.5vmin, 1.3rem);
  font-weight: bold;
  color: white;
  background-color: rgba(0, 0, 0, 0.4);
  padding: 0.05em 1em;
  border-radius: 8px;
}

.board {
  display: flex;
  gap: 2%;
  padding: 1.5%;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 10px;
  width: 100%;
  justify-content: center;
  z-index: 10;
}

.card-placeholder {
  width: 18%;
  aspect-ratio: 100 / 140;
  background-color: transparent;
  border-radius: 6px;
  overflow: hidden;
  cursor: pointer;
}

.card-placeholder:hover {
  outline: 2px solid #f6e05e;
}

.card-placeholder.locked {
  cursor: not-allowed;
  opacity: 0.6;
}

.card-placeholder.locked:hover {
  outline: none;
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/RotateDeviceOverlay.vue ---

<template>
  <div class="rotate-overlay">
    <div class="rotate-content">
      <svg class="rotate-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0011.664 0l3.181-3.183m-4.991-2.691V5.25a2.25 2.25 0 00-2.25-2.25h-4.5a2.25 2.25 0 00-2.25 2.25v4.5A2.25 2.25 0 006.75 12h4.5a2.25 2.25 0 002.25-2.25v-2.25" />
      </svg>
      <p>Por favor, gira tu dispositivo a modo vertical para usar esta función.</p>
    </div>
  </div>
</template>

<style scoped>
.rotate-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; align-items: center; text-align: center; z-index: 9999; }
.rotate-content { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; padding: 2rem; }
.rotate-icon { width: 80px; height: 80px; animation: rotate-animation 2s infinite ease-in-out; }
p { font-size: 1.2rem; font-weight: bold; max-width: 300px; }
@keyframes rotate-animation { 0% { transform: rotate(0deg); } 50% { transform: rotate(90deg); } 100% { transform: rotate(90deg); } }
</style>

------------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/SessionChart.vue ---

<template>
  <div>
    <!-- Renderizado condicional del tipo de gráfico. El :key fuerza el redibujado al cambiar -->
    <Line v-if="chartsStore.chartType === 'line'" :key="'line-' + chartsStore.timeRange" :data="lineChartData" :options="chartOptions" />
    <Bar v-else :key="'bar-' + chartsStore.timeRange" :data="barChartData" :options="chartOptions" />
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import { useChartsStore } from '../store/useChartsStore';
import { useI18n } from 'vue-i18n';
import { Line, Bar } from 'vue-chartjs';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  Filler,
} from 'chart.js';

ChartJS.register(
  CategoryScale, LinearScale, PointElement, LineElement, BarElement, Title, Tooltip, Legend, Filler
);

const sessionStore = useSessionStore();
const chartsStore = useChartsStore();
const { t } = useI18n();

const filteredSessions = computed(() => {
  const allSessions = sessionStore.savedSessions;
  const range = chartsStore.timeRange;
  
  if (range === 'all') {
    return allSessions;
  }

  const now = new Date();
  const cutoffDate = new Date();

  switch (range) {
    case '7d': cutoffDate.setDate(now.getDate() - 7); break;
    case '1m': cutoffDate.setMonth(now.getMonth() - 1); break;
    case '3m': cutoffDate.setMonth(now.getMonth() - 3); break;
    case '6m': cutoffDate.setMonth(now.getMonth() - 6); break;
    case '1y': cutoffDate.setFullYear(now.getFullYear() - 1); break;
  }

  return allSessions.filter(session => {
    // La fecha de la DB ya es un objeto Date o un string compatible
    const sessionDate = new Date(session.fecha);
    return sessionDate >= cutoffDate;
  });
});

const sessionsInChronologicalOrder = computed(() => {
  // Ordenamos de la más antigua a la más nueva para la gráfica de líneas
  return [...filteredSessions.value].sort((a, b) => new Date(a.fecha) - new Date(b.fecha));
});

const lineChartData = computed(() => {
  const sessions = sessionsInChronologicalOrder.value;
  // Usamos 'fecha' y lo formateamos para las etiquetas
  const labels = sessions.map(s => new Date(s.fecha + 'T12:00:00').toLocaleDateString());
  let cumulativeProfit = 0;
  const dataPoints = sessions.map(s => {
    // *** CAMBIO CLAVE: Usamos 'resultado' y lo convertimos a número ***
    cumulativeProfit += parseFloat(s.resultado) || 0; 
    return cumulativeProfit;
  });

  return {
    labels: ['Inicio', ...labels],
    datasets: [{
      label: t('charts.cumulativeProfit'),
      data: [0, ...dataPoints],
      borderColor: (context) => {
        const chart = context.chart;
        const { ctx, chartArea } = chart;
        if (!chartArea) return null;
        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
        gradient.addColorStop(0, '#c53030');
        gradient.addColorStop(0.5, '#718096');
        gradient.addColorStop(1, '#38a169');
        return gradient;
      },
      backgroundColor: (context) => {
         const chart = context.chart;
        const { ctx, chartArea } = chart;
         if (!chartArea) return null;
         const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
         gradient.addColorStop(0, 'rgba(197, 48, 48, 0.2)');
         gradient.addColorStop(0.5, 'rgba(74, 85, 104, 0.2)');
         gradient.addColorStop(1, 'rgba(56, 161, 105, 0.2)');
         return gradient;
      },
      borderWidth: 3,
      pointBackgroundColor: '#fff',
      pointBorderColor: '#fff',
      tension: 0.1,
      fill: true,
    }],
  };
});

const barChartData = computed(() => {
  const sessions = sessionsInChronologicalOrder.value;
  // Usamos 'fecha' y lo formateamos para las etiquetas
  const labels = sessions.map(s => new Date(s.fecha + 'T12:00:00').toLocaleDateString());
  // *** CAMBIO CLAVE: Usamos 'resultado' y lo convertimos a número ***
  const dataPoints = sessions.map(s => parseFloat(s.resultado) || 0);

  return {
    labels,
    datasets: [{
      label: 'Resultado de la Sesión',
      data: dataPoints,
      backgroundColor: dataPoints.map(val => val >= 0 ? 'rgba(56, 161, 105, 0.6)' : 'rgba(197, 48, 48, 0.6)'),
      borderColor: dataPoints.map(val => val >= 0 ? '#38a169' : '#c53030'),
      borderWidth: 1,
    }],
  };
});

const chartOptions = {
  responsive: true,
  maintainAspectRatio: true,
  plugins: {
    legend: { display: false },
    tooltip: {
      callbacks: {
        label: function (context) {
          if (context.dataIndex === 0 && context.dataset.label === t('charts.cumulativeProfit')) {
            return ` ${t('charts.cumulativeProfit')}: ${sessionStore.currency}0.00`;
          }

          let label = '';
          let value = 0;

          if (context.dataset.label === t('charts.cumulativeProfit')) {
            const session = sessionsInChronologicalOrder.value[context.dataIndex - 1];
            if (session) {
              label = 'Resultado de la Sesión: ';
              // *** CAMBIO CLAVE: Usamos 'resultado' ***
              value = parseFloat(session.resultado);
            }
          } 
          else {
            label = 'Resultado de la Sesión: ';
            value = context.parsed.y;
          }

          if (value !== null) {
            const prefix = value >= 0 ? '+' : '';
            label += `${prefix}${new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(value)}`;
          }
          return label;
        },
        labelColor: function(context) {
          let value = 0;
          if (context.dataset.label === t('charts.cumulativeProfit')) {
            if (context.dataIndex > 0) {
              const session = sessionsInChronologicalOrder.value[context.dataIndex - 1];
              if (session) {
                // *** CAMBIO CLAVE: Usamos 'resultado' ***
                value = parseFloat(session.resultado);
              }
            }
          } 
          else {
            value = context.parsed.y;
          }

          return {
            borderColor: value >= 0 ? '#68d391' : '#fc8181',
            backgroundColor: value >= 0 ? '#68d391' : '#fc8181',
          };
        }
      },
      backgroundColor: 'rgba(26, 32, 44, 0.9)',
      titleFont: { size: 14, weight: 'bold' },
      bodyFont: { size: 12 },
      padding: 10,
      borderColor: 'rgba(74, 85, 104, 0.8)',
      borderWidth: 1,
      usePointStyle: true, 
      boxPadding: 4
    },
  },
  scales: {
    y: {
      ticks: { color: '#a0aec0', callback: (value) => `${sessionStore.currency}${value}` },
      grid: { color: 'rgba(74, 85, 104, 0.4)' },
    },
    x: {
      ticks: { color: '#a0aec0' },
      grid: { display: false },
    },
  },
};
</script>

-----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/i18n.js ---

import { createI18n } from 'vue-i18n';
import es from './locales/es.json';
import en from './locales/en.json';

// Puedes añadir más importaciones de idiomas aquí
// import fr from './locales/fr.json';
// import zh from './locales/zh.json';

const i18n = createI18n({
  legacy: false, // Importante para usarlo en Composition API
  locale: localStorage.getItem('locale') || 'es', // Carga el idioma guardado o usa español por defecto
  fallbackLocale: 'en', // Idioma de respaldo si una traducción no existe
  messages: {
    es,
    en,
    // fr,
    // zh,
  },
});

export default i18n;

---------------------------------------

--- INICIO DEL ARCHIVO: src/locales/en.json ---

{
  "nav": {
    "currentHand": "Current Hand",
    "savedHands": "Saved Hands",
    "liveSession": "Live Session",
    "savedSessions": "Saved Sessions",
    "charts": "Charts",
    "settings": "Settings",
    "summary": "Summary"
  },
  "currentHand": {
    "handConfiguration": "Hand Configuration",
    "playerCount": "Number of Players",
    "players": "Players",
    "smallBlind": "Small Blind",
    "bigBlind": "Big Blind",
    "currency": "Currency",
    "configurePlayers": "Configure Players",
    "playerName": "Name",
    "stack": "Stack",
    "startHand": "Start Hand",
    "selectPosition": "Select Your Position (Hero)",
    "confirmAndStart": "Confirm and Start Hand"
  },
  "actionPanel": {
    "turnOf": "Turn:",
    "fold": "FOLD",
    "check": "CHECK",
    "call": "CALL",
    "bet": "BET",
    "raise": "RAISE",
    "pot": "POT",
    "allIn": "ALL-IN"
  },
  "pokerTable": {
    "pot": "Pot"
  },
  "liveSession": {
    "title": "Live Session",
    "titleOnBreak": "On Break",
    "configTitle": "Game Configuration",
    "playerCount": "Players at table",
    "blindsLevel": "Blinds Level",
    "location": "Location / Casino",
    "currency": "Currency",
    "initialStack": "Initial Stack (Buy-in)",
    "startSession": "Start Session",
    "break": "Break",
    "endBreak": "End Break",
    "endSession": "End Session",
    "liveActionsTitle": "QUICK ACTIONS",
    "rebuyAmount": "Rebuy Amount",
    "addRebuy": "Add Rebuy",
    "tipAmount": "Tip",
    "addTip": "Tip Dealer",
    "expenseAmount": "Expense",
    "addExpense": "Add Expense"
  },
  "endSessionModal": {
    "title": "End Session",
    "initialBuyIn": "Initial Buy-in:",
    "rebuysAddOns": "Rebuys/Add-ons:",
    "expenses": "Expenses (tips, etc.):",
    "totalInvestment": "Total Investment:",
    "finalStackLabel": "Enter Your Final Stack:",
    "finalStackPlaceholder": "Stack at the end",
    "sessionResult": "Session Result",
    "cancel": "Cancel",
    "confirm": "Confirm & Save"
  },
  "savedSessions": {
    "title": "Saved Sessions",
    "noSessions": "You have no saved sessions yet.",
    "duration": "Duration:",
    "breaks": "Breaks:",
    "buyIn": "Buy-in:",
    "rebuys": "Rebuys:",
    "expenses": "Expenses:",
    "finalStack": "Final Stack:",
    "blinds": "Blinds:",
    "players": "Players:",
    "result": "Result",
    "delete": "Delete"
  },
  "charts": {
    "title": "Session Results Chart",
    "noData": "You need at least two saved sessions to generate a chart.",
    "cumulativeProfit": "Cumulative Profit"
  },
  "settings": {
    "title": "Settings",
    "language": "Application Language"
  },
  "summary": {
    "title": "Overall Summary",
    "totalProfit": "Total Profit",
    "avgBuyIn": "Avg Buy-in",
    "avgCashOut": "Avg Cash Out",
    "sessionsTitle": "Sessions",
    "sessionCount": "Sessions Played",
    "totalHours": "Hours Played"
  }
}

-----------------------------------------------

--- INICIO DEL ARCHIVO: src/locales/es.json ---

{
  "nav": {
    "currentHand": "Mano Actual",
    "savedHands": "Manos Guardadas",
    "liveSession": "Sesión en Vivo",
    "savedSessions": "Sesiones Guardadas",
    "charts": "Gráficas",
    "settings": "Configuración",
    "summary": "Sumario"
  },
  "currentHand": {
    "handConfiguration": "Configuración de la Mano",
    "playerCount": "Número de Jugadores",
    "players": "Jugadores",
    "smallBlind": "Ciega Pequeña",
    "bigBlind": "Ciega Grande",
    "currency": "Moneda",
    "configurePlayers": "Configurar Jugadores",
    "playerName": "Nombre",
    "stack": "Stack",
    "startHand": "Iniciar Mano",
    "selectPosition": "Selecciona tu Posición (Hero)",
    "confirmAndStart": "Confirmar e Iniciar Mano"
  },
  "actionPanel": {
    "turnOf": "Turno de:",
    "fold": "FOLD",
    "check": "CHECK",
    "call": "CALL",
    "bet": "BET",
    "raise": "RAISE",
    "pot": "POT",
    "allIn": "ALL-IN"
  },
  "pokerTable": {
    "pot": "Bote"
  },
  "liveSession": {
    "title": "Sesión en Vivo",
    "titleOnBreak": "En Descanso",
    "configTitle": "Configuración de la Partida",
    "playerCount": "Jugadores en la mesa",
    "blindsLevel": "Nivel de Ciegas",
    "location": "Lugar / Casino",
    "currency": "Moneda",
    "initialStack": "Stack Inicial (Buy-in)",
    "startSession": "Iniciar Sesión",
    "break": "Descanso",
    "endBreak": "Fin del Descanso",
    "endSession": "Finalizar Sesión",
    "liveActionsTitle": "ACCIONES RÁPIDAS",
    "rebuyAmount": "Monto Recarga",
    "addRebuy": "Añadir Recarga",
    "tipAmount": "Propina",
    "addTip": "Tip Dealer",
    "expenseAmount": "Gasto",
    "addExpense": "Consumición"
  },
  "endSessionModal": {
    "title": "Finalizar Sesión",
    "initialBuyIn": "Buy-in Inicial:",
    "rebuysAddOns": "Rebuys/Add-ons:",
    "expenses": "Gastos (propinas, etc.):",
    "totalInvestment": "Inversión Total:",
    "finalStackLabel": "Introduce tu Stack Final:",
    "finalStackPlaceholder": "Stack al finalizar",
    "sessionResult": "Resultado de la Sesión",
    "cancel": "Cancelar",
    "confirm": "Confirmar y Guardar"
  },
  "savedSessions": {
    "title": "Sesiones Guardadas",
    "noSessions": "No tienes sesiones guardadas todavía.",
    "duration": "Duración:",
    "breaks": "Descansos:",
    "buyIn": "Buy-in:",
    "rebuys": "Recargas:",
    "expenses": "Gastos:",
    "finalStack": "Stack Final:",
    "blinds": "Ciegas:",
    "players": "Jugadores:",
    "result": "Resultado",
    "delete": "Eliminar"
  },
  "charts": {
    "title": "Gráfica de Resultados de Sesiones",
    "noData": "Necesitas al menos dos sesiones guardadas para generar una gráfica.",
    "cumulativeProfit": "Beneficio Acumulado"
  },
  "settings": {
    "title": "Configuración",
    "language": "Idioma de la Aplicación"
  },
  "summary": {
    "title": "Sumario General",
    "totalProfit": "Total Profit",
    "avgBuyIn": "Avg Buy-in",
    "avgCashOut": "Avg Cash Out",
    "sessionsTitle": "Sesiones",
    "sessionCount": "Sesiones Jugadas",
    "totalHours": "Horas de Juego",
    "avgHours": "Media de Horas/Sesión",
    "avgBreak": "Duración media de descanso"
  }
}

-----------------------------------------------

--- INICIO DEL ARCHIVO: src/main.js ---

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import i18n from './i18n'
import './styles.css'
import { useAuthStore } from './store/useAuthStore'

const app = createApp(App)
const pinia = createPinia()
app.use(pinia)

// Obtenemos el store de autenticación e iniciamos el listener.
// La app NO esperará, se montará inmediatamente.
const authStore = useAuthStore()
authStore.listenToAuthState() // Usaremos un nuevo listener simple

app.use(i18n)
app.mount('#app')

---------------------------------------

--- INICIO DEL ARCHIVO: src/store/game.js ---

import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
// Importamos nuestras nuevas funciones de API
import { apiFetchHands, apiAddHand, apiDeleteHand } from '@/api';

const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));

// --- LÓGICA DE EVALUACIÓN DE MANOS (PLACEHOLDER) ---
const evaluateHand = (playerCards, boardCards) => {
  const allCards = [...playerCards, ...boardCards].filter(c => c);
  if (allCards.length < 2) return { rank: 0, description: 'Nada' };
  const ranks = allCards.map(c => c.slice(0, -1));
  const rankCounts = ranks.reduce((acc, rank) => {
    acc[rank] = (acc[rank] || 0) + 1;
    return acc;
  }, {});
  const pairs = Object.keys(rankCounts).filter(r => rankCounts[r] === 2);
  const trips = Object.keys(rankCounts).filter(r => rankCounts[r] === 3);
  const quads = Object.keys(rankCounts).filter(r => rankCounts[r] === 4);
  if (quads.length > 0) return { rank: 7, description: `Poker de ${quads[0]}`};
  if (trips.length > 0 && pairs.length > 0) return { rank: 6, description: `Full House de ${trips[0]} y ${pairs[0]}`};
  if (trips.length > 0) return { rank: 3, description: `Trío de ${trips[0]}`};
  if (pairs.length === 2) return { rank: 2, description: `Doble pareja de ${pairs[0]} y ${pairs[1]}`};
  if (pairs.length === 1) return { rank: 1, description: `Pareja de ${pairs[0]}`};
  return { rank: 0, description: `Carta alta ${ranks[0]}` };
};

export const useGameStore = defineStore('game', () => {
  const players = ref([]);
  const heroPosition = ref(null);
  const smallBlind = ref(1);
  const bigBlind = ref(2);
  const currency = ref('$');
  const specialRule = ref('Ninguno');
  const bombPotBB = ref(2);
  const board = ref(['', '', '', '', '']);
  const pots = ref([]);
  const history = ref([]);
  const currentActionIndex = ref(-1);
  // Reemplazamos localStorage con un ref vacío
  const savedHands = ref([]);
  const displayInBBs = ref(false);

  // Pagination state
  const hasMore = ref(true);
  const currentOffset = ref(0);
  const pageSize = ref(20);
  
  const replaySpeed = ref(2000);
  const isReplaying = ref(false);
  let replayIntervalId = null;

  const gamePhase = ref('setup');
  const dealerPosition = ref(0);
  const activePlayerIndex = ref(null);
  const currentBet = ref(0);
  const minRaise = ref(0);
  const lastRaiserIndex = ref(null);
  const lastRaiseAmount = ref(0);
  const isCardPickerOpen = ref(false);
  const cardPickerTarget = ref(null);

  const isPreActionPhase = ref(true);
  const openNotesPanelPlayerId = ref(null);
  const tableLayout = ref({
    board: { x: 0, y: 0 },
    pot: { x: 0, y: 0 }
  });

  const totalPot = computed(() => pots.value.reduce((sum, pot) => sum + pot.amount, 0));

  const activePlayer = computed(() => {
    if (activePlayerIndex.value === null) return null;
    return players.value.find(p => p.id === activePlayerIndex.value);
  });

  const usedCards = computed(() => {
    const cards = new Set();
    players.value.forEach(p => {
      if (p.cards[0]) cards.add(p.cards[0]);
      if (p.cards[1]) cards.add(p.cards[1]);
    });
    board.value.forEach(c => {
      if (c) cards.add(c);
    });
    return cards;
  });

  // --- ACCIONES NUEVAS Y MODIFICADAS ---

  async function fetchHands(date = null, incremental = false) {
    console.log('[DEBUG] gameStore.fetchHands: Starting with date:', date, 'incremental:', incremental, 'currentOffset:', currentOffset.value);
    const limit = pageSize.value;
    const offset = incremental ? currentOffset.value : 0;
    console.log('[DEBUG] gameStore.fetchHands: Calling apiFetchHands with limit:', limit, 'offset:', offset);
    const result = await apiFetchHands(date, limit, offset);
    console.log('[DEBUG] gameStore.fetchHands: apiFetchHands completed, result count:', result?.length || 0);
    if (incremental) {
      savedHands.value = [...savedHands.value, ...result];
      console.log('[DEBUG] gameStore.fetchHands: Appended to savedHands, new total:', savedHands.value.length);
    } else {
      savedHands.value = result;
      currentOffset.value = 0;
      console.log('[DEBUG] gameStore.fetchHands: Replaced savedHands, count:', savedHands.value.length, 'offset reset to 0');
    }
    currentOffset.value += result.length;
    hasMore.value = result.length === limit;
    console.log('[DEBUG] gameStore.fetchHands: Updated currentOffset to:', currentOffset.value, 'hasMore:', hasMore.value);
  }

  async function loadMoreHands(date = null) {
    if (!hasMore.value) return;
    await fetchHands(date, true);
  }

  async function saveCurrentHand() {
    if (history.value.length === 0) return;
    const handToSave = {
      // id y fecha los genera la BD, ya no los necesitamos aquí
      fecha: new Date().toISOString(),
      posicion_heroe: heroPosition.value,
      cantidad_jugadores: players.value.length,
      historial: deepCopy(history.value), // El historial se guarda en JSONB
      ciega_pequena: smallBlind.value,
      ciega_grande: bigBlind.value,
      moneda: currency.value,
      regla_especial: specialRule.value,
      bomb_pot_bb: bombPotBB.value,
    };
    try {
      const newHand = await apiAddHand(handToSave);
      savedHands.value.unshift(newHand); // Añadimos la mano devuelta a nuestro estado local
    } catch (error) {
      console.error("Error al guardar la mano:", error);
      // Opcional: mostrar un error al usuario
    }
  }
  
  async function deleteHand(handId) {
    try {
      await apiDeleteHand(handId);
      savedHands.value = savedHands.value.filter(hand => hand.id !== handId);
    } catch(error) {
       console.error("Error al borrar la mano:", error);
    }
  }

  // loadHand no necesita ser async, porque opera con datos ya cargados
  function loadHand(handData) {
    pauseReplay();
    const initialState = handData.historial[0]; // El historial viene del campo JSONB
    players.value = deepCopy(initialState.players);
    board.value = deepCopy(initialState.board);
    pots.value = deepCopy(initialState.pots);
    heroPosition.value = handData.posicion_heroe;
    smallBlind.value = handData.ciega_pequena;
    bigBlind.value = handData.ciega_grande;
    currency.value = handData.moneda;
    specialRule.value = handData.regla_especial || 'Ninguno';
    bombPotBB.value = handData.bomb_pot_bb || 2;
    history.value = deepCopy(handData.historial);
    currentActionIndex.value = 0;
    gamePhase.value = 'replay';
    isPreActionPhase.value = false;
  }
  
  // --- RESTO DE FUNCIONES (sin cambios en su mayoría) ---

  function toggleDisplayMode() { displayInBBs.value = !displayInBBs.value; }
  
  function setReplaySpeed(newSpeed) {
    replaySpeed.value = parseInt(newSpeed, 10) || 2000;
    if (isReplaying.value) {
      pauseReplay();
      playReplay();
    }
  }

  function playReplay() {
    if (isReplaying.value) return;
    isReplaying.value = true;
    
    const intervalDuration = replaySpeed.value;

    replayIntervalId = setInterval(() => {
      if (currentActionIndex.value >= history.value.length - 1) {
        pauseReplay();
      } else {
        navigateHistory(1);
      }
    }, intervalDuration);
  }
  function pauseReplay() {
    clearInterval(replayIntervalId);
    isReplaying.value = false;
  }
  function restartReplay() {
    pauseReplay();
    currentActionIndex.value = 0;
    const stateToRestore = history.value[0];
    players.value = deepCopy(stateToRestore.players);
    board.value = deepCopy(stateToRestore.board);
    pots.value = deepCopy(stateToRestore.pots);
  }
  function toggleReplay() {
    if (isReplaying.value) {
      pauseReplay();
    } else {
      playReplay();
    }
  }
  function setupNewHand(numPlayers, newHeroPosition, newCurrency, newSb, newBb, newSpecialRule, newBombPotBB = null) {
    // ... (El resto de la lógica de setupNewHand, performAction, etc., es interna y no cambia)
    // ... (ya que solo manipula el estado de la mano actual, no la lista de manos guardadas)
    pauseReplay();
    players.value = [];
    heroPosition.value = newHeroPosition;
    currency.value = newCurrency;
    smallBlind.value = newSb;
    bigBlind.value = newBb;
    specialRule.value = newSpecialRule;
    bombPotBB.value = newBombPotBB || 2;
    board.value = ['', '', '', '', ''];
    pots.value = [{ amount: 0, eligiblePlayers: [] }];
    history.value = [];
    currentActionIndex.value = -1;
    gamePhase.value = 'preflop';
    lastRaiseAmount.value = 0;
    displayInBBs.value = false;
    isPreActionPhase.value = true;
    const positions = getPositions(numPlayers);
    for (let i = 0; i < numPlayers; i++) {
      const isHero = positions[i] === newHeroPosition;
      players.value.push({
        id: i,
        name: isHero ? 'Hero' : `Jugador ${i + 1}`,
        stack: newBb * 100,
        cards: ['', ''],
        position: positions[i],
        inHand: true,
        isAllIn: false,
        hasActedThisRound: false,
        betThisRound: 0,
        totalBetInHand: 0,
        isDealer: false,
        isSB: false,
        isBB: false,
        isStraddle: false,
        isMississippi: false,
        isBombPot: false,
        notes: '',
        tag: null,
        x: null,
        y: null,
      });
    }
    dealerPosition.value = players.value.find((p,i) => i === 0).id
    players.value[0].isDealer = true;
    let sbIndex, bbIndex;
    if (numPlayers === 2) {
      sbIndex = 0;
      bbIndex = 1;
      activePlayerIndex.value = players.value[sbIndex].id;
      lastRaiserIndex.value = players.value[bbIndex].id;
    } else {
      sbIndex = 1;
      bbIndex = 2;
      activePlayerIndex.value = players.value[(bbIndex + 1) % numPlayers].id;
      lastRaiserIndex.value = players.value[bbIndex].id;
    }

    if (specialRule.value === 'Bomb Pot') {
      const bombAmount = bigBlind.value * bombPotBB.value;
      players.value.forEach(player => {
        postBet(player.id, bombAmount, true);
        player.isBombPot = true;
      });
      currentBet.value = bombAmount;
      minRaise.value = bombAmount * 2;
      lastRaiseAmount.value = bombAmount;
      activePlayerIndex.value = players.value[(bbIndex + 1) % numPlayers].id;
      lastRaiserIndex.value = activePlayerIndex.value;
      recordState(`Bomb Pot: Todos los jugadores ponen ${bombPotBB.value} BB inicialmente.`);
    } else {
      players.value[sbIndex].isSB = true;
      postBet(players.value[sbIndex].id, smallBlind.value, true);
      players.value[bbIndex].isBB = true;
      postBet(players.value[bbIndex].id, bigBlind.value, true);
      currentBet.value = bigBlind.value;
      minRaise.value = bigBlind.value * 2;
      lastRaiseAmount.value = bigBlind.value;
      recordState("Inicio de mano. Ciegas puestas.");

      if (specialRule.value === 'Straddle' && numPlayers > 2) {
        const straddleIndex = (bbIndex + 1) % numPlayers;
        players.value[straddleIndex].isStraddle = true;
        postBet(players.value[straddleIndex].id, bigBlind.value * 2, true);
        currentBet.value = bigBlind.value * 2;
        minRaise.value = bigBlind.value * 4;
        lastRaiseAmount.value = bigBlind.value * 2;
        lastRaiserIndex.value = players.value[straddleIndex].id;
        recordState(`Straddle puesto por ${players.value[straddleIndex].name}.`);
        activePlayerIndex.value = players.value[(straddleIndex + 1) % numPlayers].id;
      }

      if (specialRule.value === 'Mississippi') {
        const buttonIndex = players.value.findIndex(p => p.isDealer);
        players.value[buttonIndex].isMississippi = true;
        postBet(players.value[buttonIndex].id, bigBlind.value * 2, true);
        currentBet.value = Math.max(currentBet.value, bigBlind.value * 2);
        minRaise.value = bigBlind.value * 4;
        lastRaiseAmount.value = bigBlind.value * 2;
        lastRaiserIndex.value = players.value[buttonIndex].id;
        recordState(`Mississippi puesto por ${players.value[buttonIndex].name}.`);
      }
    }
  }
  function performAction(action, amount = 0) {
    if (isPreActionPhase.value) {
      isPreActionPhase.value = false;
    }

    if (activePlayer.value === null) return;
    const player = activePlayer.value;
    player.hasActedThisRound = true;
    let actionDescription = '';
    switch (action) {
      case 'fold':
        player.inHand = false;
        actionDescription = `${player.name} se retira.`;
        break;
      case 'check':
        if (currentBet.value > player.betThisRound) return;
        actionDescription = `${player.name} pasa.`;
        break;
      case 'call':
        const callAmount = currentBet.value - player.betThisRound;
        postBet(player.id, callAmount);
        actionDescription = `${player.name} iguala.`;
        break;
      case 'all-in':
        const allInAmount = player.stack;
        const newTotalBet = player.betThisRound + allInAmount;
        postBet(player.id, allInAmount);
        actionDescription = `${player.name} va All-In por ${newTotalBet}.`;
        if (newTotalBet > currentBet.value) {
            players.value.forEach(p => { if(p.inHand && !p.isAllIn) p.hasActedThisRound = false; });
            const raiseDifference = newTotalBet - currentBet.value;
            lastRaiserIndex.value = player.id;
            minRaise.value = newTotalBet + raiseDifference;
            lastRaiseAmount.value = currentBet.value;
            currentBet.value = newTotalBet;
        }
        break;
      case 'bet':
      case 'raise':
        if (amount < minRaise.value && amount < player.stack + player.betThisRound) return;
        players.value.forEach(p => { if(p.inHand) p.hasActedThisRound = false; });
        const totalBet = amount;
        const raiseDifference = totalBet - currentBet.value;
        postBet(player.id, totalBet - player.betThisRound);
        lastRaiserIndex.value = player.id;
        minRaise.value = totalBet + raiseDifference;
        lastRaiseAmount.value = currentBet.value;
        currentBet.value = totalBet;
        actionDescription = `${player.name} ${action === 'bet' ? 'apuesta' : 'sube a'} ${totalBet}.`;
        break;
    }
    player.hasActedThisRound = true;
    recordState(actionDescription);
    checkHandOrRoundCompletion();
  }
  
  function checkHandOrRoundCompletion() {
    const playersInHand = players.value.filter(p => p.inHand);
    if (playersInHand.length === 1) {
      advanceRound();
      endHand(playersInHand[0]);
      return;
    }
    const playersAbleToAct = playersInHand.filter(p => !p.isAllIn);
    const roundIsOver = playersAbleToAct.every(p => {
      return p.hasActedThisRound && p.betThisRound === currentBet.value;
    });
    if (roundIsOver) {
      const isPreflopBbCheck = gamePhase.value === 'preflop' &&
        activePlayer.value.isBB &&
        currentBet.value === bigBlind.value;
      if (isPreflopBbCheck || playersAbleToAct.length < 2) {
        advanceRound();
      } else {
        advanceRound();
      }
    } else {
      advanceTurn();
    }
  }

  function runItOut() {
    advanceRound();
    if(gamePhase.value === 'showdown') return;
    recordState("--- Apuestas finalizadas, se reparten las cartas restantes ---");
    if (gamePhase.value === 'preflop') {
        gamePhase.value = 'flop';
        recordState("--- FLOP ---");
    }
    if (gamePhase.value === 'flop') {
        gamePhase.value = 'turn';
        recordState("--- TURN ---");
    }
    if (gamePhase.value === 'turn') {
        gamePhase.value = 'river';
        recordState("--- RIVER ---");
    }
    endHand();
  }
  function postBet(playerId, amount, isBlind = false) {
    const player = players.value.find(p => p.id === playerId);
    const bet = Math.min(amount, player.stack);
    player.stack -= bet;
    player.betThisRound += bet;

    if (player.stack === 0 && !isBlind) {
      player.isAllIn = true;
    }
  }
  function advanceTurn() {
    const currentIndex = players.value.findIndex(p => p.id === activePlayerIndex.value);
    let nextIndex = (currentIndex + 1) % players.value.length;
    while (!players.value[nextIndex].inHand || players.value[nextIndex].isAllIn) {
      nextIndex = (nextIndex + 1) % players.value.length;
    }
    activePlayerIndex.value = players.value[nextIndex].id;
  }
  function collectBetsAndCreatePots() {
      const playersInHand = players.value.filter(p => p.betThisRound > 0 || p.inHand);
      if (playersInHand.length === 0) return;
      playersInHand.forEach(p => p.totalBetInHand += p.betThisRound);
      while (true) {
          const playersWithMoney = playersInHand.filter(p => p.betThisRound > 0);
          if (playersWithMoney.length === 0) break;
          const allInPlayer = playersWithMoney.find(p => p.isAllIn);
          let currentPotContribution;
          if (allInPlayer) {
              const lowestAllInBet = Math.min(...playersWithMoney.filter(p => p.isAllIn).map(p => p.totalBetInHand));
              const lastTotalBetInPot = pots.value.reduce((sum, pot) => sum + (pot.betAmountPerPlayer || 0), 0);
              currentPotContribution = lowestAllInBet - lastTotalBetInPot;
          } else {
              currentPotContribution = Math.min(...playersWithMoney.map(p => p.betThisRound));
          }
          if (currentPotContribution <= 0) break;
          const newPot = { amount: 0, eligiblePlayers: [] };
          playersInHand.forEach(p => {
              if(p.totalBetInHand > 0) {
                  const contribution = Math.min(p.betThisRound, currentPotContribution);
                  p.betThisRound -= contribution;
                  newPot.amount += contribution;
                  if (!newPot.eligiblePlayers.includes(p.id)) {
                      newPot.eligiblePlayers.push(p.id);
                  }
              }
          });
          pots.value.push(newPot);
      }
      players.value.forEach(p => p.betThisRound = 0);
  }

  function advanceRound() {
    const betsOnTable = players.value.reduce((sum, p) => sum + p.betThisRound, 0);
    if(betsOnTable > 0) {
      if(pots.value.length === 1 && pots.value[0].amount === 0){
          pots.value[0].amount += betsOnTable;
          pots.value[0].eligiblePlayers = players.value.filter(p => p.inHand).map(p => p.id);
      } else {
         collectBetsAndCreatePots();
      }
    }
    players.value.forEach(p => { 
        p.betThisRound = 0;
        p.hasActedThisRound = false;
    });
    currentBet.value = 0;
    minRaise.value = bigBlind.value;
    lastRaiseAmount.value = 0;
    if (gamePhase.value === 'river') {
        endHand();
        return;
    }
    const playersAbleToAct = players.value.filter(p => p.inHand && !p.isAllIn);
    if (playersAbleToAct.length < 2) {
      runItOut();
      return;
    }

    let nextIndex;
    const dealerIndexInPlayersArray = players.value.findIndex(p => p.id === dealerPosition.value);

    if (players.value.length === 2) {
      nextIndex = (dealerIndexInPlayersArray + 1) % players.value.length;
    } else {
      nextIndex = (dealerIndexInPlayersArray + 1) % players.value.length;
    }

    while (!players.value[nextIndex].inHand || players.value[nextIndex].isAllIn) {
      nextIndex = (nextIndex + 1) % players.value.length;
    }
    activePlayerIndex.value = players.value[nextIndex].id;
    lastRaiserIndex.value = activePlayerIndex.value;

    switch (gamePhase.value) {
      case 'preflop': gamePhase.value = 'flop'; recordState("--- FLOP ---"); break;
      case 'flop': gamePhase.value = 'turn'; recordState("--- TURN ---"); break;
      case 'turn': gamePhase.value = 'river'; recordState("--- RIVER ---"); break;
    }
  }

  function endHand(winnerByFold = null) {
    gamePhase.value = 'showdown';
    activePlayerIndex.value = null;
    if(winnerByFold) {
      const winner = players.value.find(p => p.id === winnerByFold.id);
      winner.stack += totalPot.value;
      recordState(`La mano termina. ${winner.name} gana el bote de ${totalPot.value}.`);
      return;
    }
    recordState("--- SHOWDOWN --- Se muestran las cartas.");
    const playersToShowdown = players.value.filter(p => p.inHand);
    pots.value.forEach((pot, index) => {
        if(pot.amount === 0) return;
        const eligiblePlayers = playersToShowdown.filter(p => pot.eligiblePlayers.includes(p.id));
        if(eligiblePlayers.length === 1) {
            const winner = eligiblePlayers[0];
            winner.stack += pot.amount;
            recordState(`${winner.name} gana el bote ${index+1} de ${pot.amount}.`);
        } else if (eligiblePlayers.length > 1) {
            eligiblePlayers.forEach(p => { p.handResult = evaluateHand(p.cards, board.value); });
            eligiblePlayers.sort((a, b) => b.handResult.rank - a.handResult.rank);
            const bestRank = eligiblePlayers[0].handResult.rank;
            const winners = eligiblePlayers.filter(p => p.handResult.rank === bestRank);
            const potSplit = Math.floor(pot.amount / winners.length);
            winners.forEach(winner => { winner.stack += potSplit; });
            const winnerNames = winners.map(w => w.name).join(', ');
            recordState(`${winnerNames} gana${winners.length > 1 ? 'n' : ''} el bote ${index+1} de ${pot.amount} con ${winners[0].handResult.description}.`);
        }
    });
  }
  function resetHand() {
    pauseReplay();
    players.value = [];
    board.value = ['', '', '', '', ''];
    pots.value = [];
    history.value = [];
    currentActionIndex.value = -1;
    gamePhase.value = 'setup';
    isPreActionPhase.value = false;
    dealerPosition.value = 0;
    activePlayerIndex.value = null;
    currentBet.value = 0;
    minRaise.value = 0;
    lastRaiserIndex.value = null;
    lastRaiseAmount.value = 0;
  }
  function recordState(actionDescription) {
    const currentState = {
      players: deepCopy(players.value),
      board: deepCopy(board.value),
      pots: deepCopy(pots.value),
      description: actionDescription,
    };
    if(currentActionIndex.value < history.value.length - 1) {
      history.value.splice(currentActionIndex.value + 1);
    }
    history.value.push(currentState);
    currentActionIndex.value++;
  }
  function navigateHistory(direction) {
    const newIndex = currentActionIndex.value + direction;
    if (newIndex >= 0 && newIndex < history.value.length) {
      currentActionIndex.value = newIndex;
      const stateToRestore = history.value[newIndex];
      players.value = deepCopy(stateToRestore.players);
      board.value = deepCopy(stateToRestore.board);
      pots.value = deepCopy(stateToRestore.pots);
    }
  }
  function openCardPicker(target) {
    cardPickerTarget.value = target;
    isCardPickerOpen.value = true;
  }
  function closeCardPicker() {
    isCardPickerOpen.value = false;
    cardPickerTarget.value = null;
  }
  function assignCard(cardId) {
    if (!cardPickerTarget.value) return;
    const { type, id, cardIndex } = cardPickerTarget.value;
    if (type === 'player') {
      const player = players.value.find(p => p.id === id);
      if (player) player.cards[cardIndex] = cardId;
    } else if (type === 'board') {
      board.value[id] = cardId;
    }
    closeCardPicker();
    recordState(`Se asigna la carta ${cardId}.`);
  }
  function unassignCard(target) {
    const { type, id, cardIndex } = target;
    let cardToUnassign = '';
    if (type === 'player') {
      const player = players.value.find(p => p.id === id);
      if (player) {
        cardToUnassign = player.cards[cardIndex];
        player.cards[cardIndex] = '';
      }
    } else if (type === 'board') {
      cardToUnassign = board.value[id];
      board.value[id] = '';
    }
    if (cardToUnassign) {
      recordState(`Se desasigna la carta ${cardToUnassign}.`);
    }
  }

  function getPositions(numPlayers) {
    if (numPlayers === 2) { return ['BTN / SB', 'BB']; }
    if (numPlayers === 3) { return ['BTN', 'SB', 'BB']; }
    if (numPlayers === 4) { return ['BTN', 'SB', 'BB', 'CO']; }
    if (numPlayers === 5) { return ['BTN', 'SB', 'BB', 'MP', 'CO']; }
    if (numPlayers === 6) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'CO']; }
    if (numPlayers === 7) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'HJ', 'CO']; }
    if (numPlayers === 8) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'HJ', 'CO']; }
    if (numPlayers === 9) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'LJ', 'HJ', 'CO']; }
    const basePositions = ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP1', 'MP2', 'HJ', 'CO'];
    return basePositions.slice(0, numPlayers);
  }

  function updatePlayerName(playerId, newName) {
    if (!newName.trim()) return;
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.name = newName;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updatePlayerStack(playerId, newStack) {
    const stack = parseInt(newStack, 10);
    if (isNaN(stack) || stack < 0) return;
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.stack = stack;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updatePlayerNotes(playerId, newNotes) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.notes = newNotes;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updatePlayerTag(playerId, newTag) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.tag = player.tag === newTag ? null : newTag;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updatePlayerPosition(playerId, x, y) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.x = x;
      player.y = y;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updateTableLayout(element, x, y) {
    if (tableLayout.value[element]) {
      tableLayout.value[element].x = x;
      tableLayout.value[element].y = y;
    }
  }

  function toggleNotesPanel(playerId) {
    if (openNotesPanelPlayerId.value === playerId) {
      openNotesPanelPlayerId.value = null;
    } else {
      openNotesPanelPlayerId.value = playerId;
    }
  }

  function closeNotesPanel() {
    openNotesPanelPlayerId.value = null;
  }

  return {
    players, heroPosition, smallBlind, bigBlind, currency, specialRule, bombPotBB, board, savedHands, pots,
    gamePhase, activePlayerIndex, currentBet, lastRaiseAmount,
    activePlayer, totalPot, displayInBBs,
    isReplaying, isCardPickerOpen, usedCards,
    replaySpeed, isPreActionPhase, openNotesPanelPlayerId, tableLayout,
    toggleDisplayMode,
    playReplay, pauseReplay, restartReplay, setReplaySpeed, toggleReplay,
    setupNewHand, loadHand, saveCurrentHand, deleteHand, navigateHistory, recordState,
    performAction, resetHand,
    openCardPicker, closeCardPicker, assignCard, unassignCard,
    updatePlayerName, updatePlayerStack,
    updatePlayerNotes, updatePlayerTag, updatePlayerPosition, updateTableLayout, toggleNotesPanel, closeNotesPanel,
    fetchHands, loadMoreHands, hasMore, currentOffset, pageSize,
  }
});

---------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useAuthStore.js ---

import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
import { supabase } from '@/supabase';
import { useGameStore } from './game';
import { useSessionStore } from './useSessionStore';
import { useTripStore } from './useTripStore';

export const useAuthStore = defineStore('auth', () => {
  const user = ref(null);
  const session = ref(null);
  const profile = ref(null);
  const isInitialized = ref(false);

  async function fetchUserProfile() {
    if (!user.value) return;
    try {
      const { data, error } = await supabase
        .from('perfiles')
        .select('*')
        .eq('id', user.value.id)
        .single();
      if (error) throw error;
      profile.value = data;
    } catch (error) {
      console.error('Error fetching user profile:', error.message);
    }
  }

  // Listener simple que SÓLO gestiona el estado de autenticación.
  function listenToAuthState() {
    supabase.auth.onAuthStateChange(async (_event, newSession) => {
      session.value = newSession;
      user.value = newSession?.user ?? null;
      isInitialized.value = true;
    });
  }

  // WATCHER: El corazón de la nueva solución.
  // Reacciona cuando el usuario cambia (login/logout).
  watch(user, async (newUser, oldUser) => {
    if (newUser) {
      // Si hay un nuevo usuario (login), cargamos su perfil y todos sus datos.
      await fetchUserProfile();
      const gameStore = useGameStore();
      const sessionStore = useSessionStore();
      const tripStore = useTripStore();
      await Promise.all([
        gameStore.fetchHands(),
        sessionStore.fetchSessions(),
        tripStore.fetchTrips()
      ]);
    } else if (oldUser && !newUser) {
      // Si el usuario desaparece (logout), limpiamos los stores.
      profile.value = null;
      useGameStore().savedHands = [];
      useSessionStore().savedSessions = [];
      useTripStore().savedTrips = [];
    }
  });

  async function signIn(email, password) {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw error;
  }

  async function signUp(email, password, username) {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: { data: { nombre_usuario: username } }
    });
    if (error) throw error;
    return data;
  }

  async function signOut() {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
  }

  return {
    user,
    session,
    profile,
    isInitialized,
    listenToAuthState, // Reemplaza a initializeAuth
    signIn,
    signUp,
    signOut,
  };
});

-----------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useChartsStore.js ---

import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useChartsStore = defineStore('charts', () => {
  // --- STATE ---
  const timeRange = ref('all');
  const chartType = ref('line'); // <-- NUEVO ESTADO: 'line' o 'bar'

  // --- ACTIONS ---
  function setTimeRange(newRange) {
    timeRange.value = newRange;
  }

  function toggleChartType() {
    chartType.value = chartType.value === 'line' ? 'bar' : 'line';
  }

  return {
    timeRange,
    chartType, // <-- Exportar nuevo estado
    setTimeRange,
    toggleChartType, // <-- Exportar nueva acción
  };
});

-------------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useSessionStore.js ---

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { v4 as uuidv4 } from 'uuid';
import { supabase } from '@/supabase';
import { useAuthStore } from './useAuthStore';
import { apiFetchSessions, apiAddSession, apiDeleteSession } from '@/api'; // Importamos la API

export const useSessionStore = defineStore('session', () => {
  // --- STATE ---
  const isActive = ref(false);
  const elapsedTime = ref(0);
  let sessionTimerInterval = null;
  const isOnBreak = ref(false);
  const breakElapsedTime = ref(0);
  let breakTimerInterval = null;
  const totalBreakTime = ref(0);
  const totalRebuys = ref(0);
  const totalExpenses = ref(0);
  const playerCount = ref(6);
  const blinds = ref('1/2');
  const location = ref('');
  const currency = ref('$');
  const initialStack = ref(200);
  const savedSessions = ref([]);
  
  const summaryDateFilter = ref('all');

  function setSummaryDateFilter(newFilter) {
    summaryDateFilter.value = newFilter;
  }

  const filteredSessionsForSummary = computed(() => {
    const filter = summaryDateFilter.value;
    if (filter === 'all') {
      return savedSessions.value;
    }

    const now = new Date();
    const cutoffDate = new Date();
    
    cutoffDate.setHours(0, 0, 0, 0); 

    switch (filter) {
      case 'last7days': cutoffDate.setDate(now.getDate() - 7); break;
      case 'last1month': cutoffDate.setMonth(now.getMonth() - 1); break;
      case 'last3months': cutoffDate.setMonth(now.getMonth() - 3); break;
      case 'last6months': cutoffDate.setMonth(now.getMonth() - 6); break;
      case 'last1year': cutoffDate.setFullYear(now.getFullYear() - 1); break;
    }

    return savedSessions.value.filter(session => {
      const sessionDate = new Date(session.fecha);
      return sessionDate >= cutoffDate;
    });
  });

  const totalNetProfit = computed(() => {
    return filteredSessionsForSummary.value.reduce((total, session) => total + (parseFloat(session.resultado) || 0), 0);
  });

  const totalInvestment = computed(() => {
    return filteredSessionsForSummary.value.reduce((total, session) => {
      return total + (parseFloat(session.stack_inicial) || 0) + (parseFloat(session.total_recompras) || 0);
    }, 0);
  });
  
  const roi = computed(() => {
    if (totalInvestment.value === 0) return 0;
    return (totalNetProfit.value / totalInvestment.value) * 100;
  });

  const winningDays = computed(() => {
    return filteredSessionsForSummary.value.filter(session => session.resultado > 0).length;
  });

  const losingDays = computed(() => {
    return filteredSessionsForSummary.value.filter(session => session.resultado < 0).length;
  });

  const bestDay = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const results = filteredSessionsForSummary.value.map(session => parseFloat(session.resultado) || 0);
    return Math.max(...results);
  });

  const worstDay = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const results = filteredSessionsForSummary.value.map(session => parseFloat(session.resultado) || 0);
    return Math.min(...results);
  });

  const winningStreak = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const chronologicalSessions = [...filteredSessionsForSummary.value].sort((a,b) => new Date(a.fecha) - new Date(b.fecha));
    let maxStreak = 0;
    let currentStreak = 0;
    for (const session of chronologicalSessions) {
      if (session.resultado > 0) {
        currentStreak++;
      } else {
        maxStreak = Math.max(maxStreak, currentStreak);
        currentStreak = 0;
      }
    }
    maxStreak = Math.max(maxStreak, currentStreak);
    return maxStreak;
  });

  const averageBuyIn = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const totalInvest = filteredSessionsForSummary.value.reduce((total, session) => total + (parseFloat(session.stack_inicial) || 0) + (parseFloat(session.total_recompras) || 0), 0);
    return totalInvest / filteredSessionsForSummary.value.length;
  });
  
  const averageCashOut = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const totalCashOut = filteredSessionsForSummary.value.reduce((total, session) => total + (parseFloat(session.stack_final) || 0), 0);
    return totalCashOut / filteredSessionsForSummary.value.length;
  });

  const sessionCount = computed(() => filteredSessionsForSummary.value.length);

  const totalHoursPlayed = computed(() => {
    const totalSeconds = filteredSessionsForSummary.value.reduce((total, session) => total + (session.duracion_segundos || 0), 0);
    return totalSeconds / 3600;
  });
  
  const averageHoursPlayed = computed(() => {
    if (sessionCount.value === 0) return 0;
    return totalHoursPlayed.value / sessionCount.value;
  });

  const averageBreakDuration = computed(() => {
    if (sessionCount.value === 0) return 0;
    const totalBreakSeconds = filteredSessionsForSummary.value.reduce((total, session) => total + (session.tiempo_descanso_segundos || 0), 0);
    const sessionsWithBreaks = filteredSessionsForSummary.value.filter(s => s.tiempo_descanso_segundos > 0).length;
    if (sessionsWithBreaks === 0) return 0;
    return (totalBreakSeconds / sessionsWithBreaks) / 60;
  });

  const winRatePerHour = computed(() => {
    if (totalHoursPlayed.value === 0) return 0;
    return totalNetProfit.value / totalHoursPlayed.value;
  });

  const averageRebuys = computed(() => {
    if (sessionCount.value === 0) return 0;
    const totalRebuysAmount = filteredSessionsForSummary.value.reduce((sum, session) => sum + (parseFloat(session.total_recompras) || 0), 0);
    return totalRebuysAmount / sessionCount.value;
  });

  const totalAllExpenses = computed(() => {
    return filteredSessionsForSummary.value.reduce((sum, session) => sum + (parseFloat(session.total_gastos) || 0), 0);
  });

  async function fetchSessions() {
    // La lógica ahora llama a la API centralizada
    savedSessions.value = await apiFetchSessions();
  }

  function startSession() {
    elapsedTime.value = 0;
    totalBreakTime.value = 0;
    totalRebuys.value = 0;
    totalExpenses.value = 0;
    isActive.value = true;
    isOnBreak.value = false;
    
    clearInterval(sessionTimerInterval);
    sessionTimerInterval = setInterval(() => {
      if (!isOnBreak.value) {
        elapsedTime.value++;
      }
    }, 1000);
  }

  function startBreak() {
    if (!isActive.value) return;
    isOnBreak.value = true;
    breakElapsedTime.value = 0;

    clearInterval(breakTimerInterval);
    breakTimerInterval = setInterval(() => {
      breakElapsedTime.value++;
    }, 1000);
  }

  function endBreak() {
    isOnBreak.value = false;
    totalBreakTime.value += breakElapsedTime.value;
    clearInterval(breakTimerInterval);
    breakTimerInterval = null;
  }

  function addRebuy(amount) {
    if (amount > 0) {
      totalRebuys.value += amount;
    }
  }

  function addExpense(amount) {
    if (amount > 0) {
      totalExpenses.value += amount;
    }
  }
  
  // *** ÚNICO BLOQUE MODIFICADO ***
  async function stopAndSaveSession(finalStack) {
    try {
      if (isOnBreak.value) {
        totalBreakTime.value += breakElapsedTime.value;
      }

      const ensureFloat = (value) => {
          const num = parseFloat(value);
          return isNaN(num) ? 0.0 : num;
      };

      const currentInvestment = ensureFloat(initialStack.value) + ensureFloat(totalRebuys.value);
      const result = ensureFloat(finalStack) - currentInvestment - ensureFloat(totalExpenses.value);

      const sessionData = {
        fecha: new Date().toISOString().split('T')[0],
        duracion_segundos: ensureFloat(elapsedTime.value),
        tiempo_descanso_segundos: ensureFloat(totalBreakTime.value),
        cantidad_jugadores: playerCount.value || 2,
        ciegas: blinds.value || 'N/A',
        ubicacion: location.value || null,
        moneda: currency.value || '$',
        stack_inicial: ensureFloat(initialStack.value),
        total_recompras: ensureFloat(totalRebuys.value),
        total_gastos: ensureFloat(totalExpenses.value),
        stack_final: ensureFloat(finalStack),
        resultado: result,
      };
      
      // 1. Guardamos en la BBDD a través de la API
      await apiAddSession(sessionData);
      
      // 2. Volvemos a cargar TODAS las sesiones para asegurar consistencia
      await fetchSessions();

    } catch (error) {
      console.error('Error en el store al guardar sesión:', error);
      throw error; // Propaga el error para que la vista lo maneje
    } finally {
      // Este bloque se ejecuta siempre, haya error o no.
      isActive.value = false;
      isOnBreak.value = false;
      clearInterval(sessionTimerInterval);
      clearInterval(breakTimerInterval);
      sessionTimerInterval = null;
      breakTimerInterval = null;
      elapsedTime.value = 0;
      breakElapsedTime.value = 0;
    }
  }
  
  async function deleteSession(sessionId) {
    try {
      // Llama a la API para borrar
      await apiDeleteSession(sessionId);
      // Vuelve a cargar para mantener la consistencia
      await fetchSessions();
    } catch (error) {
      console.error('Error deleting session:', error.message);
    }
  }

  return {
    isActive, elapsedTime, isOnBreak, breakElapsedTime, playerCount, blinds, 
    location, currency, initialStack, savedSessions, totalRebuys, totalExpenses,
    summaryDateFilter,
    totalNetProfit,
    averageBuyIn,
    averageCashOut,
    sessionCount,
    totalHoursPlayed,
    averageHoursPlayed,
    averageBreakDuration,
    winRatePerHour,
    roi,
    winningDays,
    losingDays,
    bestDay,
    worstDay,
    winningStreak,
    averageRebuys,
    totalAllExpenses,
    startSession, startBreak, endBreak, stopAndSaveSession, deleteSession,
    addRebuy, addExpense,
    setSummaryDateFilter,
    fetchSessions,
  };
});

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useSettingsStore.js ---

import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
import i18n from '../i18n'; // Importamos la instancia de i18n

export const useSettingsStore = defineStore('settings', () => {
  const locale = ref(localStorage.getItem('locale') || 'es');

  function setLocale(newLocale) {
    locale.value = newLocale;
  }

  // Observador que actualiza la librería i18n y el localStorage cuando cambia el idioma
  watch(locale, (newLocale) => {
    i18n.global.locale.value = newLocale;
    localStorage.setItem('locale', newLocale);
  });

  return {
    locale,
    setLocale,
  };
});

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useTripStore.js ---

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { v4 as uuidv4 } from 'uuid';
import { apiFetchTrips, apiAddOrUpdateTrip, apiDeleteTrip } from '@/api';

export const useTripStore = defineStore('trip', () => {
  // --- STATE ---
  const savedTrips = ref([]);
  const currentTripId = ref(null); 

  // --- STATE DE PLANIFICACIÓN ---
  const playerCount = ref(4);
  const city = ref('');
  const casino = ref('');
  const players = ref([]);
  const currency = ref('$');
  const repartoType = ref('participation');

  // --- ESTADO DE SEGUIMIENTO ---
  const isTripActive = ref(false);
  const tripDays = ref([]);
  const dailyResults = ref({});

  // --- COMPUTED ---
  const collectiveBankroll = computed(() => {
    return players.value.reduce((sum, player) => sum + (player.individualBankroll || 0), 0);
  });

  const tripTotalProfit = computed(() => {
    return Object.values(dailyResults.value).reduce((total, dayResults) => {
      const dayTotal = Object.values(dayResults).reduce((daySum, playerData) => daySum + (playerData.result || 0), 0);
      return total + dayTotal;
    }, 0);
  });
  
  const totalParticipation = computed(() => {
    const sum = players.value.reduce((sum, player) => sum + (parseFloat(player.participation) || 0), 0);
    return parseFloat(sum.toFixed(2));
  });

  const playerTotalHours = computed(() => {
    const totals = {};
    players.value.forEach(player => { totals[player.id] = 0; });
    for (const day in dailyResults.value) {
      for (const playerId in dailyResults.value[day]) {
        if (totals[playerId] !== undefined) {
          totals[playerId] += dailyResults.value[day][playerId].hours || 0;
        }
      }
    }
    return totals;
  });

  const tripTotalHours = computed(() => {
    return Object.values(playerTotalHours.value).reduce((sum, hours) => sum + hours, 0);
  });

  const playerTotals = computed(() => {
    const totals = {};
    players.value.forEach(player => { totals[player.id] = 0; });
    for (const day in dailyResults.value) {
      for (const playerId in dailyResults.value[day]) {
        if (totals[playerId] !== undefined) {
          totals[playerId] += dailyResults.value[day][playerId].result || 0;
        }
      }
    }
    return totals;
  });
  
  const playerFinalShares = computed(() => {
    const finalBankroll = collectiveBankroll.value + tripTotalProfit.value;
    const shares = {};

    if (repartoType.value === 'hours') {
      if (tripTotalHours.value === 0) return shares; // Evitar división por cero
      players.value.forEach(player => {
        const playerHours = playerTotalHours.value[player.id] || 0;
        const hourPercentage = (playerHours / tripTotalHours.value) * 100;
        const shareAmount = (hourPercentage / 100) * finalBankroll;
        shares[player.id] = isNaN(shareAmount) ? 0 : shareAmount;
      });
    } else { // Reparto por participación
      players.value.forEach(player => {
        const participationPercent = parseFloat(player.participation) || 0;
        const shareAmount = (participationPercent / 100) * finalBankroll;
        shares[player.id] = isNaN(shareAmount) ? 0 : shareAmount;
      });
    }
    return shares;
  });

  const playerAverageWinRates = computed(() => {
    const rates = {};
    players.value.forEach(player => {
      const totalProfit = playerTotals.value[player.id];
      const totalHours = playerTotalHours.value[player.id];
      rates[player.id] = totalHours > 0 ? totalProfit / totalHours : 0;
    });
    return rates;
  });

  const tripAverageWinRate = computed(() => {
    return tripTotalHours.value > 0 ? tripTotalProfit.value / tripTotalHours.value : 0;
  });

  // --- ACTIONS (Refactorizadas para usar API) ---
  
  async function fetchTrips() {
    try {
        savedTrips.value = await apiFetchTrips();
    } catch (error) {
        console.error("Error al cargar los viajes:", error);
        savedTrips.value = [];
    }
  }

  async function saveCurrentTrip() {
    const tripData = {
      id: currentTripId.value,
      city: city.value,
      casino: casino.value,
      players: players.value,
      currency: currency.value,
      repartoType: repartoType.value,
      isTripActive: isTripActive.value,
      tripDays: tripDays.value,
      dailyResults: dailyResults.value,
    };

    try {
      const savedTripId = await apiAddOrUpdateTrip(tripData);
      if (!currentTripId.value) {
        currentTripId.value = savedTripId;
      }
      await fetchTrips(); // Recargamos la lista completa para reflejar los cambios
      alert('¡Viaje guardado con éxito!');
    } catch (error) {
      alert(`Error al guardar el viaje: ${error.message}`);
    }
  }
  
  function loadTrip(tripId) {
    const tripToLoad = savedTrips.value.find(t => t.id === tripId);
    if (!tripToLoad) {
        console.error("No se encontró el viaje para cargar con ID:", tripId);
        return;
    }
    
    // Mapeo de nombres de columna de la DB a estado local
    currentTripId.value = tripToLoad.id;
    playerCount.value = tripToLoad.players ? tripToLoad.players.length : 0;
    city.value = tripToLoad.ciudad;
    casino.value = tripToLoad.casino;
    players.value = tripToLoad.players;
    currency.value = tripToLoad.moneda;
    repartoType.value = tripToLoad.tipo_reparto;
    isTripActive.value = tripToLoad.activo;
    tripDays.value = tripToLoad.tripDays;
    dailyResults.value = tripToLoad.dailyResults;
  }

  async function deleteTrip(tripId) {
    try {
        await apiDeleteTrip(tripId);
        savedTrips.value = savedTrips.value.filter(t => t.id !== tripId);
    } catch(error) {
        alert(`Error al borrar el viaje: ${error.message}`);
    }
  }
  
  function resetCurrentTrip() {
    currentTripId.value = null;
    playerCount.value = 4;
    city.value = '';
    casino.value = '';
    players.value = [];
    currency.value = '$';
    repartoType.value = 'participation';
    isTripActive.value = false;
    tripDays.value = [];
    dailyResults.value = {};
    setPlayerCount(4);
  }

  function recalculateParticipations() {
    const totalBank = collectiveBankroll.value;
    if (totalBank === 0) {
      players.value.forEach(player => { player.participation = 0; });
      return;
    }
    players.value.forEach(player => {
      const bankroll = player.individualBankroll || 0;
      player.participation = parseFloat(((bankroll / totalBank) * 100).toFixed(2));
    });
    const currentTotal = totalParticipation.value;
    const difference = 100 - currentTotal;
    if (difference !== 0 && players.value.length > 0) {
      players.value[0].participation = parseFloat((players.value[0].participation + difference).toFixed(2));
    }
  }
  
  function setPlayerCount(newCount) {
    const currentCount = players.value.length;
    if (newCount > currentCount) {
      for (let i = currentCount; i < newCount; i++) {
        players.value.push({
          id: uuidv4(),
          name: `Jugador ${i + 1}`,
          individualBankroll: 1000,
          participation: 0,
        });
      }
    } else if (newCount < currentCount) {
      players.value.splice(newCount);
    }
    playerCount.value = newCount;
    recalculateParticipations();
  }

  function updatePlayerBankroll(playerId, value) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.individualBankroll = parseFloat(value) || 0;
      recalculateParticipations();
    }
  }

  function startTrip() { isTripActive.value = true; }

  function addTripDay(dateString) {
    if (!dateString) return;
    if (!tripDays.value.includes(dateString)) {
      tripDays.value.push(dateString);
      tripDays.value.sort();
      dailyResults.value[dateString] = {};
      players.value.forEach(p => {
        dailyResults.value[dateString][p.id] = { result: 0, hours: 0, stake: '' };
      });
    }
  }

  function updatePlayerDailyData(day, playerId, field, value) {
    if (dailyResults.value[day]?.[playerId]) {
      const finalValue = (field === 'result' || field === 'hours') ? parseFloat(value) || 0 : value;
      dailyResults.value[day][playerId][field] = finalValue;
    }
  }

  return {
    savedTrips, currentTripId, playerCount, city, casino, players, currency, repartoType,
    isTripActive, tripDays, dailyResults,
    collectiveBankroll, tripTotalProfit, totalParticipation, playerFinalShares,
    playerTotalHours, tripTotalHours, playerAverageWinRates, tripAverageWinRate, playerTotals,
    fetchTrips, saveCurrentTrip, loadTrip, deleteTrip, resetCurrentTrip,
    setPlayerCount, startTrip, addTripDay, updatePlayerDailyData, updatePlayerBankroll,
  };
});

-----------------------------------------------------

--- INICIO DEL ARCHIVO: src/styles.css ---

:root {
  --table-green: #28563a;
  --table-blue: #3a4c8a;
  --table-red: #8a3a3a;
  --bg-color: #1a202c;
  --text-color: #e2e8f0;
  --border-color: #4a5568;
  --primary-color: #4299e1;
  --card-bg: #ffffff;

  /* --- TAMAÑOS DE CARTAS --- */
  --board-card-width: 70px;
  --board-card-height: 98px;
  --player-card-width: 70px;
  --player-card-height: 98px;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,
    Arial, sans-serif;
  margin: 0;
  background-color: var(--bg-color);
  color: var(--text-color);
  overscroll-behavior: none;
  /* Espacio en la parte inferior para la nueva barra de navegación fija */
  padding-bottom: 80px; 
}

#app {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
}

/* Tipografía fluida para los títulos principales de cada vista */
h2 {
  font-size: clamp(1.5rem, 4vw + 1rem, 2.2rem);
}

button {
  background-color: var(--primary-color);
  color: white;
  border: none;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: bold;
  transition: background-color 0.2s, transform 0.1s;
  /* Altura mínima para ser un buen "touch target" en móviles */
  min-height: 24px;
}

/* Solo aplicar :hover en dispositivos con un puntero (ratón), no en táctiles */
@media (hover: hover) and (pointer: fine) {
  button:hover {
    background-color: #2b6cb0;
  }
}

/* Feedback visual al pulsar el botón */
button:active {
  transform: scale(0.98);
}

button:disabled {
  background-color: #4a5568;
  cursor: not-allowed;
  transform: none;
}

input,
select {
  padding: 0.75rem;
  border-radius: 8px;
  border: 1px solid var(--border-color);
  background-color: #2d3748;
  color: var(--text-color);
  font-size: 1rem;
}

------------------------------------------

--- INICIO DEL ARCHIVO: src/supabase.js ---

import { createClient } from '@supabase/supabase-js'

// Obtén estos valores de tu panel de Supabase: Project Settings > API
const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

export const supabase = createClient(supabaseUrl, supabaseAnonKey)

-------------------------------------------

--- INICIO DEL ARCHIVO: src/views/AuthView.vue ---

<template>
  <div class="auth-container">
    <div class="auth-panel">
      <h2>{{ isLogin ? 'Iniciar Sesión' : 'Crear Cuenta' }}</h2>
      <form @submit.prevent="handleSubmit">
        <div class="form-group">
          <label for="email">Email</label>
          <input type="email" id="email" v-model="email" required>
        </div>
        <div v-if="!isLogin" class="form-group">
          <label for="username">Nombre de Usuario</label>
          <input type="text" id="username" v-model="username" required>
        </div>
        <div class="form-group">
          <label for="password">Contraseña</label>
          <input type="password" id="password" v-model="password" required>
        </div>
        <div v-if="errorMessage" class="error-message">
          {{ errorMessage }}
        </div>
        <button type="submit" class="auth-btn">{{ isLogin ? 'Entrar' : 'Registrarse' }}</button>
      </form>
      <div class="toggle-form">
        <a href="#" @click.prevent="isLogin = !isLogin">
          {{ isLogin ? '¿No tienes cuenta? Regístrate' : '¿Ya tienes cuenta? Inicia sesión' }}
        </a>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useAuthStore } from '@/store/useAuthStore';

const authStore = useAuthStore();
const isLogin = ref(true);
const email = ref('');
const password = ref('');
const username = ref('');
const errorMessage = ref('');

async function handleSubmit() {
  errorMessage.value = '';
  try {
    if (isLogin.value) {
      await authStore.signIn(email.value, password.value);
    } else {
      await authStore.signUp(email.value, password.value, username.value);
      alert('¡Registro exitoso! Revisa tu email para confirmar tu cuenta.');
    }
  } catch (error) {
    errorMessage.value = error.message;
  }
}
</script>

<style scoped>
.auth-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 2rem;
}
.auth-panel {
  width: 100%;
  max-width: 400px;
  background-color: #2d3748;
  padding: 2.5rem;
  border-radius: 12px;
}
h2 {
  text-align: center;
  margin-bottom: 2rem;
}
.form-group {
  margin-bottom: 1.5rem;
}
.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
}
.form-group input {
  width: 100%;
  box-sizing: border-box;
}
.error-message {
  color: #fc8181;
  background-color: rgba(197, 48, 48, .3);
  padding: 0.75rem;
  border-radius: 6px;
  margin-bottom: 1rem;
  text-align: center;
}
.auth-btn {
  width: 100%;
  padding: 15px;
  font-size: 1.2rem;
  font-weight: bold;
}
.toggle-form {
  margin-top: 1.5rem;
  text-align: center;
}
.toggle-form a {
  color: var(--primary-color);
  text-decoration: none;
}
.toggle-form a:hover {
  text-decoration: underline;
}
</style>

--------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/ChartsView.vue ---

<template>
  <div class="charts-container">
    <div class="header">
      <h2>{{ $t('charts.title') }}</h2>
      
      <div class="controls-wrapper">
        <div class="filter-controls">
          <label for="time-range">Mostrar:</label>
          <select id="time-range" v-model="chartsStore.timeRange">
            <option value="all">Todo</option>
            <option value="7d">Última Semana</option>
            <option value="1m">Último Mes</option>
            <option value="3m">Últimos 3 Meses</option>
            <option value="6m">Últimos 6 Meses</option>
            <option value="1y">Último Año</option>
          </select>
        </div>

        <button @click="chartsStore.toggleChartType()" class="toggle-chart-btn" :title="`Cambiar a gráfico de ${chartsStore.chartType === 'line' ? 'barras' : 'líneas'}`">
          <svg v-if="chartsStore.chartType === 'line'" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" />
          </svg>
          <svg v-else xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 18L9 11.25l4.306 4.307a11.95 11.95 0 015.814-5.519l2.74-1.22m0 0l-3.75-2.25M21 12l-3.75 2.25" />
          </svg>
        </button>
      </div>
    </div>
    
    <div v-if="isLoading" class="loading-message">
        Cargando datos para la gráfica...
    </div>
    <div v-else-if="sessionStore.savedSessions.length < 2" class="no-data-message">
      {{ $t('charts.noData') }}
    </div>
    <div v-else class="chart-wrapper">
      <SessionChart />
    </div>
  </div>
</template>

<script setup>
import { ref, onActivated } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import { useChartsStore } from '../store/useChartsStore';
import SessionChart from '../components/SessionChart.vue';

const sessionStore = useSessionStore();
const chartsStore = useChartsStore();
const isLoading = ref(true);

onActivated(async () => {
    isLoading.value = true;
    await sessionStore.fetchSessions();
    isLoading.value = false;
});
</script>

<style scoped>
.charts-container {
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  flex-wrap: wrap;
  gap: 1rem;
}
h2 {
  margin: 0;
  font-size: 2rem;
}
.controls-wrapper {
  display: flex;
  align-items: center;
  gap: 1.5rem;
}
.filter-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}
.filter-controls label {
  font-weight: bold;
  color: #a0aec0;
}
.filter-controls select {
  padding: 8px 12px;
  font-size: 1rem;
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: white;
}
.toggle-chart-btn {
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s;
}
.toggle-chart-btn:hover {
  background-color: #2D3748;
}
.toggle-chart-btn svg {
  width: 24px;
  height: 24px;
  color: white;
}
.loading-message, .no-data-message {
  text-align: center;
  font-size: 1.2rem;
  color: #a0aec0;
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
}
.chart-wrapper {
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
}
</style>

----------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/CommunityView.vue ---

<template>
  <div class="trip-planner-container">
    <!-- Panel de Planificación -->
    <div v-if="!tripStore.isTripActive" class="planner-panel">
      <h2>Planificador de Viajes de Poker</h2>
      <div class="form-grid">
        <div class="form-column">
          <div class="config-item"><label for="trip-city">Ciudad</label><input id="trip-city" type="text" v-model="tripStore.city" placeholder="Ej: Las Vegas"></div>
          <div class="config-item"><label for="trip-casino">Casino / Club</label><input id="trip-casino" type="text" v-model="tripStore.casino" placeholder="Ej: Bellagio"></div>
          
          <!-- SELECTOR DE MONEDA ACTUALIZADO CON LA LISTA COMPLETA -->
          <div class="config-item">
            <label for="trip-currency">Moneda</label>
            <select id="trip-currency" v-model="tripStore.currency">
              <option v-for="c in currencies" :key="c.symbol" :value="c.symbol">
                {{ c.symbol }} - {{ c.name }}
              </option>
            </select>
          </div>

          <div class="config-item"><label for="player-count">Número de Jugadores</label><select id="player-count" v-model.number="tripStore.playerCount" @change="tripStore.setPlayerCount(tripStore.playerCount)"><option v-for="n in 14" :key="n" :value="n + 1">{{ n + 1 }} Jugadores</option></select></div>
          <div class="config-item collective-bankroll"><label>Banca Colectiva (Total)</label><div class="calculated-value">{{ tripStore.collectiveBankroll }} {{ tripStore.currency }}</div></div>
        </div>
        <div class="form-column">
          <div class="config-item">
            <label for="reparto-type">Tipo de Reparto Final</label>
            <select id="reparto-type" v-model="tripStore.repartoType">
              <option value="participation">Reparto por Aportación</option>
              <option value="hours">Reparto por Horas Jugadas</option>
            </select>
          </div>
          <div class="config-item">
            <label>Nombres y Aportación</label>
            <div class="player-list">
              <div v-for="player in tripStore.players" :key="player.id" class="player-entry">
                <input type="text" v-model="player.name" class="player-name-input" placeholder="Nombre">
                <div v-if="tripStore.repartoType === 'participation'" class="participation-input-group">
                  <input type="number" :value="player.individualBankroll" @input="tripStore.updatePlayerBankroll(player.id, $event.target.value)" class="player-participation-input" min="0">
                  <span class="currency-symbol">{{ tripStore.currency }}</span>
                  <span class="participation-percentage">({{ player.participation.toFixed(2) }}%)</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="actions-footer"><button class="start-trip-btn" @click="tripStore.startTrip()">Iniciar Viaje</button></div>
    </div>

    <!-- Panel de Seguimiento por Días -->
    <div v-else class="tracking-panel">
      <header class="tracking-header">
        <h2>Seguimiento del Viaje</h2>
        <div class="trip-info"><span><strong>Destino:</strong> {{ tripStore.city || 'N/A' }}, {{ tripStore.casino || 'N/A' }}</span></div>
        <div class="trip-actions-header">
          <button @click="handleSaveTrip()" class="save-trip-btn">Guardar Viaje</button>
          <button @click="tripStore.resetCurrentTrip()" class="new-trip-btn">Nuevo Viaje</button>
        </div>
        <div class="add-day-form">
          <input type="date" v-model="newDayDateString" class="date-input">
          <button @click="confirmAddDay" class="add-day-btn">Añadir Día</button>
        </div>
      </header>
      
      <div class="days-container">
        <div v-for="day in tripStore.tripDays" :key="day" class="day-card">
          <h3>Día: {{ new Date(day + 'T12:00:00').toLocaleDateString() }}</h3>
          <div class="player-results-list">
            <div v-for="player in tripStore.players" :key="player.id" class="player-session-details">
              <span class="player-name">{{ player.name }}</span>
              <div class="player-inputs-grid">
                <div class="input-group"><label>Resultado ({{ tripStore.currency }})</label><input type="number" :value="tripStore.dailyResults[day]?.[player.id]?.result" @input="tripStore.updatePlayerDailyData(day, player.id, 'result', $event.target.value)"></div>
                <div class="input-group"><label>Horas</label><input type="number" :value="tripStore.dailyResults[day]?.[player.id]?.hours" @input="tripStore.updatePlayerDailyData(day, player.id, 'hours', $event.target.value)"></div>
                <div class="input-group"><label>Stake</label><input type="text" :value="tripStore.dailyResults[day]?.[player.id]?.stake" @input="tripStore.updatePlayerDailyData(day, player.id, 'stake', $event.target.value)" placeholder="1/2"></div>
                <div class="input-group calculated"><label>{{ tripStore.currency }} / Hora</label><span :class="getResultClass(calculateWinRate(tripStore.dailyResults[day]?.[player.id]))">{{ calculateWinRate(tripStore.dailyResults[day]?.[player.id]).toFixed(2) }}</span></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div v-if="tripStore.tripDays.length > 0" class="totals-section">
        <h3>Resultados Acumulados</h3>
        <div class="player-totals-list">
           <div v-for="player in tripStore.players" :key="player.id" class="player-total-item-detailed">
              <span class="player-name">
                {{ player.name }}
                <span v-if="tripStore.repartoType === 'participation'">({{ player.participation || 0 }}%)</span>
              </span>
              <div class="player-financials">
                <div class="financial-item"><label>Horas Totales</label><span class="value">{{ tripStore.playerTotalHours[player.id]?.toFixed(1) || '0.0' }} h</span></div>
                <div class="financial-item"><label>Media {{tripStore.currency}}/h</label><span class="value" :class="getResultClass(tripStore.playerAverageWinRates[player.id])">{{ tripStore.playerAverageWinRates[player.id]?.toFixed(2) || '0.00' }}</span></div>
                <div class="financial-item"><label>P/L Individual</label><span class="value" :class="getResultClass(tripStore.playerTotals[player.id])">{{ tripStore.playerTotals[player.id]?.toFixed(2) || '0.00' }} {{ tripStore.currency }}</span></div>
                <div class="financial-item"><label>{{ repartoLabel }}</label><span class="value">{{ tripStore.playerFinalShares[player.id]?.toFixed(2) || '0.00' }} {{ tripStore.currency }}</span></div>
              </div>
            </div>
        </div>
        <div class="trip-totals-summary">
          <div class="trip-total-item"><label>Horas Totales del Viaje</label><span class="trip-total-value">{{ tripStore.tripTotalHours.toFixed(1) }} h</span></div>
          <div class="trip-total-item"><label>Media {{tripStore.currency}}/h del Viaje</label><span class="trip-total-value" :class="getResultClass(tripStore.tripAverageWinRate)">{{ tripStore.tripAverageWinRate.toFixed(2) }}</span></div>
          <div class="trip-total-item main-total"><label>Beneficio Total del Viaje</label><span class="trip-total-value" :class="getResultClass(tripStore.tripTotalProfit)">{{ tripStore.tripTotalProfit.toFixed(2) }} {{ tripStore.currency }}</span></div>
        </div>
      </div>
    </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Viaje guardado con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { onMounted, ref, computed } from 'vue';
import { useTripStore } from '../store/useTripStore';

const tripStore = useTripStore();
const showToast = ref(false);

// --- LISTA AMPLIADA DE LAS 30 MONEDAS MÁS USADAS ---
const currencies = ref([
  { symbol: '$', name: 'USD - Dólar estadounidense' },
  { symbol: '€', name: 'EUR - Euro' },
  { symbol: '¥', name: 'JPY - Yen japonés' },
  { symbol: '£', name: 'GBP - Libra esterlina' },
  { symbol: 'A$', name: 'AUD - Dólar australiano' },
  { symbol: 'C$', name: 'CAD - Dólar canadiense' },
  { symbol: 'CHF', name: 'CHF - Franco suizo' },
  { symbol: 'CN¥', name: 'CNY - Yuan chino' },
  { symbol: 'SEK', name: 'SEK - Corona sueca' },
  { symbol: 'NZ$', name: 'NZD - Dólar neozelandés' },
  { symbol: 'Mex$', name: 'MXN - Peso mexicano' },
  { symbol: 'S$', name: 'SGD - Dólar de Singapur' },
  { symbol: 'HK$', name: 'HKD - Dólar de Hong Kong' },
  { symbol: 'NOK', name: 'NOK - Corona noruega' },
  { symbol: '₩', name: 'KRW - Won surcoreano' },
  { symbol: '₺', name: 'TRY - Lira turca' },
  { symbol: '₽', name: 'RUB - Rublo ruso' },
  { symbol: '₹', name: 'INR - Rupia india' },
  { symbol: 'R$', name: 'BRL - Real brasileño' },
  { symbol: 'R', name: 'ZAR - Rand sudafricano' },
  { symbol: 'zł', name: 'PLN - Zloty polaco' },
  { symbol: '฿', name: 'THB - Baht tailandés' },
  { symbol: 'Rp', name: 'IDR - Rupia indonesia' },
  { symbol: 'Ft', name: 'HUF - Forinto húngaro' },
  { symbol: 'Kč', name: 'CZK - Corona checa' },
  { symbol: '₪', name: 'ILS - Nuevo séquel israelí' },
  { symbol: 'CLP$', name: 'CLP - Peso chileno' },
  { symbol: '₱', name: 'PHP - Peso filipino' },
  { symbol: 'د.إ', name: 'AED - Dírham de los EAU' },
  { symbol: 'Col$', name: 'COP - Peso colombiano' }
]);

const newDayDateString = ref(new Date().toISOString().split('T')[0]);

const repartoLabel = computed(() => {
  return tripStore.repartoType === 'hours' ? 'Reparto Final (x Horas)' : 'Reparto Final (x Aport.)';
});

function getResultClass(result) {
  if (result === undefined || result === null || result === 0) return 'even';
  return result > 0 ? 'profit' : 'loss';
}

function calculateWinRate(playerData) {
  if (!playerData || !playerData.hours || playerData.hours <= 0) { return 0; }
  return playerData.result / playerData.hours;
}

function confirmAddDay() {
  if (newDayDateString.value) { tripStore.addTripDay(newDayDateString.value); }
}

function handleSaveTrip() {
  tripStore.saveCurrentTrip();
  showToast.value = true;
  setTimeout(() => {
    showToast.value = false;
  }, 3000);
}

onMounted(() => {
  if (tripStore.players.length !== tripStore.playerCount) { 
    tripStore.setPlayerCount(tripStore.playerCount); 
  }
});
</script>

<style scoped>
/* --- (Estilos existentes sin cambios) --- */
.trip-planner-container { display: flex; justify-content: center; padding: 3rem; }
.planner-panel, .tracking-panel { width: 100%; max-width: 1000px; background-color: #2d3748; border-radius: 12px; padding: 2.5rem; }
h2 { margin-top: 0; margin-bottom: 2rem; text-align: center; font-size: 2.2rem; }
h3 { font-size: 1.6rem; color: #cbd5e0; border-bottom: 1px solid #4a5568; padding-bottom: 0.75rem; margin-bottom: 1.5rem; }
.form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 3rem; }
.form-column { display: flex; flex-direction: column; gap: 1.5rem; }
.config-item { display: flex; flex-direction: column; gap: 10px; }
.config-item label { font-weight: bold; font-size: 1.2rem; color: #a0aec0; }
.config-item input, .config-item select { padding: 15px; font-size: 1.1rem; border-radius: 6px; }
.collective-bankroll .calculated-value { background-color: #1a202c; padding: 15px; font-size: 1.5rem; font-weight: bold; border-radius: 6px; text-align: center; color: #68d391; }
.player-list { display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto; padding-right: 10px; }
.actions-footer { margin-top: 2rem; display: flex; justify-content: center; }
.start-trip-btn { background-color: #38a169; color: white; font-size: 1.4rem; padding: 15px 40px; border-radius: 8px; font-weight: bold; }
.player-entry { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
.player-name-input { width: 100%; }
.participation-input-group { display: flex; align-items: center; background-color: #2d3748; border: 1px solid var(--border-color); border-radius: 6px; padding-left: 10px; }
.player-participation-input { border: none; background: transparent; width: 100px; -moz-appearance: textfield; font-size: 1.1rem; color: var(--text-color); }
.player-participation-input::-webkit-outer-spin-button, .player-participation-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.participation-input-group .currency-symbol { color: #a0aec0; padding: 0 5px; }
.participation-input-group .participation-percentage { color: #a0aec0; font-size: 0.9rem; padding-right: 10px; min-width: 60px; text-align: right;}
.tracking-header { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin-bottom: 2rem; }
.trip-info { font-size: 1.2rem; }
.trip-actions-header { display: flex; gap: 1rem; }
.save-trip-btn { background-color: #38a169; color: white; padding: 12px 25px; font-size: 1.1rem; font-weight: bold; border-radius: 6px; }
.new-trip-btn { background-color: #718096; padding: 12px 25px; font-size: 1.1rem; font-weight: bold; border-radius: 6px; }
.add-day-form { display: flex; align-items: center; gap: 1rem; background-color: #1a202c; padding: 1rem; border-radius: 8px; }
.date-input { padding: 12px; font-size: 1.1rem; border-radius: 6px; border: 1px solid var(--border-color); background-color: #2d3748; color: var(--text-color); color-scheme: dark; }
.add-day-btn { background-color: var(--primary-color); padding: 12px 25px; font-size: 1.1rem; font-weight: bold; border-radius: 6px; }
.days-container { display: flex; flex-direction: column; gap: 2rem; }
.day-card { background-color: #1a202c; padding: 1.5rem; border-radius: 8px; border: 1px solid #4a5568; }
.player-results-list { display: flex; flex-direction: column; gap: 1.5rem; }
.player-session-details { border-bottom: 1px solid #3a475c; padding-bottom: 1.5rem; }
.player-session-details:last-child { border-bottom: none; padding-bottom: 0; }
.player-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 1rem; display: block; }
.player-inputs-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; align-items: flex-end; }
.input-group { display: flex; flex-direction: column; gap: 8px; }
.input-group label { font-size: 0.9rem; color: #a0aec0; font-weight: bold; }
.input-group input { width: 100%; padding: 10px; font-size: 1.1rem; border-radius: 4px; }
.input-group.calculated span { font-size: 1.4rem; font-weight: bold; padding: 8px 10px; text-align: center; }
.totals-section { margin-top: 3rem; background-color: #1a202c; padding: 1.5rem; border-radius: 8px; }
.player-totals-list { display: flex; flex-direction: column; gap: 1rem; margin-bottom: 2rem; }
.player-total-item-detailed { padding: 1rem; border: 1px solid #3a475c; border-radius: 6px; }
.player-total-item-detailed > .player-name { font-size: 1.3rem; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #3a475c; }
.player-financials { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
.financial-item { display: flex; flex-direction: column; }
.financial-item label { font-size: 0.9rem; color: #a0aec0; margin-bottom: 0.25rem; }
.financial-item .value { font-weight: bold; font-size: 1.2rem; }
.trip-totals-summary { display: flex; flex-direction: column; gap: 0.75rem; border-top: 2px solid #4a5568; padding-top: 1.5rem; }
.trip-total-item { display: flex; justify-content: space-between; font-size: 1.1rem; }
.trip-total-item.main-total { font-size: 1.6rem; font-weight: bold; }
.trip-total-value { font-weight: bold; }
.profit { color: #68d391; }
.loss { color: #fc8181; }
.even { color: #e2e8f0; }
.toast { position: fixed; top: 20px; right: 20px; display: flex; align-items: center; gap: 10px; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); z-index: 1000; animation: slideIn 0.3s ease-out; }
.success-toast { background-color: #38a169; color: white; }
.toast-icon { font-size: 1.5rem; font-weight: bold; }
.toast-message { font-size: 1rem; font-weight: bold; }
@keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

/* ========================================================== */
/* ===> NUEVO BLOQUE DE CÓDIGO PARA ADAPTAR A MÓVILES <=== */
/* ========================================================== */
@media (max-width: 640px) {
  .trip-planner-container {
    padding: 1rem;
  }
  .planner-panel, .tracking-panel {
    padding: 1.5rem;
  }
  h2 {
    font-size: 1.8rem;
    margin-bottom: 1.5rem;
  }
  .form-grid {
    /* El grid ya pasa a una columna por el minmax(), pero reducimos el gap */
    gap: 1.5rem;
  }
  .config-item label {
    font-size: 1rem; /* Reducimos el tamaño de la etiqueta */
  }
  .config-item input, .config-item select {
    padding: 12px; /* Reducimos el padding de los inputs */
    font-size: 1rem; /* Reducimos la fuente de los inputs */
  }
  .player-entry {
    /* Apilamos el nombre y la aportación en vertical */
    display: flex;
    flex-direction: column;
    align-items: stretch; /* Hacemos que ocupen todo el ancho */
    gap: 8px;
  }
  .player-participation-input {
    width: 100px; /* Aseguramos un ancho mínimo para el input de dinero */
  }
}
</style>

-------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/CurrentHandView.vue ---

<template>
  <div class="view-container">
    <!-- Panel de Configuración (visible cuando no hay mano activa) -->
    <div v-if="!handIsActive" class="configuration-panel">
      <h2></h2>
      <div class="config-item">
        <label for="player-count">Número de Jugadores:</label>
        <select id="player-count" v-model.number="selectedPlayers">
          <option v-for="n in 8" :key="n" :value="n + 1">{{ n + 1 }} Jugadores</option>
        </select>
      </div>
      <div class="blinds-container">
        <div class="config-item">
          <label for="sb-input">Ciega Pequeña:</label>
          <input id="sb-input" type="number" v-model.number="sbInput" min="1">
        </div>
        <div class="config-item">
          <label for="bb-input">Ciega Grande:</label>
          <input id="bb-input" type="number" v-model.number="bbInput" min="1">
        </div>
      </div>
      <div class="config-item">
        <label for="currency-select">Moneda:</label>
        <select id="currency-select" v-model="selectedCurrency">
          <option v-for="currency in currencies" :key="currency.symbol" :value="currency.symbol">
            {{ currency.symbol }} - {{ currency.name }}
          </option>
        </select>
      </div>
      <div class="config-item">
        <label for="special-rule-select">Regla Especial:</label>
        <select id="special-rule-select" v-model="selectedSpecialRule">
          <option value="Ninguno">Ninguno</option>
          <option value="Straddle">Straddle</option>
          <option value="Mississippi">Mississippi</option>
          <option value="Bomb Pot">Bomb Pot</option>
        </select>
      </div>
      <div v-if="selectedSpecialRule === 'Bomb Pot'" class="config-item">
        <label for="bomb-pot-bb-select">Bomb Pot BB:</label>
        <select id="bomb-pot-bb-select" v-model="selectedBombPotBB">
          <option value="2">2bb</option>
          <option value="3">3bb</option>
          <option value="4">4bb</option>
          <option value="5">5bb</option>
        </select>
      </div>
      <button @click="loadHandClicked">Iniciar Mano</button>
    </div>

    <!-- Contenedor del Editor de Manos (ahora con layout de Grid) -->
    <div v-else class="hand-editor-content">
      <PokerTable />
      <ActionPanel v-if="gameStore.gamePhase !== 'replay'" v-model="tableColorForActionPanel" />
      <DisplayOptions v-else v-model="tableColorForActionPanel" />
      <CardPicker v-if="gameStore.isCardPickerOpen" />
    </div>
    
    <!-- Overlay que pide girar el dispositivo (se muestra en móvil vertical) -->
    <RotateDeviceOverlay v-if="showRotateOverlay" />

    <ConfigurationModal
      v-if="showPositionModal"
      :positions="availablePositions"
      @confirm="handlePositionSelected"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue';
import { useGameStore } from '../store/game';
import PokerTable from '../components/PokerTable.vue';
import ActionPanel from '../components/ActionPanel.vue';
import DisplayOptions from '../components/DisplayOptions.vue';
import ConfigurationModal from '../components/ConfigurationModal.vue';
import CardPicker from '../components/CardPicker.vue';
import RotateDeviceOverlay from '../components/RotateDeviceOverlay.vue';

const gameStore = useGameStore();
const handIsActive = computed(() => gameStore.gamePhase !== 'setup');
const tableColorForActionPanel = ref('#28563a');

const selectedPlayers = ref(6);
const sbInput = ref(1);
const bbInput = ref(2);
const selectedCurrency = ref('$');
const selectedSpecialRule = ref('Ninguno');
const selectedBombPotBB = ref(2);

const showRotateOverlay = ref(false);

const checkOrientation = () => {
  const isPortrait = window.matchMedia('(orientation: portrait)').matches;
  const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
  showRotateOverlay.value = handIsActive.value && !isPortrait && isCoarsePointer;
};

watch(handIsActive, () => {
  checkOrientation();
});

const currencies = ref([
  { symbol: '$', name: 'USD - Dólar estadounidense' },
  { symbol: '€', name: 'EUR - Euro' },
  { symbol: '¥', name: 'JPY - Yen japonés' },
  { symbol: '£', name: 'GBP - Libra esterlina' },
  { symbol: 'A$', name: 'AUD - Dólar australiano' },
  { symbol: 'C$', name: 'CAD - Dólar canadiense' },
  { symbol: 'CHF', name: 'CHF - Franco suizo' },
  { symbol: 'CN¥', name: 'CNY - Yuan chino' },
  { symbol: 'SEK', name: 'SEK - Corona sueca' },
  { symbol: 'NZ$', name: 'NZD - Dólar neozelandés' },
  { symbol: 'Mex$', name: 'MXN - Peso mexicano' },
  { symbol: 'S$', name: 'SGD - Dólar de Singapur' },
  { symbol: 'HK$', name: 'HKD - Dólar de Hong Kong' },
  { symbol: 'NOK', name: 'NOK - Corona noruega' },
  { symbol: '₩', name: 'KRW - Won surcoreano' },
  { symbol: '₺', name: 'TRY - Lira turca' },
  { symbol: '₽', name: 'RUB - Rublo ruso' },
  { symbol: '₹', name: 'INR - Rupia india' },
  { symbol: 'R$', name: 'BRL - Real brasileño' },
  { symbol: 'R', name: 'ZAR - Rand sudafricano' },
  { symbol: 'zł', name: 'PLN - Zloty polaco' },
  { symbol: '฿', name: 'THB - Baht tailandés' },
  { symbol: 'Rp', name: 'IDR - Rupia indonesia' },
  { symbol: 'Ft', name: 'HUF - Forinto húngaro' },
  { symbol: 'Kč', name: 'CZK - Corona checa' },
  { symbol: '₪', name: 'ILS - Nuevo séquel israelí' },
  { symbol: 'CLP$', name: 'CLP - Peso chileno' },
  { symbol: '₱', name: 'PHP - Peso filipino' },
  { symbol: 'د.إ', name: 'AED - Dírham de los EAU' },
  { symbol: 'Col$', name: 'COP - Peso colombiano' }
]);

const showPositionModal = ref(false);

const availablePositions = computed(() => {
  return getPositionsForCount(selectedPlayers.value);
});

function loadHandClicked() {
  showPositionModal.value = true;
}

function handlePositionSelected(heroPosition) {
  showPositionModal.value = false;
  gameStore.setupNewHand(
    selectedPlayers.value,
    heroPosition,
    selectedCurrency.value,
    sbInput.value,
    bbInput.value,
    selectedSpecialRule.value,
    selectedSpecialRule.value === 'Bomb Pot' ? selectedBombPotBB.value : null
  );
}

function getPositionsForCount(numPlayers) {
  if (numPlayers === 2) { return ['BTN / SB', 'BB']; }
  if (numPlayers === 3) { return ['BTN', 'SB', 'BB']; }
  if (numPlayers === 4) { return ['BTN', 'SB', 'BB', 'CO']; }
  if (numPlayers === 5) { return ['BTN', 'SB', 'BB', 'MP', 'CO']; }
  if (numPlayers === 6) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'CO']; }
  if (numPlayers === 7) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'HJ', 'CO']; }
  if (numPlayers === 8) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'HJ', 'CO']; }
  if (numPlayers === 9) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'LJ', 'HJ', 'CO']; }
  return [];
}

function handleKeyDown(event) {
  if (!handIsActive.value) return;
  if (document.activeElement.tagName === 'INPUT' && (event.key === 'ArrowRight' || event.key === 'ArrowLeft')) {
    return;
  }
  if (event.key === 'ArrowRight') gameStore.navigateHistory(1);
  else if (event.key === 'ArrowLeft') gameStore.navigateHistory(-1);
}

onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('resize', checkOrientation);
  checkOrientation();
});

onUnmounted(() => {
  window.removeEventListener('resize', checkOrientation);
  window.removeEventListener('keydown', handleKeyDown);
  gameStore.pauseReplay();
});
</script>

<style scoped>
.view-container {
  width: 100%;
  height: calc(100vh - 70px);
  display: flex;
  flex-direction: column;
}
.configuration-panel {
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; gap: 30px; padding: 3.5rem;
  max-width: 500px; margin: 1rem auto;
  background-color: #2d3748; border-radius: 12px;
}
h2 { font-size: 2.5rem; margin-bottom: -50px; }
.config-item { display: flex; flex-direction: column; align-items: center; gap: 12px; }
label { font-weight: bold; font-size: 1.2rem; }
select, input[type="number"] { padding: 15px; font-size: 1.2rem; width: 250px; text-align: center; box-sizing: border-box; border-radius: 8px; }
#currency-select { width: 350px; text-align: left; }
.blinds-container { display: flex; gap: 20px; }
.blinds-container .config-item { width: auto; }
.blinds-container input { width: 150px; }
button { padding: 8px 35px; font-size: 1.4rem; font-weight: bold; border-radius: 8px; margin-top: 10px; }

/* --- NUEVA LÓGICA DE LAYOUT CON GRID --- */
.hand-editor-content {
  width: 100%;
  height: 100%;
  display: grid;
  /* Por defecto (escritorio), una columna con la mesa arriba y el panel abajo */
  grid-template-rows: 1fr auto;
  grid-template-columns: 100%;
  gap: 15px;
  padding: 15px;
  box-sizing: border-box;
  overflow: hidden;
}

.rotate-device-prompt { display: none; }

/* Ocultar editor y mostrar aviso en móvil vertical */
@media (hover: none) and (pointer: coarse) and (orientation: portrait) {
  /* .rotate-device-prompt { display: flex; } */
  .hand-editor-content {
      /* display: none;  */
  }
}

/* Reorganizar layout para pantallas apaisadas y no muy altas (móviles horizontales) */
@media screen and (orientation: landscape) and (max-height: 600px) {
  .hand-editor-content {
    /* Columna flexible para la mesa (min 0), columna fija para acciones */
    grid-template-columns: minmax(0, 1fr) minmax(280px, 350px);
    grid-template-rows: 100%; /* Una sola fila */
    gap: 10px;
    padding: 10px;
  }
}

/* Estilos para el panel de configuración en pantallas pequeñas */
@media screen and (max-width: 640px) {
  .configuration-panel { padding: 1.5rem; margin: 1rem; gap: 15px; }
  h2 { font-size: 2rem; }
  .config-item { width: 100%; }
  select, input[type="number"] { width: 100%; max-width: 350px; }
  .blinds-container { flex-direction: column; width: 100%; }
  .blinds-container .config-item, .blinds-container input { width: 100%; }
  button { width: 100%; }
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/LiveSessionView.vue ---

<template>
  <div class="live-session-container">
    <div class="session-panel">

      <!-- WIDGET DEL TEMPORIZADOR -->
      <div class="widget timer-widget" :class="{ 'on-break': sessionStore.isOnBreak }">
        <div class="widget-header">
          <span class="status-indicator"></span>
          <span>{{ sessionStore.isOnBreak ? 'EN DESCANSO' : (sessionStore.isActive ? 'SESIÓN ACTIVA' : 'SESIÓN DETENIDA') }}</span>
        </div>
        <div class="timer-display">
          {{ formattedTime }}
        </div>
      </div>

      <!-- WIDGET DE ACCIONES RÁPIDAS (solo visible durante la sesión) -->
      <div v-if="sessionStore.isActive && !sessionStore.isOnBreak" class="widget actions-widget">
        <div class="widget-header">
          <span>ACCIONES RÁPIDAS</span>
        </div>
        <div class="live-actions">
          <div class="action-group">
            <input type="number" v-model.number="rebuyAmount" placeholder="Monto Recarga">
            <button @click="handleAddRebuy">Añadir Recarga</button>
          </div>
          <div class="action-group">
            <input type="number" v-model.number="tipAmount" placeholder="Propina">
            <button @click="handleAddTip">Tip Dealer</button>
          </div>
          <div class="action-group">
            <input type="number" v-model.number="expenseAmount" placeholder="Gasto">
            <button @click="handleAddExpense">Consumición</button>
          </div>
        </div>
      </div>

      <!-- WIDGET DE CONFIGURACIÓN -->
      <div class="widget config-widget">
         <div class="widget-header">
          <span>CONFIGURACIÓN DE LA PARTIDA</span>
        </div>
        <fieldset class="config-fieldset" :disabled="sessionStore.isActive">
          <div class="config-grid">
            <div class="config-item">
              <label for="player-count">Jugadores</label>
              <select id="player-count" v-model.number="sessionStore.playerCount">
                <option v-for="n in 8" :key="n" :value="n + 1">{{ n + 1 }} jugadores</option>
              </select>
            </div>
            <div class="config-item">
              <label for="blinds">Ciegas</label>
              <input type="text" id="blinds" v-model="sessionStore.blinds" placeholder="Ej: 1/2">
            </div>
            <div class="config-item">
              <label for="location">Lugar</label>
              <input type="text" id="location" v-model="sessionStore.location" placeholder="Ej: Casino Gran Vía">
            </div>
            <div class="config-item">
              <label for="currency">Moneda</label>
              <select id="currency" v-model="sessionStore.currency">
                <option>$</option><option>€</option><option>£</option>
              </select>
            </div>
            <div class="config-item">
              <label for="initial-stack">Buy-in</label>
              <input type="number" id="initial-stack" v-model.number="sessionStore.initialStack" placeholder="Ej: 200">
            </div>
          </div>
        </fieldset>
      </div>
      
      <!-- CONTROLES PRINCIPALES -->
      <div class="main-controls">
        <button v-if="!sessionStore.isActive" @click="sessionStore.startSession()" class="btn-play">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" /></svg>
          <span>INICIAR SESIÓN</span>
        </button>
        <template v-if="sessionStore.isActive">
          <button v-if="!sessionStore.isOnBreak" @click="sessionStore.startBreak()" class="btn-pause">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M14.25 9v6m-4.5 0V9M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <span>DESCANSO</span>
          </button>
          <button v-else @click="sessionStore.endBreak()" class="btn-play">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" /></svg>
            <span>FIN DEL DESCANSO</span>
          </button>
          <button @click="showEndSessionModal = true" class="btn-stop">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 019 14.437V9.564z" /></svg>
            <span>FINALIZAR SESIÓN</span>
          </button>
        </template>
      </div>
    </div>
    <EndSessionModal 
      v-if="showEndSessionModal" 
      @confirm="handleConfirmEndSession" 
      @cancel="showEndSessionModal = false"
      :is-saving="isSaving" 
    />
  </div>
</template>

<script setup>
import { computed, ref } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import { useAuthStore } from '../store/useAuthStore';
import EndSessionModal from '../components/EndSessionModal.vue';

const sessionStore = useSessionStore();
const authStore = useAuthStore();
const showEndSessionModal = ref(false);
const isSaving = ref(false);

const rebuyAmount = ref(null);
const tipAmount = ref(null);
const expenseAmount = ref(null);

function handleAddRebuy() {
  if (rebuyAmount.value > 0) {
    sessionStore.addRebuy(rebuyAmount.value);
    rebuyAmount.value = null;
  }
}
function handleAddTip() {
  if (tipAmount.value > 0) {
    sessionStore.addExpense(tipAmount.value);
    tipAmount.value = null;
  }
}
function handleAddExpense() {
  if (expenseAmount.value > 0) {
    sessionStore.addExpense(expenseAmount.value);
    expenseAmount.value = null;
  }
}

async function handleConfirmEndSession(finalStack) {
  isSaving.value = true;
  try {
    await sessionStore.stopAndSaveSession(finalStack);
    showEndSessionModal.value = false;
  } catch (error) {
    alert(`Error al guardar la sesión: ${error.message}`);
  } finally {
    isSaving.value = false;
  }
}

const formattedTime = computed(() => {
  const totalSeconds = sessionStore.isOnBreak ? sessionStore.breakElapsedTime : sessionStore.elapsedTime;
  const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
  const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
  const seconds = (totalSeconds % 60).toString().padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
});
</script>

<style scoped>
.live-session-container {
  display: flex;
  justify-content: center;
  padding: 2rem 1rem;
}
.session-panel {
  width: 100%;
  max-width: 950px;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  grid-template-areas:
    "timer timer"
    "actions config"
    "controls controls";
  gap: 2rem;
}

/* --- Widgets --- */
.widget {
  background-color: #2d3748;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  padding: 2rem;
}
.widget-header {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 1rem;
  font-weight: bold;
  color: #a0aec0;
  margin-bottom: 1.5rem;
  letter-spacing: 1px;
}
.timer-widget { grid-area: timer; }
.actions-widget { grid-area: actions; }
.config-widget { grid-area: config; }

/* --- Timer Widget --- */
.status-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: #718096;
  transition: background-color 0.3s ease;
}
.timer-widget:not(.on-break) .status-indicator {
  background-color: #68d391;
  animation: pulse 2s infinite;
}
.timer-widget.on-break .status-indicator {
  background-color: #63b3ed;
}
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(104, 211, 145, 0.7); }
  70% { box-shadow: 0 0 0 12px rgba(104, 211, 145, 0); }
  100% { box-shadow: 0 0 0 0 rgba(104, 211, 145, 0); }
}
.timer-display {
  font-family: 'Courier New', Courier, monospace;
  font-size: clamp(3.5rem, 10vw, 6rem);
  font-weight: 700;
  color: #fff;
  text-align: center;
}
.timer-widget.on-break .timer-display {
  color: #63b3ed;
}

/* --- Actions Widget --- */
.live-actions {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}
.action-group {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 1rem;
}
.action-group input {
  padding: 15px;
  font-size: 1.1rem;
  text-align: center;
}
.action-group button {
  padding: 15px;
  font-size: 1rem;
  background-color: #4A5568;
}

/* --- Config Widget --- */
.config-fieldset {
  border: none; padding: 0; margin: 0;
  transition: opacity 0.3s ease;
}
.config-fieldset:disabled { opacity: 0.6; }
.config-grid {
  display: grid; grid-template-columns: 1fr 1fr; 
  gap: 1.5rem;
}
.config-item { display: flex; flex-direction: column; gap: 10px; }
.config-item label { 
  font-weight: bold; 
  font-size: 1.1rem;
  color: #a0aec0; 
}
.config-item input, .config-item select { 
  font-size: 1.1rem;
  padding: 15px;
}

/* --- Main Controls --- */
.main-controls {
  grid-area: controls;
  display: flex;
  justify-content: center;
  gap: 1.5rem;
  margin-top: 1rem;
}
.main-controls button {
  display: flex; align-items: center; justify-content: center; gap: 12px;
  font-size: 1.3rem;
  font-weight: bold; 
  padding: 18px 30px;
  border-radius: 8px;
  flex-grow: 1; max-width: 300px;
}
.main-controls button svg { 
  width: 28px;
  height: 28px; 
}
.btn-play { background-color: #38a169; color: white; }
.btn-pause { background-color: #dd6b20; color: white; }
.btn-stop { background-color: #c53030; color: white; }

/* --- Media Queries for Responsiveness --- */
@media (max-width: 820px) {
  .session-panel {
    grid-template-columns: 1fr;
    grid-template-areas:
      "timer"
      "actions"
      "config"
      "controls";
    gap: 1.5rem;
  }
  .main-controls {
    flex-direction: column;
  }
  .main-controls button {
    max-width: none;
  }
  .config-grid {
    grid-template-columns: 1fr; /* Apila los inputs de configuración */
  }
}

/* ================================================== */
/* ===> NUEVO BLOQUE DE CÓDIGO PARA LA SOLUCIÓN <=== */
/* ================================================== */
/* En pantallas muy estrechas (móviles verticales), apilamos las acciones rápidas */
@media (max-width: 480px) {
  .action-group {
    display: flex;
    flex-direction: column;
    gap: 0.75rem; /* Un espacio más pequeño entre input y botón */
  }
  
  .action-group button {
    font-size: 1.1rem; /* Hacemos el texto del botón un poco más grande */
  }
}

</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SavedHandsView.vue ---

<template>
  <div class="saved-hands-container">
    <h2>Manos Guardadas</h2>

    <div class="filters-container">
      <div class="filter-group">
        <button v-if="selectedDate" @click="selectedDate = null" class="clear-btn">Mostrar Todas las Manos</button>
      </div>
      <div class="filter-group">
        <button @click="toggleHandStrengthSort" class="sort-btn">
          {{ sortKey === 'strength' ? 'Ordenar por Fecha' : 'Ordenar por Mano de Héroe' }}
        </button>
      </div>
    </div>

    <div v-if="isLoading" class="loading-message">
      Cargando manos...
    </div>
    <div v-else-if="selectedDate && filteredAndSortedHands.length === 0" class="no-hands">
      No se encontraron manos para la fecha seleccionada.
    </div>
    <div v-else-if="!selectedDate && groupedHands.length === 0" class="no-hands">
      No se encontraron manos.
    </div>
    <div v-else-if="selectedDate" class="hands-container">
      <ul class="hands-list">
        <li v-for="hand in filteredAndSortedHands" :key="hand.id">
          <div class="hand-info">
            <span><strong>Hora:</strong> {{ new Date(hand.fecha).toLocaleTimeString('es-ES') }}</span>
            <span><strong>Hero:</strong> {{ hand.posicion_heroe }}</span>
            <span><strong>Jugadores:</strong> {{ hand.cantidad_jugadores }}</span>
          </div>

          <div class="hand-preview">
            <div class="card-group hero-hand-preview">
              <span class="group-label">Hero</span>
              <div class="cards-display">
                <template v-if="getHeroFromHand(hand)?.cards">
                  <PlayingCard v-for="(card, index) in getHeroFromHand(hand).cards" :key="`hero-${card}-${index}`" :cardId="card" />
                </template>
              </div>
            </div>
            <div class="card-group">
              <span class="group-label">Board</span>
              <div class="cards-display">
                <template v-if="getBoardFromHand(hand).length > 0">
                  <PlayingCard v-for="(card, index) in getBoardFromHand(hand)" :key="`board-${card}-${index}`" :cardId="card" />
                </template>
              </div>
            </div>
          </div>

          <div class="hand-actions">
            <button @click="loadHandForReplay(hand)">Cargar Replay</button>
            <button class="delete-btn" @click="confirmDelete(hand.id)">Eliminar</button>
          </div>
        </li>
      </ul>
    </div>
    <div v-else class="grouped-hands-container">
      <div v-for="group in groupedHands" :key="group.date" class="date-group">
        <h3 @click="selectedDate = group.date" class="date-header">{{ new Date(group.date).toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }) }}</h3>
        <ul class="hands-list">
          <li v-for="hand in group.hands" :key="hand.id">
            <div class="hand-info">
              <span><strong>Hora:</strong> {{ new Date(hand.fecha).toLocaleTimeString('es-ES') }}</span>
              <span><strong>Hero:</strong> {{ hand.posicion_heroe }}</span>
              <span><strong>Jugadores:</strong> {{ hand.cantidad_jugadores }}</span>
            </div>

            <div class="hand-preview">
              <div class="card-group hero-hand-preview">
                <span class="group-label">Hero</span>
                <div class="cards-display">
                  <template v-if="getHeroFromHand(hand)?.cards">
                    <PlayingCard v-for="(card, index) in getHeroFromHand(hand).cards" :key="`hero-${card}-${index}`" :cardId="card" />
                  </template>
                </div>
              </div>
              <div class="card-group">
                <span class="group-label">Board</span>
                <div class="cards-display">
                  <template v-if="getBoardFromHand(hand).length > 0">
                    <PlayingCard v-for="(card, index) in getBoardFromHand(hand)" :key="`board-${card}-${index}`" :cardId="card" />
                  </template>
                </div>
              </div>
            </div>

            <div class="hand-actions">
              <button @click="loadHandForReplay(hand)">Cargar Replay</button>
              <button class="delete-btn" @click="confirmDelete(hand.id)">Eliminar</button>
            </div>
          </li>
        </ul>
      </div>
    </div>

    <div v-if="gameStore.hasMore && !selectedDate" class="load-more-container">
      <button @click="gameStore.loadMoreHands(selectedDate)">Cargar Más</button>
    </div>

    <div v-if="showModal" class="modal-overlay" @click="closeModal">
      <div class="modal-content" @click.stop>
        <h3>Confirmar Eliminación</h3>
        <p>¿Está seguro de que desea eliminar esta mano?</p>
        <div class="modal-actions">
          <button class="cancel-btn" @click="closeModal">No</button>
          <button class="confirm-btn" @click="deleteAndClose">Sí</button>
        </div>
      </div>
    </div>

    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Mano eliminada con éxito</div>
    </div>

    <!-- Overlay que pide girar el dispositivo (se muestra en móvil horizontal) -->
    <RotateDeviceOverlay v-if="showRotateOverlay" />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue';
import { useGameStore } from '../store/game'
import { useAuthStore } from '../store/useAuthStore'
import PlayingCard from '../components/PlayingCard.vue';
import RotateDeviceOverlay from '../components/RotateDeviceOverlay.vue';

const gameStore = useGameStore();
const authStore = useAuthStore();
const emit = defineEmits(['switch-view']);

const isLoading = computed(() => !authStore.isInitialized);

const selectedDate = ref(null);
const sortKey = ref('date');

const showModal = ref(false);
const showToast = ref(false);
const selectedHandId = ref(null);

const showRotateOverlay = ref(false);

const checkOrientation = () => {
  const isPortrait = window.matchMedia('(orientation: portrait)').matches;
  const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
  showRotateOverlay.value = !isPortrait && isCoarsePointer;
};

const HAND_STRENGTH_MAP = { 'AA': 1, 'KK': 2, 'QQ': 3, 'AKs': 4, 'JJ': 5, 'AQs': 6, 'KQs': 7, 'AJs': 8, 'KJs': 9, 'TT': 10, 'AKo': 11, 'ATs': 12, 'QJs': 13, 'KTs': 14, 'QTs': 15, 'JTs': 16, '99': 17, 'AQo': 18, 'A9s': 19, 'K9s': 20, 'Q9s': 21, 'J9s': 22, 'T9s': 23, 'A8s': 24, '88': 25, 'K8s': 26, 'Q8s': 27, 'J8s': 28, 'AJo': 29, 'A5s': 30, 'T8s': 31, '98s': 32, 'A7s': 33, 'A4s': 34, 'K7s': 35, '77': 36, 'A3s': 37, 'Q7s': 38, 'A6s': 39, 'KJo': 40, 'A2s': 41, 'K6s': 42, '87s': 43, 'T7s': 44, 'K5s': 45, '66': 46, 'ATo': 47, 'J7s': 48, 'Q6s': 49, 'K4s': 50, '97s': 51, '76s': 52, 'K3s': 53, 'Q5s': 54, '55': 55, 'K2s': 56, 'J6s': 57, 'T6s': 58, 'Q4s': 59, '86s': 60, 'Q3s': 61, '65s': 62, 'KTo': 63, 'A9o': 64, 'Q2s': 65, '44': 66, 'J5s': 67, '96s': 68, 'J4s': 69, '75s': 70, 'QJo': 71, 'A8o': 72, 'T5s': 73, 'J3s': 74, '54s': 75, '85s': 76, 'K9o': 77, 'Q9o': 78, '33': 79, 'J2s': 80, '64s': 81, 'T4s': 82, 'J9o': 83, 'T9o': 84, 'A7o': 85, 'K8o': 86, '95s': 87, '22': 88, '74s': 89, 'T3s': 90, '53s': 91, 'Q8o': 92, 'A5o': 93, '84s': 94, 'A4o': 95, 'K7o': 96, 'J8o': 97, 'T2s': 98, 'A6o': 99, '98o': 100, '43s': 101, 'A3o': 102, 'K6o': 103, '63s': 104, 'T8o': 105, 'A2o': 106, 'Q7o': 107, 'J7o': 108, 'K5o': 109, '87o': 110, '52s': 111, 'K4o': 112, 'T7o': 113, '76o': 114, 'Q6o': 115, '94s': 116, 'K3o': 117, 'J6o': 118, '83s': 119, 'K2o': 120, 'Q5o': 121, '97o': 122, '73s': 123, '42s': 124, 'T6o': 125, '65o': 126, 'Q4o': 127, 'J5o': 128, '86o': 129, 'Q3o': 130, 'J4o': 131, '96o': 132, '75o': 133, 'T5o': 134, 'Q2o': 135, '62s': 136, 'J3o': 137, '82s': 138, '54o': 139, '85o': 140, 'J2o': 141, '93s': 142, 'T4o': 143, '64o': 144, '95o': 145, '72s': 146, 'T3o': 147, '74o': 148, '53o': 149, '84o': 150, 'T2o': 151, '43o': 152, '92s': 153, '63o': 154, '83o': 155, '73o': 156, '52o': 157, '94o': 158, '42o': 159, '82o': 160, '62o': 161, '93o': 162, '72o': 163, '92o': 164, };
const RANK_ORDER = 'AKQJT98765432';

function getHandRank(cards) {
  if (!cards || cards.length < 2 || !cards[0] || !cards[1]) return 999;
  const rank1 = cards[0].charAt(0), suit1 = cards[0].charAt(1);
  const rank2 = cards[1].charAt(0), suit2 = cards[1].charAt(1);
  const isSuited = suit1 === suit2, isPair = rank1 === rank2;
  const [r1, r2] = [RANK_ORDER.indexOf(rank1), RANK_ORDER.indexOf(rank2)].sort((a,b) => a - b);
  const highRank = RANK_ORDER[r1], lowRank = RANK_ORDER[r2];
  let handKey;
  if (isPair) handKey = `${highRank}${lowRank}`;
  else if (isSuited) handKey = `${highRank}${lowRank}s`;
  else handKey = `${highRank}${lowRank}o`;
  return HAND_STRENGTH_MAP[handKey] || 999;
}

const groupedHands = computed(() => {
  const groups = {};
  gameStore.savedHands.forEach(hand => {
    const date = hand.fecha.split('T')[0];
    if (!groups[date]) groups[date] = [];
    groups[date].push(hand);
  });
  const sortedDates = Object.keys(groups).sort((a, b) => new Date(b) - new Date(a));
  return sortedDates.map(date => ({ date, hands: groups[date] }));
});

const filteredAndSortedHands = computed(() => {
  let hands = [...gameStore.savedHands];
  if (selectedDate.value) {
    hands = hands.filter(hand => hand.fecha.split('T')[0] === selectedDate.value);
  }
  if (sortKey.value === 'strength') {
    hands.sort((a, b) => getHandRank(getHeroFromHand(a)?.cards) - getHandRank(getHeroFromHand(b)?.cards));
  } else {
    hands.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
  }
  return hands;
});

function toggleHandStrengthSort() { sortKey.value = sortKey.value === 'strength' ? 'date' : 'strength'; }
function loadHandForReplay(hand) { gameStore.loadHand(hand); emit('switch-view', 'CurrentHandView'); }
function getHeroFromHand(hand) { if (!hand.historial || hand.historial.length === 0) return null; const finalState = hand.historial[hand.historial.length - 1]; return finalState.players.find(p => p.name === 'Hero'); }
function getBoardFromHand(hand) { if (!hand.historial || hand.historial.length === 0) return []; const finalState = hand.historial[hand.historial.length - 1]; return finalState.board.filter(card => card); }
function confirmDelete(handId) { selectedHandId.value = handId; showModal.value = true; }
function closeModal() { showModal.value = false; selectedHandId.value = null; }
async function deleteAndClose() {
  if (selectedHandId.value) {
    await gameStore.deleteHand(selectedHandId.value);
    showToast.value = true;
    setTimeout(() => { showToast.value = false; }, 3000);
    closeModal();
  }
}

onMounted(() => {
  window.addEventListener('resize', checkOrientation);
  checkOrientation();
});

onUnmounted(() => {
  window.removeEventListener('resize', checkOrientation);
});
</script>

<style scoped>
.saved-hands-container {
  padding: 1rem;
  max-width: 1200px;
  margin: 0 auto;
}
.loading-message, .no-hands {
  margin-top: 2rem;
  text-align: center;
  color: #a0aec0;
  font-size: 1.2rem;
}
.hands-list {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.hands-list li {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1.5rem;
  flex-wrap: wrap;
}
.filters-container {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1.5rem;
  margin-bottom: 2rem;
}
.filter-group {
  display: flex;
  align-items: center;
  gap: 10px;
}
.filter-group label {
  font-weight: bold;
  color: #a0aec0;
}
.filter-group input[type="date"] {
  padding: 8px;
  border-radius: 4px;
}
.sort-btn, .clear-btn {
  font-size: 1rem;
  padding: 8px 16px;
}
.clear-btn {
  background-color: #718096;
}
.date-header {
  cursor: pointer;
  color: #a0aec0;
  font-size: 1.2rem;
  margin-bottom: 1rem;
  padding: 0.5rem;
  border-bottom: 1px solid #4A5568;
}
.date-header:hover {
  color: #e2e8f0;
}
.grouped-hands-container {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}
.date-group {
  border: 1px solid #4A5568;
  border-radius: 8px;
  padding: 1rem;
}
.hand-info {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.5rem;
  flex-basis: 200px;
  flex-shrink: 0;
}
.hand-actions {
  display: flex;
  gap: 0.5rem;
}
.hand-preview {
  display: flex;
  flex-grow: 1;
  flex-direction: column;
  align-items: flex-start;
  gap: 1rem;
}
.card-group {
  display: flex;
  align-items: center;
  gap: 10px;
}
.group-label {
  font-weight: bold;
  font-size: 1.1rem;
  color: #a0aec0;
}
.cards-display {
  display: flex;
  gap: 5px;
}
.cards-display :deep(.playing-card) {
  width: 45px;
  height: 63px;
  border-radius: 4px;
}
.cards-display :deep(.rank) {
  font-size: 1.5rem;
}
.cards-display :deep(.suit-icon) {
  font-size: 1rem;
}
.delete-btn {
  background-color: #c53030;
}
.delete-btn:hover {
  background-color: #9b2c2c;
}
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}
.modal-content {
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
  text-align: center;
  border: 1px solid var(--border-color);
}
.modal-content h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  color: white;
}
.modal-content p {
  margin: 0 0 2rem 0;
  color: #a0aec0;
  font-size: 1.1rem;
}
.modal-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}
.cancel-btn, .confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}
.cancel-btn {
  background-color: #4A5568;
  color: white;
}
.cancel-btn:hover {
  background-color: #2D3748;
}
.confirm-btn {
  background-color: #c53030;
  color: white;
}
.confirm-btn:hover {
  background-color: #9b2c2c;
}
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}
.success-toast {
  background-color: #38a169;
  color: white;
}
.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}
.toast-message {
  font-size: 1rem;
  font-weight: bold;
}
@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
.hero-hand-preview {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #68d391;
  animation: hero-glow-list 2s infinite ease-in-out;
}
.load-more-container {
  text-align: center;
  margin-top: 2rem;
}
.load-more-container button {
  padding: 10px 20px;
  background-color: #4A5568;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}
.load-more-container button:hover {
  background-color: #2D3748;
}
@keyframes hero-glow-list {
  0%, 100% {
    background-color: rgba(104, 211, 145, 0.05);
    box-shadow: 0 0 5px rgba(104, 211, 145, 0.5);
  }
  50% {
    background-color: rgba(104, 211, 145, 0.15);
    box-shadow: 0 0 12px rgba(104, 211, 145, 0.8);
  }
}

@media (max-width: 768px) {
  .hands-list li {
    flex-direction: column;
    align-items: stretch;
    gap: 1rem;
  }
  .hand-info {
    flex-direction: row;
    justify-content: space-between;
    flex-basis: auto;
    width: 100%;
    font-size: 0.9rem;
  }
  .hand-preview {
    justify-content: space-around;
    width: 100%;
  }
  .hand-actions {
    width: 100%;
    display: grid;
    grid-template-columns: 1fr 1fr;
  }
}
</style>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SavedSessionsView.vue ---

<template>
  <div class="saved-sessions-container">
    <h2>Sesiones Guardadas</h2>

    <div class="filters-container">
      <label for="date-range-filter">Mostrar Sesiones de:</label>
      <select id="date-range-filter" v-model="selectedFilter">
        <option value="all">Todo</option>
        <option value="today">Hoy</option>
        <option value="last7days">Última semana</option>
        <option value="last1month">Último mes</option>
        <option value="last3months">Últimos 3 meses</option>
        <option value="last6months">Últimos 6 meses</option>
        <option value="last1year">Último año</option>
      </select>
    </div>

    <!-- ESTADO DE CARGA -->
    <div v-if="isLoading" class="loading-message">
      Cargando sesiones...
    </div>
    
    <!-- MENSAJE Y LISTA AHORA USAN LA PROPIEDAD COMPUTADA 'filteredSessions' -->
    <div v-else-if="filteredSessions.length === 0" class="no-sessions">
      No tienes sesiones guardadas que coincidan con el filtro seleccionado.
    </div>
    <ul v-else class="sessions-list">
      <li v-for="session in filteredSessions" :key="session.id">
        
        <div class="session-header">
          <span class="location">{{ session.ubicacion || 'Partida Privada' }}</span>
          <!-- Formateamos la fecha que viene de la base de datos -->
          <span class="date">{{ new Date(session.fecha + 'T12:00:00').toLocaleDateString() }}</span>
        </div>
        
        <div class="session-result" :class="getResultClass(session.resultado)">
          <span>Resultado</span>
          <span class="result-amount">
            {{ formatResult(session.resultado, session.moneda) }}
          </span>
        </div>

        <div class="session-details">
          <div class="session-stats">
            <div class="stat-item"><strong>Duración:</strong> <span>{{ formatDuration(session.duracion_segundos) }}</span></div>
            <div class="stat-item"><strong>Descansos:</strong> <span>{{ formatDuration(session.tiempo_descanso_segundos) }}</span></div>
            <div class="stat-item"><strong>Ciegas:</strong> <span>{{ session.ciegas }}</span></div>
            <div class="stat-item"><strong>Jugadores:</strong> <span>{{ session.cantidad_jugadores }}</span></div>
            <div class="stat-item"><strong>Buy-in:</strong> <span>{{ session.moneda }}{{ session.stack_inicial }}</span></div>
            <div class="stat-item"><strong>Recargas:</strong> <span>{{ session.moneda }}{{ session.total_recompras || 0 }}</span></div>
            <div class="stat-item"><strong>Gastos:</strong> <span>-{{ session.moneda }}{{ session.total_gastos || 0 }}</span></div>
            <div class="stat-item"><strong>Stack Final:</strong> <span>{{ session.moneda }}{{ session.stack_final !== undefined ? session.stack_final : 'N/A' }}</span></div>
          </div>
        </div>

        <div class="session-actions">
           <button class="notes-btn" @click="openNotesModal(session.id)" title="Añadir Notas">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
               <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
             </svg>
           </button>
           <button class="delete-btn" @click="confirmDelete(session.id)">Eliminar Sesión</button>
         </div>
      </li>
    </ul>

    <!-- Confirmation Modal -->
     <div v-if="showModal" class="modal-overlay" @click="closeModal">
       <div class="modal-content" @click.stop>
         <h3>Confirmar Eliminación</h3>
         <p>¿Estás seguro de que deseas eliminar esta sesión?</p>
         <div class="modal-actions">
           <button class="cancel-btn" @click="closeModal">No</button>
           <button class="confirm-btn" @click="deleteAndClose">Sí</button>
         </div>
       </div>
     </div>

     <!-- Notes Modal -->
     <div v-if="showNotesModal" class="modal-overlay" @click="closeNotesModal">
       <div class="modal-content notes-modal" @click.stop>
         <h3>Notas de la Sesión</h3>
         <textarea v-model="sessionNotes" placeholder="Escribe tus notas sobre esta sesión..." rows="6"></textarea>
         <div class="modal-actions">
           <button class="cancel-btn" @click="closeNotesModal">Cancelar</button>
           <button class="confirm-btn" @click="saveNotes">Guardar</button>
         </div>
       </div>
     </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Sesión eliminada con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useSessionStore } from '../store/useSessionStore';

const sessionStore = useSessionStore();
const isLoading = ref(true);
const selectedFilter = ref('all');
const showModal = ref(false);
const showToast = ref(false);
const selectedSessionId = ref(null);

const showNotesModal = ref(false);
const sessionNotes = ref('');
const notesSessionId = ref(null);

// Cargar sesiones al montar el componente
onMounted(async () => {
  isLoading.value = true;
  await sessionStore.fetchSessions();
  isLoading.value = false;
});

const filteredSessions = computed(() => {
  const filter = selectedFilter.value;
  const allSessions = sessionStore.savedSessions;

  if (filter === 'all') {
    return allSessions;
  }

  const now = new Date();
  const cutoffDate = new Date();

  switch (filter) {
    case 'today':
      cutoffDate.setHours(0, 0, 0, 0);
      break;
    case 'last7days':
      cutoffDate.setDate(now.getDate() - 7);
      break;
    case 'last1month':
      cutoffDate.setMonth(now.getMonth() - 1);
      break;
    case 'last3months':
      cutoffDate.setMonth(now.getMonth() - 3);
      break;
    case 'last6months':
      cutoffDate.setMonth(now.getMonth() - 6);
      break;
    case 'last1year':
      cutoffDate.setFullYear(now.getFullYear() - 1);
      break;
  }

  return allSessions.filter(session => {
    // La fecha de la DB (YYYY-MM-DD) se convierte a objeto Date para comparar
    const sessionDate = new Date(session.fecha);
    return sessionDate >= cutoffDate;
  });
});

function formatDuration(totalSeconds) {
  if (!totalSeconds) return '0m';
  if (totalSeconds < 60) return `${totalSeconds}s`;
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  let result = '';
  if (hours > 0) result += `${hours}h `;
  if (minutes > 0) result += `${minutes}m`;
  return result.trim();
}

function getResultClass(result) {
  const numResult = parseFloat(result);
  if (isNaN(numResult)) return 'even';
  if (numResult > 0) return 'profit';
  if (numResult < 0) return 'loss';
  return 'even';
}

function formatResult(result, currency) {
  const numResult = parseFloat(result);
  if (isNaN(numResult)) {
    return 'N/A';
  }
  const prefix = numResult >= 0 ? '+' : '';
  return `${prefix}${currency}${numResult.toFixed(2)}`;
}

function confirmDelete(sessionId) {
  selectedSessionId.value = sessionId;
  showModal.value = true;
}

function closeModal() {
  showModal.value = false;
  selectedSessionId.value = null;
}

async function deleteAndClose() {
  if (selectedSessionId.value) {
    await sessionStore.deleteSession(selectedSessionId.value);
    showToast.value = true;
    setTimeout(() => {
      showToast.value = false;
    }, 3000);
    closeModal();
  }
}

function openNotesModal(sessionId) {
  notesSessionId.value = sessionId;
  sessionNotes.value = localStorage.getItem(`sessionNotes_${sessionId}`) || '';
  showNotesModal.value = true;
}

function closeNotesModal() {
  showNotesModal.value = false;
  sessionNotes.value = '';
  notesSessionId.value = null;
}

function saveNotes() {
  if (notesSessionId.value) {
    localStorage.setItem(`sessionNotes_${notesSessionId.value}`, sessionNotes.value);
    closeNotesModal();
  }
}
</script>

<style scoped>
.saved-sessions-container {
  padding: 1rem; /* Padding base para móvil */
  max-width: 700px;
  margin: 0 auto;
}
h2 {
  margin-bottom: 1.5rem;
  text-align: center;
}
.loading-message, .no-sessions {
  margin-top: 1rem;
  color: #a0aec0;
  font-size: 1.2rem;
  text-align: center;
}
.sessions-list {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}
.filters-container {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  margin-bottom: 2rem;
}
.filters-container label {
  font-weight: bold;
  font-size: 1.1rem;
  color: #a0aec0;
}
.filters-container select {
  padding: 10px 15px;
  font-size: 1.1rem;
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: white;
}
.sessions-list li {
  background-color: #2d3748;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}
.session-header {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  border-bottom: 1px solid #4a5568;
  padding-bottom: 1rem;
}
.location {
  font-size: 1.5rem;
  font-weight: 700;
}
.date {
  font-size: 1rem;
  color: #a0aec0;
  flex-shrink: 0;
  margin-left: 1rem;
}
.session-result {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 1.5rem;
  border-radius: 8px;
  text-align: center;
}
.session-result span:first-child {
  font-size: 1.1rem;
  opacity: .8;
  margin-bottom: .5rem;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.result-amount {
  font-size: 2.8rem;
  font-weight: 700;
}
.profit { background-color: rgba(47, 133, 90, .3); color: #68d391; }
.loss { background-color: rgba(197, 48, 48, .3); color: #fc8181; }
.even { background-color: rgba(74, 85, 104, .3); color: #a0aec0; }

.session-stats {
  display: grid;
  grid-template-columns: 1fr 1fr; /* 2 columnas por defecto */
  gap: 0.5rem 1.5rem;
}
.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 1.1rem; /* Tamaño de fuente base */
  padding: 0.5rem 0;
  border-bottom: 1px solid #3c485e;
}
.stat-item:last-child {
  border-bottom: none;
}
.stat-item strong {
  color: #a0aec0;
  margin-right: 1rem;
}
.stat-item span {
  font-weight: bold;
}
.session-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 1rem;
}
.notes-btn {
  background-color: #48bb78;
  padding: 12px;
  font-size: 1.1rem;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.notes-btn:hover { background-color: #38a169; }
.notes-btn svg {
  width: 20px;
  height: 20px;
}
.delete-btn {
  background-color: #c53030;
  padding: 12px 25px;
  font-size: 1.1rem;
}
.delete-btn:hover { background-color: #9b2c2c; }

/* (Resto del CSS para modales y toast sin cambios) */
.modal-overlay,.toast{position:fixed;z-index:1000}.modal-overlay{top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);display:flex;justify-content:center;align-items:center}.modal-content{background-color:#2d3748;border-radius:12px;padding:2rem;max-width:400px;width:90%;text-align:center;border:1px solid var(--border-color)}.modal-content h3{margin:0 0 1rem;font-size:1.5rem;color:#fff}.modal-content p{margin:0 0 2rem;color:#a0aec0;font-size:1.1rem}.modal-actions{display:flex;gap:1rem;justify-content:center}.cancel-btn,.confirm-btn{padding:10px 20px;border:none;border-radius:6px;font-size:1rem;cursor:pointer;transition:background-color .2s ease}.cancel-btn{background-color:#4A5568;color:#fff}.confirm-btn{background-color:#c53030;color:#fff}.notes-modal textarea{width:100%;padding:10px;border:1px solid var(--border-color);border-radius:6px;background-color:#1a202c;color:#fff;font-family:inherit;font-size:1rem;resize:vertical;margin-bottom:1rem}.notes-modal .confirm-btn{background-color:#48bb78}.toast{top:20px;right:20px;display:flex;align-items:center;gap:10px;padding:15px 20px;border-radius:8px;box-shadow:0 4px 15px rgba(0,0,0,.3);animation:slideIn .3s ease-out}.success-toast{background-color:#38a169;color:#fff}.toast-icon{font-size:1.5rem;font-weight:700}.toast-message{font-size:1rem;font-weight:700}@keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}

@media (max-width: 640px) {
  .saved-sessions-container {
    padding: 1rem 0.5rem;
  }
  .sessions-list li {
    padding: 1rem;
  }
  .location {
    font-size: 1.2rem;
  }
  .date {
    font-size: 0.8rem;
  }
  .result-amount {
    font-size: 2.2rem;
  }
  .session-stats {
    grid-template-columns: 1fr; /* Cambia a 1 columna */
    gap: 0.25rem;
  }
  .stat-item {
    font-size: 1rem; /* Reduce fuente en móvil */
    padding: 0.4rem 0;
  }
  .session-actions {
    flex-direction: column;
    gap: 0.5rem;
    align-items: stretch; /* Estira los elementos para que ocupen el ancho */
  }
  .session-actions button {
    width: 100%;
    justify-content: center;
  }
}
</style>

-----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SavedTripsView.vue ---

<template>
  <div class="saved-trips-container">
    <h2>Viajes Guardados</h2>

    <div v-if="isLoading" class="loading-message">
      Cargando viajes...
    </div>
    <div v-else-if="tripStore.savedTrips.length === 0" class="no-trips">
      No tienes viajes guardados todavía.
    </div>
    <ul v-else class="trips-list">
      <li v-for="trip in tripStore.savedTrips" :key="trip.id">
        <div class="trip-header">
          <div class="trip-info">
            <span class="trip-destination">{{ trip.ciudad || 'Viaje sin ciudad' }}, {{ trip.casino || 'Sin casino' }}</span>
            <span class="trip-date">Guardado el: {{ new Date(trip.fecha_creacion).toLocaleDateString() }}</span>
          </div>
          <div class="trip-actions">
            <button @click="loadTripForEditing(trip.id)">Cargar y Editar</button>
            <button class="delete-btn" @click="confirmDelete(trip.id)">Eliminar</button>
          </div>
        </div>

        <div class="trip-stats">
          <div class="stat-item">
            <label>Jugadores</label>
            <span class="value">{{ trip.players.length }}</span>
          </div>
          <div class="stat-item">
            <label>Horas Totales</label>
            <span class="value">{{ calculateTripHours(trip).toFixed(1) }} h</span>
          </div>
          <div class="stat-item">
            <label>Beneficio Total</label>
            <span class="value" :class="getResultClass(calculateTripProfit(trip))">
              {{ calculateTripProfit(trip).toFixed(2) }} {{ trip.moneda }}
            </span>
          </div>
          <div class="stat-item">
            <label>Media {{ trip.moneda }}/h</label>
            <span class="value" :class="getResultClass(calculateTripWinRate(trip))">
              {{ calculateTripWinRate(trip).toFixed(2) }}
            </span>
          </div>
        </div>
      </li>
    </ul>

    <!-- Confirmation Modal -->
    <div v-if="showModal" class="modal-overlay" @click="closeModal">
      <div class="modal-content" @click.stop>
        <h3>Confirmar Eliminación</h3>
        <p>¿Está seguro de que desea eliminar este viaje?</p>
        <div class="modal-actions">
          <button class="cancel-btn" @click="closeModal">No</button>
          <button class="confirm-btn" @click="deleteAndClose">Sí</button>
        </div>
      </div>
    </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Viaje eliminado con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onActivated } from 'vue';
import { useTripStore } from '../store/useTripStore';

const tripStore = useTripStore();
const emit = defineEmits(['switch-view']);

const isLoading = ref(true);
const showModal = ref(false);
const showToast = ref(false);
const selectedTripId = ref(null);

const loadTrips = async () => {
  isLoading.value = true;
  await tripStore.fetchTrips();
  isLoading.value = false;
};

onMounted(loadTrips);

// ========================================================================
// === BLOQUE DE CÓDIGO ADITIVO Y AISLADO PARA SOLUCIONAR EL BUG ==========
// ========================================================================
// El hook `onActivated` se ejecuta cada vez que el componente es mostrado
// al navegar internamente (cuando el componente ya estaba "montado").
// Esto asegura que los datos se recarguen siempre que el usuario
// vuelva a esta vista.
onActivated(loadTrips);
// ========================================================================
// ========================================================================

function loadTripForEditing(tripId) {
  tripStore.loadTrip(tripId);
  emit('switch-view', 'CommunityView');
}

function calculateTripProfit(trip) {
  if (!trip.dailyResults) return 0;
  return Object.values(trip.dailyResults).reduce((total, dayResults) => {
    const dayTotal = Object.values(dayResults).reduce((daySum, playerData) => daySum + (parseFloat(playerData.result) || 0), 0);
    return total + dayTotal;
  }, 0);
}

function calculateTripHours(trip) {
  if (!trip.dailyResults) return 0;
  return Object.values(trip.dailyResults).reduce((total, dayResults) => {
    const dayTotal = Object.values(dayResults).reduce((daySum, playerData) => daySum + (parseFloat(playerData.hours) || 0), 0);
    return total + dayTotal;
  }, 0);
}

function calculateTripWinRate(trip) {
  const totalProfit = calculateTripProfit(trip);
  const totalHours = calculateTripHours(trip);
  return totalHours === 0 ? 0 : totalProfit / totalHours;
}

function getResultClass(result) {
  if (result > 0) return 'profit';
  if (result < 0) return 'loss';
  return 'even';
}

function confirmDelete(tripId) {
  selectedTripId.value = tripId;
  showModal.value = true;
}

function closeModal() {
  showModal.value = false;
  selectedTripId.value = null;
}

async function deleteAndClose() {
  if (selectedTripId.value) {
    await tripStore.deleteTrip(selectedTripId.value);
    showToast.value = true;
    setTimeout(() => { showToast.value = false; }, 3000);
    closeModal();
  }
}
</script>

<style scoped>
.saved-trips-container {
  padding: 2rem;
  max-width: 900px;
  margin: 0 auto;
}
h2 {
  text-align: center;
  margin-bottom: 2rem;
}
.loading-message, .no-trips {
  margin-top: 1rem;
  color: #a0aec0;
  text-align: center;
  font-size: 1.2rem;
}
.trips-list {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}
.trips-list li {
  background-color: #2d3748;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.trip-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  flex-wrap: wrap;
  gap: 1rem;
}
.trip-info {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.5rem;
}
.trip-destination {
  font-size: 1.5rem;
  font-weight: bold;
}
.trip-date {
  font-size: 0.9rem;
  color: #a0aec0;
}
.trip-actions {
  display: flex;
  gap: 0.5rem;
  flex-shrink: 0;
}

.trip-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 1rem;
  background-color: #1a202c;
  padding: 1rem;
  border-radius: 8px;
}
.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0.5rem;
}
.stat-item label {
  font-size: 0.9rem;
  color: #a0aec0;
  margin-bottom: 0.25rem;
  font-weight: bold;
}
.stat-item .value {
  font-size: 1.5rem;
  font-weight: bold;
}

.delete-btn {
  background-color: #c53030;
}
.delete-btn:hover {
  background-color: #9b2c2c;
}
.profit { color: #68d391; }
.loss { color: #fc8181; }
.even { color: #e2e8f0; }

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
  text-align: center;
  border: 1px solid var(--border-color);
}

.modal-content h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  color: white;
}

.modal-content p {
  margin: 0 0 2rem 0;
  color: #a0aec0;
  font-size: 1.1rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.cancel-btn, .confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.cancel-btn {
  background-color: #4A5568;
  color: white;
}

.cancel-btn:hover {
  background-color: #2D3748;
}

.confirm-btn {
  background-color: #c53030;
  color: white;
}

.confirm-btn:hover {
  background-color: #9b2c2c;
}

/* Toast Styles */
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}

.success-toast {
  background-color: #38a169;
  color: white;
}

.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}

.toast-message {
  font-size: 1rem;
  font-weight: bold;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@media (max-width: 640px) {
  .saved-trips-container {
    padding: 1rem 0.5rem;
  }
  .trip-header {
    flex-direction: column;
    align-items: stretch;
    gap: 0.75rem;
  }
  .trip-actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
  }
  .trip-destination {
    font-size: 1.2rem;
  }
  .trip-stats {
    grid-template-columns: 1fr 1fr;
  }
  .stat-item .value {
    font-size: 1.2rem;
  }
}
</style>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SettingsView.vue ---

<template>
  <div class="settings-container">
    <div class="settings-panel">
      <h2>{{ $t('settings.title') }}</h2>
      <div class="setting-item">
        <label for="language-select">{{ $t('settings.language') }}</label>
        <select id="language-select" v-model="settingsStore.locale">
          <option value="es">Español</option>
          <option value="en">English</option>
          <!-- Aquí puedes añadir más idiomas cuando crees sus archivos .json -->
        </select>
      </div>

      <!-- AVISO DE COPYRIGHT AÑADIDO -->
      <div class="copyright-notice">
        © {{ new Date().getFullYear() }} Tracker de Poker en Vivo. Protegido con Copyright. Todos los derechos reservados.
      </div>

    </div>
  </div>
</template>

<script setup>
import { useSettingsStore } from '../store/useSettingsStore';
const settingsStore = useSettingsStore();
</script>

<style scoped>
.settings-container {
  display: flex;
  justify-content: center;
  padding: 3rem;
}
.settings-panel {
  width: 100%;
  max-width: 500px;
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
}
h2 {
  margin-top: 0;
  text-align: center;
}
.setting-item {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.setting-item label {
  font-weight: bold;
}
.setting-item select {
  padding: 12px;
  font-size: 1.1rem;
}

/* --- ESTILOS ADITIVOS PARA EL AVISO DE COPYRIGHT --- */
.copyright-notice {
  margin-top: 2rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border-color);
  text-align: center;
  font-size: 0.9rem;
  color: #a0aec0;
}
</style>

------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SummaryView.vue ---

<template>
  <div class="summary-container">
    <h2>{{ $t('summary.title') }}</h2>

    <div class="filters-container">
      <label for="summary-date-filter">Mostrar datos de:</label>
      <select 
        id="summary-date-filter"
        :value="sessionStore.summaryDateFilter" 
        @change="sessionStore.setSummaryDateFilter($event.target.value)"
      >
        <option value="all">Todo</option>
        <option value="last7days">Última semana</option>
        <option value="last1month">Último mes</option>
        <option value="last3months">Últimos 3 meses</option>
        <option value="last6months">Últimos 6 meses</option>
        <option value="last1year">Último año</option>
      </select>
    </div>

    <div v-if="isLoading" class="loading-message">
      Cargando datos del sumario...
    </div>
    <div v-else-if="sessionStore.sessionCount === 0" class="no-data-message">
      No hay sesiones guardadas para el período seleccionado.
    </div>
    <template v-else>
      <div class="stats-grid">
        <div class="stat-card">
          <span class="stat-title">{{ $t('summary.totalProfit') }}</span>
          <span class="stat-value" :class="getResultClass(sessionStore.totalNetProfit)">{{ formatCurrency(sessionStore.totalNetProfit) }}</span>
        </div>
        <div class="stat-card">
          <span class="stat-title">ROI</span>
          <span class="stat-value" :class="getResultClass(sessionStore.roi)">{{ sessionStore.roi.toFixed(2) }}%</span>
        </div>
        <div class="stat-card">
          <span class="stat-title">{{ $t('summary.avgBuyIn') }}</span>
          <span class="stat-value">{{ formatCurrency(sessionStore.averageBuyIn, false) }}</span>
        </div>
        <div class="stat-card">
          <span class="stat-title">{{ $t('summary.avgCashOut') }}</span>
          <span class="stat-value">{{ formatCurrency(sessionStore.averageCashOut, false) }}</span>
        </div>
      </div>
      
      <div class="detailed-summary-panel">
        <h3>{{ $t('summary.sessionsTitle') }}</h3>
        <div class="detailed-stats-grid">
          <div class="detail-item">
            <span>{{ $t('summary.sessionCount') }}</span>
            <span>{{ sessionStore.sessionCount }}</span>
          </div>
           <div class="detail-item">
            <span>Manos guardadas</span>
            <span>{{ gameStore.savedHands.length }}</span>
          </div>
          <div class="detail-item">
            <span>Días ganadores</span>
            <span class="profit-text">{{ sessionStore.winningDays }}</span>
          </div>
           <div class="detail-item">
            <span>Días perdedores</span>
            <span class="loss-text">{{ sessionStore.losingDays }}</span>
          </div>
          <div class="detail-item">
            <span>Mejor día</span>
            <span class="profit-text">{{ formatCurrency(sessionStore.bestDay) }}</span>
          </div>
           <div class="detail-item">
            <span>Peor día</span>
            <span class="loss-text">{{ formatCurrency(sessionStore.worstDay) }}</span>
          </div>
           <div class="detail-item">
            <span>Racha ganadora</span>
            <span>{{ sessionStore.winningStreak }} días</span>
          </div>
          <div class="detail-item">
            <span>Ganancias/Hora</span>
            <span :class="getResultClass(sessionStore.winRatePerHour)">{{ formatCurrency(sessionStore.winRatePerHour) }}/h</span>
          </div>
           <div class="detail-item">
            <span>BB/100</span>
            <span :class="getResultClass(bbPer100)">{{ bbPer100.toFixed(2) }}</span>
          </div>
          <div class="detail-item">
            <span>Media de rebuys</span>
            <span>{{ formatCurrency(sessionStore.averageRebuys, false) }}</span>
          </div>
          <div class="detail-item">
            <span>Propinas y Consumiciones</span>
            <span>{{ formatCurrency(sessionStore.totalAllExpenses, false) }}</span>
          </div>
          <div class="detail-item">
            <span>{{ $t('summary.totalHours') }}</span>
            <span>{{ sessionStore.totalHoursPlayed.toFixed(2) }}h</span>
          </div>
          <div class="detail-item">
            <span>{{ $t('summary.avgHours') }}</span>
            <span>{{ sessionStore.averageHoursPlayed.toFixed(2) }}h</span>
          </div>
          <div class="detail-item">
            <span>{{ $t('summary.avgBreak') }}</span>
            <span>{{ sessionStore.averageBreakDuration.toFixed(0) }}min</span>
          </div>
        </div>
      </div>
    </template>
  </div>
</template>

<script setup>
import { computed, ref, onActivated } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import { useGameStore } from '../store/game';

const sessionStore = useSessionStore();
const gameStore = useGameStore();
const isLoading = ref(true);

onActivated(async () => {
    isLoading.value = true;
    await Promise.all([
        sessionStore.fetchSessions(),
        gameStore.fetchHands()
    ]);
    isLoading.value = false;
});

const bbPer100 = computed(() => {
  const totalHands = gameStore.savedHands.length;
  if (totalHands === 0) return 0;
  
  const totalProfit = sessionStore.totalNetProfit;
  
  const handsWithBlinds = gameStore.savedHands.filter(hand => hand.ciega_grande > 0);
  if (handsWithBlinds.length === 0) return 0;
  
  const totalBigBlindValue = handsWithBlinds.reduce((sum, hand) => sum + hand.ciega_grande, 0);
  const averageBigBlind = totalBigBlindValue / handsWithBlinds.length;

  if (averageBigBlind === 0) return 0;
  
  const profitInBB = totalProfit / averageBigBlind;
  const winRate = (profitInBB / totalHands) * 100;
  
  return winRate;
});

function formatCurrency(value, showSign = true) {
  if (typeof value !== 'number') return `${sessionStore.currency}0.00`;
  const prefix = value >= 0 ? '+' : '';
  if (showSign) {
     return `${prefix}${sessionStore.currency}${value.toFixed(2)}`;
  }
  return `${sessionStore.currency}${value.toFixed(2)}`;
}

function getResultClass(result) {
  if (typeof result !== 'number' || result === 0) return 'even-text';
  if (result > 0) return 'profit-text';
  if (result < 0) return 'loss-text';
  return 'even-text';
}
</script>

<style scoped>
.summary-container {
  padding: 1rem;
  max-width: 1200px;
  margin: 0 auto;
}
h2 {
  text-align: center;
  margin-bottom: 2rem;
  font-size: 2rem;
}
.filters-container {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  margin-bottom: 2rem;
}
.filters-container label {
  font-weight: bold;
  font-size: 1.1rem;
  color: #a0aec0;
}
.filters-container select {
  padding: 10px 15px;
  font-size: 1.1rem;
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: white;
}
.loading-message, .no-data-message {
  text-align: center;
  font-size: 1.2rem;
  color: #a0aec0;
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
}
.stats-grid {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.stat-card {
  background-color: #2d3748;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}
.stat-title {
  font-size: 1.1rem;
  color: #a0aec0;
  font-weight: bold;
  text-transform: uppercase;
}
.stat-value {
  font-size: 2.5rem;
  font-weight: bold;
}
.detailed-summary-panel {
  background-color: #2d3748;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  margin-top: 2rem;
}
.detailed-summary-panel h3 {
  margin: 0 0 1.5rem 0;
  font-size: 1.5rem;
  text-align: center;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 1rem;
}
.detailed-stats-grid {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}
.detail-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 1.1rem;
  padding: 0.75rem 0;
  border-bottom: 1px solid #3c485e;
}
.detail-item:last-child { border-bottom: none; }
.detail-item span:first-child { color: #a0aec0; }
.detail-item span:last-child { font-weight: bold; }
.profit-text { color: #68d391; }
.loss-text { color: #fc8181; }
.even-text { color: #e2e8f0; }
@media (min-width: 768px) {
  .summary-container { padding: 2rem; }
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }
  .detailed-stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem 2rem;
  }
  .detail-item { font-size: 1.2rem; }
}
@media (min-width: 1024px) {
  .stats-grid {
    grid-template-columns: repeat(4, 1fr);
  }
}
</style>

-----------------------------------------------------

--- INICIO DEL ARCHIVO: vite.config.js ---

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { VitePWA } from 'vite-plugin-pwa'
import path from 'path' // <-- PASO 1: AÑADIR ESTA LÍNEA
import { liveDesigner } from '@pinegrow/vite-plugin'

export default defineConfig({
  // --- PASO 2: AÑADIR ESTA SECCIÓN 'resolve' COMPLETA ---
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  // ----------------------------------------------------------
  plugins: [
    vue(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'masked-icon.svg'],
      manifest: {
        name: 'Poker Replayer Interactivo',
        short_name: 'Poker Replayer',
        description: 'Una herramienta para configurar, registrar y reproducir manos de poker para su estudio.',
        theme_color: '#1a202c',
        background_color: '#1a202c',
        start_url: '.',
        display: 'standalone',
        icons: [
          {
            src: 'icons/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: 'icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
        ],
      },
    }),
  ],
})

------------------------------------------

