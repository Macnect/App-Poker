=================================== RESUMEN DEL PROYECTO ===================================

--- INICIO DEL ARCHIVO: README.md ---

<<<<<<< HEAD
# Vue 3 + Vite

This template should help get you started developing with Vue 3 in Vite. The template uses Vue 3 `<script setup>` SFCs, check out the [script setup docs](https://v3.vuejs.org/api/sfc-script-setup.html#sfc-script-setup) to learn more.

Learn more about IDE Support for Vue in the [Vue Docs Scaling up Guide](https://vuejs.org/guide/scaling-up/tooling.html#ide-support).
=======
# App-Poker
poker
>>>>>>> 382eb947e0e9e79948d26fb03166f34db02ddb93


-------------------------------------

--- INICIO DEL ARCHIVO: index.html ---

<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1a202c" />
    <title>Poker Replayer Interactivo</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

--------------------------------------

--- INICIO DEL ARCHIVO: package.json ---

{
  "name": "poker-replayer",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@kurkle/color": "^0.4.0",
    "chart.js": "^4.5.0",
    "pinia": "^3.0.3",
    "uuid": "^13.0.0",
    "vite-plugin-pwa": "^1.0.3",
    "vue": "^3.5.21",
    "vue-chartjs": "^5.3.2",
    "vue-i18n": "^11.1.12"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^6.0.1",
    "sharp": "^0.34.4",
    "vite": "^7.1.6"
  }
}


----------------------------------------

--- INICIO DEL ARCHIVO: public/icons/all-in-icon.svg ---

<svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="triangleGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#ff4444;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#cc0000;stop-opacity:1" />
    </linearGradient>
  </defs>
  <polygon points="60,11 109,101 11,101" fill="url(#triangleGradient)" stroke="#000000" stroke-width="5" rx="6" ry="6" />
  <text x="60" y="71" text-anchor="middle" font-family="Arial Black, sans-serif" font-size="22" font-weight="bold" fill="#ffffff">All-in</text>
</svg>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: public/vite.svg ---

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

-------------------------------------------

--- INICIO DEL ARCHIVO: src/App.vue ---

<template>
  <div id="main-container">
    <nav>
      <button @click="currentView = 'CurrentHandView'" :class="{ active: currentView === 'CurrentHandView' }">
        {{ $t('nav.currentHand') }}
      </button>
      <button @click="currentView = 'SavedHandsView'" :class="{ active: currentView === 'SavedHandsView' }">
        {{ $t('nav.savedHands') }}
      </button>
      <button @click="currentView = 'LiveSessionView'" :class="{ active: currentView === 'LiveSessionView' }">
        {{ $t('nav.liveSession') }}
      </button>
      <button @click="currentView = 'SavedSessionsView'" :class="{ active: currentView === 'SavedSessionsView' }">
        {{ $t('nav.savedSessions') }}
      </button>
      <button @click="currentView = 'ChartsView'" :class="{ active: currentView === 'ChartsView' }">
        {{ $t('nav.charts') }}
      </button>
      <button @click="currentView = 'SummaryView'" :class="{ active: currentView === 'SummaryView' }">
        {{ $t('nav.summary') }}
      </button>
      <!-- BOTÓN COMUNIDAD MODIFICADO PARA RESETEAR -->
      <button @click="switchToView('CommunityView')" :class="{ active: currentView === 'CommunityView' }">
        Viajes
      </button>
      <!-- BOTÓN NUEVO PARA VIAJES GUARDADOS -->
      <button @click="currentView = 'SavedTripsView'" :class="{ active: currentView === 'SavedTripsView' }">
        Viajes Guardados
      </button>
      <button @click="currentView = 'SettingsView'" :class="{ active: currentView === 'SettingsView' }">
        {{ $t('nav.settings') }}
      </button>
    </nav>
    <main>
      <!-- EMISOR DE EVENTOS MODIFICADO -->
      <component :is="views[currentView]" @switch-view="switchToView" />
    </main>
  </div>
</template>

<script setup>
import { ref, shallowRef } from 'vue';
import { useTripStore } from './store/useTripStore'; // <-- 1. IMPORTAR EL TRIP STORE
import CurrentHandView from './views/CurrentHandView.vue';
import SavedHandsView from './views/SavedHandsView.vue';
import LiveSessionView from './views/LiveSessionView.vue';
import SavedSessionsView from './views/SavedSessionsView.vue';
import ChartsView from './views/ChartsView.vue';
import SettingsView from './views/SettingsView.vue';
import SummaryView from './views/SummaryView.vue';
import CommunityView from './views/CommunityView.vue';
import SavedTripsView from './views/SavedTripsView.vue'; // <-- 2. IMPORTAR LA NUEVA VISTA

const currentView = ref('CurrentHandView');
const tripStore = useTripStore(); // <-- 3. INICIALIZAR EL TRIP STORE

const views = shallowRef({
  CurrentHandView,
  SavedHandsView,
  LiveSessionView,
  SavedSessionsView,
  ChartsView,
  SettingsView,
  SummaryView,
  CommunityView,
  SavedTripsView, // <-- 4. REGISTRAR LA NUEVA VISTA
});

// --- 5. LÓGICA DE NAVEGACIÓN ACTUALIZADA ---
function switchToView(viewName) {
  // Caso especial para el replay de manos guardadas
  if (viewName === undefined || viewName === 'CurrentHandView') {
    currentView.value = 'CurrentHandView';
    return;
  }
  
  // Si hacemos clic en "Comunidad" desde cualquier otra vista que no sea "Viajes Guardados",
  // reseteamos el estado para empezar un viaje nuevo.
  if (viewName === 'CommunityView' && currentView.value !== 'SavedTripsView') {
      tripStore.resetCurrentTrip();
  }

  currentView.value = viewName;
}

// Mantenemos la función original por si algún componente la sigue usando sin argumentos
function switchToCurrentHandView() {
  currentView.value = 'CurrentHandView';
}
</script>

<style scoped>
#main-container {
  width: 100%;
}
nav {
  padding: 10px;
  background-color: #2d3748;
  border-bottom: 2px solid var(--border-color);
}
nav button {
  margin: 0 10px;
  background-color: transparent;
  border: 1px solid var(--primary-color);
}
nav button.active {
  background-color: var(--primary-color);
}
main {
  width: 100%;
}
</style>

---------------------------------------

--- INICIO DEL ARCHIVO: src/assets/vue.svg ---

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>

----------------------------------------------

--- INICIO DEL ARCHIVO: src/components/ActionPanel.vue ---

<template>
  <div class="action-panel-wrapper" style="position: fixed; top: 800px; left: 50%; transform: translateX(-50%);">
    
    <div class="actions-grid">
      <!-- Fila 1 -->
      <div class="grid-turn-info">{{ $t('actionPanel.turnOf') }} <strong>{{ gameStore.activePlayer?.name }}</strong></div>
      <button @click="gameStore.performAction('fold')" class="grid-fold btn-fold">{{ $t('actionPanel.fold') }}</button>
      <button @click="handleCheckCall" :disabled="isCallDisabled" class="grid-call btn-call">{{ checkOrCallLabel.toUpperCase() }}</button>
      
      <!-- Fila 2 -->
      <button @click="handleBetRaise" :disabled="isRaiseDisabled" class="grid-raise btn-raise">{{ betOrRaiseLabel.toUpperCase() }}</button>
      
      <!-- Input ahora usa 'displayRaiseAmount' para ser dinámico -->
      <input type="number" v-model="displayRaiseAmount" class="grid-input" />
      <div v-if="isAllIn" class="all-in-indicator">▲</div>
      
      <input 
        type="range" 
        :min="minRaiseValue" 
        :max="maxSliderValue"
        :step="gameStore.bigBlind"
        v-model.number="raiseAmount"
        class="grid-slider"
        @wheel="handleWheelScroll"
        :style="sliderStyle" 
      />

      <!-- Fila 3 -->
      <div class="grid-quick-bets">
        <button @click="setRaiseAmountByPot(0.25)">25%</button>
        <button @click="setRaiseAmountByPot(0.33)">33%</button>
        <button @click="setRaiseAmountByPot(0.50)">50%</button>
        <button @click="setRaiseAmountByPot(0.75)">75%</button>
        <button @click="setRaiseAmountByPot(1)">{{ $t('actionPanel.pot') }}</button>
        <button @click="setRaiseAmountByPot(1.5)">150%</button>
        <!-- BOTÓN ALL-IN MODIFICADO -->
        <button @click="setRaiseAmountToAllIn" class="btn-allin">{{ $t('actionPanel.allIn') }}</button>
      </div>

      <!-- Controles de la mesa -->
      <select class="grid-color-select" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)">
        <option value="#28563a">Verde</option>
        <option value="#3a4c8a">Azul</option>
        <option value="#8a3a3a">Rojo</option>
        <option value="#553c9a">Morado</option>
        <option value="#b7791f">Oro</option>
        <option value="#1A202C">Negro</option>
        <option value="#4A5568">Gris</option>
      </select>
      <button class="grid-bbs-toggle" @click="gameStore.toggleDisplayMode()">
        {{ gameStore.displayInBBs ? gameStore.currency : 'BBs' }}
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted, onUnmounted } from 'vue';
import { useI18n } from 'vue-i18n';
import { useGameStore } from '../store/game';

const { t } = useI18n();

const props = defineProps({ modelValue: String });
const emit = defineEmits(['update:modelValue']);
const gameStore = useGameStore();

// No drag functionality needed since it's fixed positioned

const amountToCall = computed(() => {
  if (!gameStore.activePlayer) return 0;
  return gameStore.currentBet - gameStore.activePlayer.betThisRound;
});

const checkOrCallLabel = computed(() => {
  if (amountToCall.value <= 0) return t('actionPanel.check');
  if (gameStore.displayInBBs) {
    const bbValue = (amountToCall.value / gameStore.bigBlind).toFixed(1);
    return `${t('actionPanel.call')} ${bbValue} BB`;
  }
  return `${t('actionPanel.call')} ${amountToCall.value}`;
});

const maxSliderValue = computed(() => {
    if (!gameStore.activePlayer) return 0;
    return gameStore.activePlayer.stack + gameStore.activePlayer.betThisRound;
});

const minRaiseValue = computed(() => {
  if (!gameStore.activePlayer) return 0;
  const raiseDifference = gameStore.currentBet - (gameStore.lastRaiseAmount || 0);
  const min = gameStore.currentBet + Math.max(raiseDifference, gameStore.bigBlind);
  return Math.min(min, maxSliderValue.value);
});

const raiseAmount = ref(minRaiseValue.value);
watch(minRaiseValue, (newVal) => {
    if(raiseAmount.value < newVal) {
        raiseAmount.value = newVal;
    }
});
watch(() => gameStore.activePlayerIndex, () => {
    raiseAmount.value = minRaiseValue.value;
});

const displayRaiseAmount = computed({
  get() {
    if (gameStore.displayInBBs) {
      return (raiseAmount.value / gameStore.bigBlind).toFixed(1);
    }
    return raiseAmount.value;
  },
  set(newValue) {
    if (gameStore.displayInBBs) {
      raiseAmount.value = Math.round(parseFloat(newValue) * gameStore.bigBlind);
    } else {
      raiseAmount.value = parseInt(newValue) || 0;
    }
  }
});

const sliderStyle = computed(() => {
  if (!gameStore.activePlayer) return {};
  const min = minRaiseValue.value;
  const max = maxSliderValue.value;
  const current = raiseAmount.value;
  if (max <= min) {
    return { '--slider-fill-percentage': '100%' };
  }
  const percentage = ((current - min) / (max - min)) * 100;
  return {
    '--slider-fill-percentage': `${percentage}%`
  };
});

const betOrRaiseLabel = computed(() => (gameStore.currentBet > 0 ? t('actionPanel.raise') : t('actionPanel.bet')));
const isCallDisabled = computed(() => !gameStore.activePlayer || amountToCall.value > gameStore.activePlayer.stack);
const isRaiseDisabled = computed(() => !gameStore.activePlayer || raiseAmount.value < minRaiseValue.value || raiseAmount.value > maxSliderValue.value);
const isAllIn = computed(() => gameStore.activePlayer && raiseAmount.value >= gameStore.activePlayer.stack);

function handleCheckCall() {
  const action = amountToCall.value > 0 ? 'call' : 'check';
  gameStore.performAction(action);
}
function handleBetRaise() {
  const action = gameStore.currentBet > 0 ? 'raise' : 'bet';
  gameStore.performAction(action, raiseAmount.value);
}

function setRaiseAmountByPot(multiplier) {
  if (!gameStore.activePlayer) return;
  
  let betValue = Math.round(gameStore.totalPot * multiplier);
  betValue = Math.max(minRaiseValue.value, betValue);
  betValue = Math.min(maxSliderValue.value, betValue);

  raiseAmount.value = betValue;
}

// --- NUEVA FUNCIÓN PARA EL BOTÓN ALL-IN ---
function setRaiseAmountToAllIn() {
  if (!gameStore.activePlayer) return;
  // Simplemente establece el raiseAmount al valor máximo posible (el stack del jugador)
  raiseAmount.value = maxSliderValue.value;
}


function handleWheelScroll(event) {
  event.preventDefault();
  const step = gameStore.bigBlind;
  let newValue;
  if (event.deltaY < 0) {
    newValue = raiseAmount.value + step;
  } else {
    newValue = raiseAmount.value - step;
  }
  newValue = Math.max(minRaiseValue.value, newValue);
  newValue = Math.min(maxSliderValue.value, newValue);
  raiseAmount.value = newValue;
}
</script>

<style scoped>
/* El CSS es idéntico al que me pasaste */
.action-panel-wrapper {
  --btn-red: #f95f41;
  --btn-red-hover: #e04a2f;
  --btn-green: #70b75b;
  --btn-green-hover: #59b33f;
  --btn-orange: #e39e49;
  --btn-orange-hover: #de8f32;
  --btn-purple: #a955cd;
  --btn-purple-hover: #9c51bb;
  --btn-grey: #4A5568;
  --btn-grey-hover: #2D3748;
  --slider-color-active: #FAB76B;
  --slider-color-inactive: #1A202C;
  background-color: #2d3748;
  border-radius: 12px;
  padding: 20px;
  width: 900px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  border: 3px solid var(--border-color);
  color: white;
}
.actions-grid {
  display: grid;
  grid-template-columns: 180px 120px 1fr 120px 120px;
  grid-template-rows: auto auto auto;
  gap: 15px;
  align-items: center;
  grid-template-areas:
    "fold       call       turn-info  color-select bbs-toggle"
    "raise      input      slider     slider       slider"
    "quick-bets quick-bets quick-bets quick-bets   quick-bets";
}
.grid-turn-info { grid-area: turn-info; text-align: center; font-size: 1.4rem; }
.grid-fold { grid-area: fold; }
.grid-call { grid-area: call; }
.grid-raise { grid-area: raise; }
.grid-input { grid-area: input; }
.grid-slider { grid-area: slider; margin-right: 20px; }
.grid-quick-bets { grid-area: quick-bets; }
.grid-color-select { grid-area: color-select; }
.grid-bbs-toggle { grid-area: bbs-toggle; }
.grid-fold, .grid-call, .grid-raise {
  height: 65px;
  font-size: 1.3rem;
  font-weight: bold;
  border: 1px solid #000;
  border-radius: 8px;
  color: white;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  line-height: 1.2;
  padding: 2px;
}
.grid-input {
  height: 65px;
  border-radius: 8px;
  border: 1px solid #000;
  background-color: #1A202C;
  color: white;
  font-size: 2rem;
  text-align: center;
  width: 84%;
  position: relative;
}
.all-in-indicator {
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  color: #f95f41;
  font-size: 1.5rem;
  font-weight: bold;
}
.grid-quick-bets {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}
.grid-quick-bets button {
  flex-grow: 1;
  padding: 12px;
  font-size: 1rem;
  border: 1px solid #000;
  border-radius: 6px;
  background-color: var(--btn-grey);
  color: white;
  cursor: pointer;
}
.grid-quick-bets button:hover {
  background-color: var(--btn-grey-hover);
}
.grid-color-select, .grid-bbs-toggle {
  height: 65px;
  padding: 0 15px;
  font-size: 1.2rem;
  font-weight: bold;
  border: 1px solid #000;
  border-radius: 8px;
  background-color: #718096;
  color: white;
  cursor: pointer;
}
.btn-fold { background-color: var(--btn-red); }
.btn-fold:hover { background-color: var(--btn-red-hover); }
.btn-call { background-color: var(--btn-green); }
.btn-call:hover { background-color: var(--btn-green-hover); }
.btn-raise { background-color: var(--btn-orange); }
.btn-raise:hover { background-color: var(--btn-orange-hover); }
.btn-allin { background-color: var(--btn-purple) !important; }
.btn-allin:hover { background-color: var(--btn-purple-hover) !important; }
button:disabled {
  background-color: #718096 !important;
  cursor: not-allowed;
  opacity: 0.6;
}
.grid-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 98%;
  height: 16px;
  background: transparent;
  outline: none;
  border-radius: 8px;
}
.grid-slider::-webkit-slider-runnable-track {
  width: 100%;
  height: 16px;
  cursor: pointer;
  border-radius: 8px;
  border: 1px solid #000;
  background: linear-gradient(to right, 
    var(--slider-color-active) var(--slider-fill-percentage), 
    var(--slider-color-inactive) var(--slider-fill-percentage)
  );
}
.grid-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  border: 1px solid #000;
  height: 30px;
  width: 20px;
  border-radius: 4px;
  background: #E2E8F0;
  cursor: pointer;
  margin-top: -8px;
}
.grid-slider::-moz-range-track {
  width: 100%;
  height: 16px;
  cursor: pointer;
  border-radius: 8px;
  border: 1px solid #000;
  background: linear-gradient(to right, 
    var(--slider-color-active) var(--slider-fill-percentage), 
    var(--slider-color-inactive) var(--slider-fill-percentage)
  );
}
.grid-slider::-moz-range-thumb {
  border: 1px solid #000;
  height: 30px;
  width: 20px;
  border-radius: 4px;
  background: #E2E8F0;
  cursor: pointer;
}
</style>

----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/CardPicker.vue ---

<template>
  <div class="modal-overlay" @click.self="gameStore.closeCardPicker()">
    <div class="card-picker-content">
      <div v-for="suit in deck" :key="suit.name" class="suit-row">
        <div
          v-for="card in suit.cards"
          :key="card.id"
          class="card"
          :class="[suit.colorClass, { disabled: gameStore.usedCards.has(card.id) }]"
          @click="selectCard(card)"
        >
          {{ card.rank }}
          <span class="suit-icon" v-html="suit.icon"></span>
        </div>
      </div>
      <button class="close-btn" @click="gameStore.closeCardPicker()">Cerrar</button>
    </div>
  </div>
</template>

<script setup>
import { useGameStore } from '../store/game';

const gameStore = useGameStore();

const ranks = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];
const suits = [
  { name: 'Spades', id: 'S', icon: '&spades;', colorClass: 'black' },
  { name: 'Hearts', id: 'H', icon: '&hearts;', colorClass: 'red' },
  { name: 'Clubs', id: 'C', icon: '&clubs;', colorClass: 'green' },
  { name: 'Diamonds', id: 'D', icon: '&diams;', colorClass: 'blue' },
];

const deck = suits.map(suit => ({
  ...suit,
  cards: ranks.map(rank => ({
    id: rank + suit.id,
    rank: rank,
  }))
}));

function selectCard(card) {
  if (gameStore.usedCards.has(card.id)) return;
  gameStore.assignCard(card.id);
}
</script>

<style scoped>
.modal-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex; justify-content: center; align-items: center; z-index: 2000;
}
.card-picker-content {
  background-color: #1a202c;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.suit-row {
  display: flex;
  gap: 0.5rem;
}
.card {
  width: 50px; height: 70px;
  border: 1px solid #4A5568;
  border-radius: 6px;
  display: flex; flex-direction: column;
  justify-content: center; align-items: center;
  font-family: 'Arial Black', sans-serif; font-size: 1.8rem; font-weight: bold;
  cursor: pointer;
  color: white;
  user-select: none;
  transition: transform 0.1s, box-shadow 0.1s;
}
.card:hover {
  transform: scale(1.05);
  box-shadow: 0 0 15px #f6e05e;
}
.suit-icon {
  font-size: 1.2rem;
  line-height: 1;
}
/* 4-Color Deck */
.card.black { background-color: #2d3748; }
.card.red { background-color: #c53030; }
.card.green { background-color: #2f855a; }
.card.blue { background-color: #2b6cb0; }

.card.disabled {
  background-color: #4a5568;
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}
.card.disabled:hover {
  transform: none;
  box-shadow: none;
}
.close-btn {
  margin-top: 1rem;
  padding: 10px;
  font-size: 1rem;
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/ChipStack.vue ---

<template>
  <div class="chip-stack-container">
    <div v-if="stackDetails.count > 0" class="chip-stack">
      <div
        v-for="i in stackDetails.count"
        :key="i"
        class="chip"
        :style="{
          backgroundColor: stackDetails.color,
          bottom: (i - 1) * 3 + 'px', // Reducimos el espaciado para un stack más compacto
          zIndex: stackDetails.count - i,
          '--chip-color': stackDetails.color, // Pasamos el color como variable CSS
        }"
      ></div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  amount: {
    type: Number,
    required: true,
  },
  bigBlind: {
    type: Number,
    required: true,
  },
});

const chipDenominations = [
  { value: 1000, color: '#D6A2E8' },
  { value: 500, color: '#82589F' },
  { value: 100, color: '#1A202C' },
  { value: 25, color: '#2F855A' },
  { value: 5, color: '#C53030' },
  { value: 1, color: '#E2E8F0' },
];

const stackDetails = computed(() => {
  if (props.amount <= 0) {
    return { color: 'transparent', count: 0 };
  }

  const primaryChip = chipDenominations.find(chip => props.amount >= chip.value) || chipDenominations[chipDenominations.length - 1];
  const betInBBs = props.amount / props.bigBlind;

  // --- LÓGICA DE CANTIDAD DE FICHAS AJUSTADA ---
  let count;
  if (betInBBs <= 1) {       // Apuestas mínimas (ciegas, limps)
    count = 2;
  } else if (betInBBs <= 5) { // Apuestas de continuación pequeñas
    count = 4;
  } else if (betInBBs <= 15) { // Subidas estándar, 3-bets
    count = 6;
  } else if (betInBBs <= 40) { // Apuestas grandes en el turn/river
    count = 8;
  } else if (betInBBs <= 100) { // Botes muy grandes
    count = 10;
  } else {                   // All-ins enormes
    count = 12; // Máximo de 12 fichas para mantenerlo visualmente limpio
  }

  return {
    color: primaryChip.color,
    count: count,
  };
});
</script>

<style scoped>
/* --- ESTILOS 3D COMPLETAMENTE NUEVOS --- */
.chip-stack-container {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  height: 60px;
  width: 45px;
  /* La perspectiva es clave para el efecto 3D */
  perspective: 500px;
}

.chip-stack {
  position: relative;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
}

.chip {
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  box-sizing: border-box;
  left: 5.5px; /* Centrado en el contenedor de 45px */
  
  /* --- EFECTO 3D Y REALISMO --- */

  /* 1. Inclinación para dar perspectiva */
  transform: rotateX(70deg); 
  
  /* 2. Sombra proyectada por la ficha */
  box-shadow: 0 10px 8px rgba(0, 0, 0, 0.4);

  /* 3. Grosor y color del borde de la ficha */
  border-bottom: 5px solid color-mix(in srgb, var(--chip-color) 70%, black);

  /* 4. Reflejo de luz en la parte superior para dar volumen */
  background-image: radial-gradient(
    circle at 50% 10%, 
    rgba(255, 255, 255, 0.6), 
    transparent 70%
  );
}

/* Detalle de las franjas en la cara de la ficha */
.chip::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 85%;
  height: 85%;
  border-radius: 50%;
  /* Usamos un borde discontinuo para un look clásico */
  border: 2px dashed color-mix(in srgb, var(--chip-color) 60%, white);
  opacity: 0.8;
}
</style>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/ConfigurationModal.vue ---

<template>
  <div class="modal-overlay">
    <div class="modal-content">
      <h3>Selecciona tu Posición (Hero)</h3>
      <div class="positions-grid">
        <button
          v-for="pos in positions"
          :key="pos"
          @click="selectedPosition = pos"
          :class="{ selected: selectedPosition === pos }"
        >
          {{ pos }}
        </button>
      </div>
      <button class="confirm-btn" @click="$emit('confirm', selectedPosition)" :disabled="!selectedPosition">
        Confirmar e Iniciar Mano
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';

defineProps({
  positions: Array,
});
defineEmits(['confirm']);

const selectedPosition = ref(null);
</script>

<style scoped>
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}
.modal-content {
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  width: 90%;
  max-width: 500px;
  text-align: center;
}
h3 {
  margin-top: 0;
  font-size: 1.5rem;
}
.positions-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
  gap: 10px;
  margin: 2rem 0;
}
.positions-grid button {
  padding: 15px;
  font-size: 1rem;
  font-weight: bold;
  background-color: var(--btn-grey, #4A5568);
  border: 2px solid transparent;
}
.positions-grid button.selected {
  background-color: var(--primary-color);
  border-color: #f6e05e;
}
.confirm-btn {
  width: 100%;
  padding: 15px;
  font-size: 1.2rem;
  font-weight: bold;
}
</style>

-----------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/DisplayOptions.vue ---

<template>
  <div class="display-options-wrapper" ref="panelRef" @mousedown="startDrag" :style="{ position: 'absolute', left: panelPosition.x + 'px', top: panelPosition.y + 'px', cursor: isDraggable ? (isDragging ? 'grabbing' : 'grab') : 'default' }">
    <h3>Opciones mesa</h3>
    <div class="options-row">
      <select class="option-item" :value="modelValue" @input="$emit('update:modelValue', $event.target.value)">
        <option value="#28563a">Verde</option>
        <option value="#3a4c8a">Azul</option>
        <option value="#8a3a3a">Rojo</option>
        <option value="#553c9a">Morado</option>
        <option value="#b7791f">Oro</option>
        <option value="#1A202C">Negro</option>
        <option value="#4A5568">Gris</option>
      </select>

      <button class="option-item" @click="gameStore.toggleDisplayMode()">
        {{ gameStore.displayInBBs ? gameStore.currency : 'BBs' }}
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { useGameStore } from '../store/game';

// Definimos las propiedades y eventos para comunicarnos con el componente padre
defineProps({
  modelValue: String
});
defineEmits(['update:modelValue']);

const gameStore = useGameStore();

const panelRef = ref(null);
const isDragging = ref(false);
const dragOffset = ref({ x: 0, y: 0 });
const panelPosition = ref({ x: 0, y: 0 });
const isDraggable = ref(true);

function startDrag(event) {
  if (!isDraggable.value) return;
  isDragging.value = true;
  const rect = panelRef.value.getBoundingClientRect();
  dragOffset.value = {
    x: event.clientX - rect.left,
    y: event.clientY - rect.top
  };
  document.addEventListener('mousemove', drag);
  document.addEventListener('mouseup', stopDrag);
}

function drag(event) {
  if (!isDragging.value) return;
  panelPosition.value = {
    x: event.clientX - dragOffset.value.x,
    y: event.clientY - dragOffset.value.y
  };
}

function stopDrag() {
  isDragging.value = false;
  isDraggable.value = false;
  localStorage.setItem('displayOptionsPosition', JSON.stringify(panelPosition.value));
  document.removeEventListener('mousemove', drag);
  document.removeEventListener('mouseup', stopDrag);
}

onMounted(() => {
  const savedPosition = localStorage.getItem('displayOptionsPosition');
  if (savedPosition) {
    panelPosition.value = JSON.parse(savedPosition);
    isDraggable.value = false;
  } else {
    // Set initial position
    const rect = panelRef.value.getBoundingClientRect();
    panelPosition.value = {
      x: window.innerWidth / 2 - rect.width / 2,
      y: window.innerHeight - 300
    };
    isDraggable.value = true;
  }
});

onUnmounted(() => {
  document.removeEventListener('mousemove', drag);
  document.removeEventListener('mouseup', stopDrag);
});
</script>

<style scoped>
.display-options-wrapper {
  display: flex;
  flex-direction: column;
  gap: 15px;
  align-items: center;
  padding: 15px;
  background-color: #2d3748;
  border-radius: 12px;
  border: 1px solid var(--border-color);
}

h3 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: bold;
  color: white;
}

.options-row {
  display: flex;
  gap: 15px;
  align-items: center;
}

.option-item {
  height: 50px;
  width: 120px;
  padding: 0 15px;
  font-size: 1.2rem;
  font-weight: bold;
  border: 1px solid #000;
  border-radius: 8px;
  background-color: #718096;
  color: white;
  cursor: pointer;
  text-align: center;
}
</style>

-------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/EndSessionModal.vue ---

<!-- src/components/EndSessionModal.vue -->
<template>
  <div class="modal-overlay" @click.self="cancel">
    <div class="modal-content">
      <h3>Finalizar Sesión</h3>
      
      <div class="summary">
        <div class="summary-item"><span>Buy-in Inicial:</span> <span>{{ sessionStore.currency }}{{ sessionStore.initialStack }}</span></div>
        <div class="summary-item"><span>Rebuys/Add-ons:</span> <span>{{ sessionStore.currency }}{{ sessionStore.totalRebuys }}</span></div>
        <div class="summary-item"><span>Gastos (propinas, etc.):</span> <span>- {{ sessionStore.currency }}{{ sessionStore.totalExpenses }}</span></div>
        <hr>
        <div class="summary-item total-investment"><span>Inversión Total:</span> <span>{{ sessionStore.currency }}{{ totalInvestment }}</span></div>
      </div>

      <div class="final-stack-input">
        <label for="final-stack">Introduce tu Stack Final:</label>
        <div class="input-group">
          <span>{{ sessionStore.currency }}</span>
          <input id="final-stack" type="number" v-model.number="finalStack" placeholder="Stack al finalizar" ref="inputRef">
        </div>
      </div>
      
      <div class="result-display" :class="resultClass">
        <h4>Resultado de la Sesión</h4>
        <p>{{ sessionResult >= 0 ? '+' : '' }}{{ sessionStore.currency }}{{ sessionResult.toFixed(2) }}</p>
      </div>

      <div class="modal-actions">
        <button class="btn-cancel" @click="cancel">Cancelar</button>
        <button class="btn-confirm" @click="confirm" :disabled="finalStack === null || finalStack < 0">Confirmar y Guardar</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';
import { useSessionStore } from '../store/useSessionStore';

const emit = defineEmits(['confirm', 'cancel']);
const sessionStore = useSessionStore();

const finalStack = ref(null);
const inputRef = ref(null);

const totalInvestment = computed(() => sessionStore.initialStack + sessionStore.totalRebuys);
const sessionResult = computed(() => {
  if (finalStack.value === null || finalStack.value < 0) return 0;
  return finalStack.value - totalInvestment.value - sessionStore.totalExpenses;
});

const resultClass = computed(() => {
  if (sessionResult.value > 0) return 'profit';
  if (sessionResult.value < 0) return 'loss';
  return 'even';
});

function confirm() {
  emit('confirm', finalStack.value);
}

function cancel() {
  emit('cancel');
}

onMounted(() => {
  inputRef.value?.focus();
});
</script>

<style scoped>
.modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.8);display:flex;justify-content:center;align-items:center;z-index:2000}.modal-content{background-color:#2d3748;padding:2rem;border-radius:12px;border:1px solid var(--border-color);width:90%;max-width:450px;text-align:center}h3{margin-top:0;font-size:1.8rem}.summary{text-align:left;margin:1.5rem 0;font-size:1.1rem}.summary-item{display:flex;justify-content:space-between;padding:.5rem 0}.total-investment{font-weight:700;border-top:1px solid var(--border-color);margin-top:.5rem;padding-top:.5rem}.final-stack-input{margin:1.5rem 0}.final-stack-input label{display:block;margin-bottom:.5rem;font-weight:700}.input-group{display:flex;align-items:center;background-color:#1a202c;border-radius:6px;border:1px solid var(--border-color)}.input-group span{padding:0 15px;font-size:1.2rem;color:#a0aec0}.input-group input{flex-grow:1;background:0 0;border:none;font-size:1.5rem;padding:15px;color:#fff;outline:0}.result-display{margin:1.5rem 0;padding:1rem;border-radius:8px}.result-display h4{margin:0 0 .5rem}.result-display p{margin:0;font-size:2.5rem;font-weight:700}.result-display.profit{background-color:rgba(47,133,90,.3);color:#68d391}.result-display.loss{background-color:rgba(197,48,48,.3);color:#fc8181}.result-display.even{background-color:rgba(74,85,104,.3);color:#a0aec0}.modal-actions{display:flex;gap:1rem;margin-top:2rem}.modal-actions button{flex-grow:1;padding:15px;font-size:1.1rem;font-weight:700}.btn-cancel{background-color:#718096}.btn-confirm{background-color:#48bb78}
</style>

--------------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/HelloWorld.vue ---

<script setup>
import { ref } from 'vue'

defineProps({
  msg: String,
})

const count = ref(0)
</script>

<template>
  <h1>{{ msg }}</h1>

  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>

  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>

<style scoped>
.read-the-docs {
  color: #888;
}
</style>


---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/Player.vue ---

<template>
  <div class="player-container" :style="seatStyle">

    <div class="player-cards">
        <div class="card-placeholder" @click="handleCardClick(player.id, 0)">
          <PlayingCard v-if="player.cards[0]" :cardId="player.cards[0]" />
          <svg v-else width="100%" height="100%" viewBox="0 0 100 140" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="100" height="140" rx="8" fill="#4A5568"/>
            <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="white" font-size="60" font-weight="bold">+</text>
          </svg>
        </div>
        <div class="card-placeholder" @click="handleCardClick(player.id, 1)">
          <PlayingCard v-if="player.cards[1]" :cardId="player.cards[1]" />
          <svg v-else width="100%" height="100%" viewBox="0 0 100 140" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="100" height="140" rx="8" fill="#4A5568"/>
            <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="white" font-size="60" font-weight="bold">+</text>
          </svg>
        </div>
    </div>
    
    <div class="player-seat" :class="{ faded: !player.inHand, active: isActivePlayer, 'is-hero': player.name === 'Hero' }">
      
      <div v-if="player.isDealer" class="dealer-button" :style="dealerButtonStyle">D</div>

      <div class="player-info-panel">
        <div class="player-info">
          <div class="player-name">
            <span v-if="player.tag" class="player-tag" :style="{ backgroundColor: player.tag }"></span>
            <div v-if="gameStore.isPreActionPhase" class="editable-name-wrapper">
              <input
                type="text"
                :value="player.name"
                @change="gameStore.updatePlayerName(player.id, $event.target.value)"
                class="player-input player-name-input"
              />
              <span class="player-position-static">({{ player.position }})</span>
            </div>
            <span v-else>{{ player.name }} ({{ player.position }})</span>
          </div>
          <div class="player-stack">
            <div v-if="gameStore.isPreActionPhase" class="stack-input-wrapper">
              <span>{{ gameStore.currency }}</span>
              <input
                type="number"
                :value="player.stack"
                @change="gameStore.updatePlayerStack(player.id, $event.target.value)"
                class="player-input player-stack-input"
              />
            </div>
            <span v-else>
              <span v-if="!gameStore.displayInBBs">{{ gameStore.currency }}{{ player.stack }}</span>
              <span v-else>{{ (player.stack / gameStore.bigBlind).toFixed(1) }} BBs</span>
            </span>
          </div>
        </div>
      </div>
      
      <button v-if="gameStore.isPreActionPhase" @click="gameStore.toggleNotesPanel(player.id)" class="edit-notes-btn" ref="editBtnRef">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
        </svg>
      </button>

      <div v-if="!gameStore.isPreActionPhase && player.notes" class="notes-display-wrapper">
        <svg class="notes-display-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
        </svg>
        <div class="notes-tooltip">{{ player.notes }}</div>
      </div>
    </div>

    <div v-if="isNotesPanelOpen" class="notes-panel" :style="notesPanelStyle" ref="notesPanelRef">
      <textarea
        :value="player.notes"
        @input="gameStore.updatePlayerNotes(player.id, $event.target.value)"
        placeholder="Notas sobre el jugador..."
      ></textarea>
      <div class="tags-container">
        <div
          v-for="color in tagColors"
          :key="color"
          class="tag-selector"
          :class="{ selected: player.tag === color }"
          :style="{ backgroundColor: color }"
          @click="gameStore.updatePlayerTag(player.id, color)"
        ></div>
      </div>
    </div>

    <div v-if="player.betThisRound > 0" class="bet-box" :style="betBoxStyle">
      <ChipStack :amount="player.betThisRound" :bigBlind="gameStore.bigBlind" />
      <div class="bet-info">
        <div class="bet-amount-container">
          <div class="bet-amount-text">
            <span v-if="!gameStore.displayInBBs">{{ gameStore.currency }}{{ player.betThisRound }}</span>
            <span v-else>{{ (player.betThisRound / gameStore.bigBlind).toFixed(1) }}</span>
          </div>
        </div>
        <img v-if="player.isAllIn" src="/icons/all-in-icon.svg" alt="All-in" class="all-in-icon" />
      </div>
    </div>

  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import { useGameStore } from '../store/game'
import PlayingCard from './PlayingCard.vue';
import ChipStack from './ChipStack.vue';

const notesPanelRef = ref(null);
const editBtnRef = ref(null);

const tagColors = ['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef'];

const props = defineProps({
  player: Object,
  playerCount: Number,
  index: Number,
  heroIndex: Number,
})

const gameStore = useGameStore();

const isNotesPanelOpen = computed(() => gameStore.openNotesPanelPlayerId === props.player.id);

function handleCardClick(playerId, cardIndex) {
  const target = { type: 'player', id: playerId, cardIndex: cardIndex };
  if (props.player.cards[cardIndex]) {
    gameStore.unassignCard(target);
  } else {
    gameStore.openCardPicker(target);
  }
}

function handleClickOutside(event) {
  if (gameStore.openNotesPanelPlayerId === props.player.id && notesPanelRef.value && !notesPanelRef.value.contains(event.target) && editBtnRef.value && !editBtnRef.value.contains(event.target)) {
    gameStore.closeNotesPanel();
  }
}

onMounted(() => {
  document.addEventListener('click', handleClickOutside);
});

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside);
});

const isActivePlayer = computed(() => gameStore.activePlayerIndex === props.player.id);
function calculateEquidistantPositions(playerCount, radiusX = 450, radiusY = 220) {
  const positions = [];
  const angleStep = (Math.PI * 2) / playerCount;
  for (let i = 0; i < playerCount; i++) {
    const angleRad = angleStep * i + Math.PI / 2; // Start from top
    const x = Math.cos(angleRad) * radiusX;
    let y = Math.sin(angleRad) * radiusY;
    // Adjust top and bottom players to be closer to table edges
    const angleDeg = (angleRad * 180) / Math.PI;
    if (angleDeg > 60 && angleDeg < 120) { // Top area
      y *= 1.1; // Move higher
    } else if (angleDeg > 240 && angleDeg < 300) { // Bottom area
      y *= 1.1; // Move lower
    }
    positions.push({ x: Math.round(x), y: Math.round(y) });
  }
  return positions;
}

const PREDEFINED_LAYOUTS = {
  2: [ { x: 0, y: 280 }, { x: 0, y: -280 } ],
  3: [ { x: 0, y: 240 }, { x: -520, y: -120 }, { x: 520, y: -120 } ],
  4: [ { x: 0, y: 280 }, { x: -420, y: 0 }, { x: 0, y: -280 }, { x: 420, y: 0 } ],
  5: [ { x: 0, y: 240 }, { x: -520, y: 100 }, { x: -400, y: -240 }, { x: 400, y: -240 }, { x: 520, y: 100 } ],
  6: [ { x: 0, y: 240 }, { x: -520, y: 120 }, { x: -520, y: -140 }, { x: 0, y: -280 }, { x: 520, y: -140 }, { x: 520, y: 120 } ],
  7: calculateEquidistantPositions(7, 500, 240),
  8: calculateEquidistantPositions(8, 500, 260),
  9: calculateEquidistantPositions(9, 500, 280),
};
const seatCoordinates = computed(() => {
  const visualIndex = (props.index - props.heroIndex + props.playerCount) % props.playerCount;
  if (PREDEFINED_LAYOUTS[props.playerCount]) {
    return PREDEFINED_LAYOUTS[props.playerCount][visualIndex];
  } else {
    const angleRad = (Math.PI * 2 / props.playerCount) * visualIndex + Math.PI / 2;
    const radiusX = 450;
    const radiusY = 220;
    return { x: Math.cos(angleRad) * radiusX, y: Math.sin(angleRad) * radiusY };
  }
});
const seatStyle = computed(() => {
  const { x, y } = seatCoordinates.value;
  return { transform: `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))` };
});
const dealerButtonStyle = computed(() => {
  return {
    bottom: '-40px',
    left: '57%',
    transform: 'translateX(-50%)'
  };
});
const betBoxStyle = computed(() => {
  const { x, y } = seatCoordinates.value;
  const threshold = 150;

  if (Math.abs(y) > threshold) {
    // Top/bottom players: position bets on the players
    if (y > 0) {
      // Top player: position bet on player
      return { top: '-30%', left: '50%', transform: 'translateX(-50%)', zIndex: 11 };
    } else {
      // Bottom player: position bet on player
      return { bottom: '-45%', left: '50%', transform: 'translateX(-50%)', zIndex: 11 };
    }
  } else {
    // Left/right players: position bets on the players
    if (x < 0) {
      // Left player: position bet on player
      return { right: '-40%', top: '50%', transform: 'translateY(-50%)', zIndex: 11 };
    } else {
      // Right player: position bet on player
      return { left: '-35%', top: '50%', transform: 'translateY(-50%)', zIndex: 11 };
    }
  }
});
const notesPanelStyle = computed(() => {
  return { top: '10%', left: '50%', transform: 'translateX(-50%)' };
});
</script>

<style scoped>
/* --- ESTILOS COMPLETAMENTE RENOVADOS --- */
.player-container {
  position: absolute;
  top: 50%;
  left: 50%;
  z-index: 5;
  width: 150px;
  /* CAMBIO: La altura ahora es fija y tiene en cuenta el nuevo tamaño de las cartas */
  height: 200px; /* Increased height to create space above for community cards */
}

.player-seat {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 60px;
  background: none;
  border: none;
  transition: all 0.3s ease;
}

.player-info-panel {
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, rgba(45, 55, 72, 0.95) 0%, rgba(26, 32, 44, 0.95) 100%);
  border: 1px solid rgba(74, 85, 104, 0.5);
  border-radius: 8px;
  padding: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.05);
  text-align: center;
  z-index: 10;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.player-cards {
  position: absolute;
  /* Moved closer to the player panel */
  top: 38px;
  left: 55%;
  transform: translateX(-50%);
  display: flex;
  justify-content: center;
  gap: 5px;
  width: 100%;
  z-index: 9;
}

.card-placeholder {
  width: var(--player-card-width);
  height: var(--player-card-height);
  cursor: pointer;
  position: relative;
}

.player-name {
  font-weight: 700;
  font-size: 1.1em;
  color: #E2E8F0;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  margin-bottom: 4px;
}

.player-stack {
  font-family: 'Roboto Mono', monospace;
  font-size: 1.2em;
  font-weight: 700;
  color: #FFFFFF;
  background-color: rgba(0,0,0,0.3);
  border-radius: 4px;
  padding: 2px 6px;
}

.active .player-info-panel {
  border-color: #f6e05e;
  box-shadow: 0 0 15px rgba(246, 224, 94, 0.5), 0 4px 15px rgba(0, 0, 0, 0.4);
}

.faded {
  opacity: 0.5;
}

.dealer-button {
  position: absolute;
  width: 25px;
  height: 25px;
  background: linear-gradient(145deg, #ffffff, #e6e6e6);
  color: #333;
  border-radius: 50%;
  font-weight: bold;
  font-size: 1rem;
  display: flex;
  justify-content: center;
  align-items: center;
  border: 1px solid rgba(0,0,0,0.2);
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  z-index: 15;
}

.bet-box {
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0px;
  z-index: 9;
}

.bet-info {
  display: flex;
  align-items: center;
  gap: 5px;
}

.bet-amount-text {
  background-color: rgba(0,0,0,0.8);
  border: 1px solid #000;
  padding: 2px 8px;
  border-radius: 6px;
  font-size: 1em;
  font-weight: bold;
  color: white;
  white-space: nowrap;
}

.all-in-icon {
  width: 40px;
  height: 40px;
}

.is-hero .player-info-panel {
  border-color: #68d391;
  animation: hero-glow 2s infinite ease-in-out;
}

@keyframes hero-glow {
  0%, 100% {
    box-shadow: 0 0 8px #68d391, 0 0 10px #68d391 inset, 0 4px 15px rgba(0, 0, 0, 0.4);
  }
  50% {
    box-shadow: 0 0 20px #68d391, 0 0 15px #68d391 inset, 0 4px 15px rgba(0, 0, 0, 0.4);
  }
}

.player-input {
  background-color: #1a202c;
  border: 1px solid var(--border-color);
  color: var(--text-color);
  border-radius: 4px;
  text-align: center;
  padding: 2px 4px;
  max-width: 100%;
}
.player-name-input {
  font-size: 0.9em;
  width: 70px;
}
.player-stack-input {
  font-size: 1em;
  width: 70px;
  -moz-appearance: textfield;
}
.player-stack-input::-webkit-outer-spin-button,
.player-stack-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.stack-input-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
}
.editable-name-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
}
.player-position-static {
  font-size: 0.9em;
  color: #a0aec0;
}

.edit-notes-btn, .notes-display-wrapper {
  position: absolute;
  top: -4px;
  right: -26px;
  z-index: 15;
}

.edit-notes-btn {
  background: rgba(45, 55, 72, 0.9);
  border: 3px solid rgba(74, 85, 104, 0.5);
  border-radius: 50%;
  width: 30px;
  height: 30px;
  padding: 2px;
  cursor: pointer;
  color: #cbd5e0;
}
.edit-notes-btn:hover {
  background: rgba(74, 85, 104, 1);
  color: white;
}
.notes-panel {
  position: absolute;
  width: 220px;
  background-color: #2d3748;
  border: 1px solid var(--border-color);
  border-radius: 8px;
  padding: 10px;
  z-index: 20;
  display: flex;
  flex-direction: column;
  gap: 10px;
  box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}
.notes-panel textarea {
  width: 100%;
  height: 100px;
  resize: vertical;
  background-color: #1a202c;
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 5px;
  font-family: inherit;
  font-size: 0.9rem;
}
.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.tag-selector {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid transparent;
  transition: transform 0.1s;
}
.tag-selector:hover {
  transform: scale(1.1);
}
.tag-selector.selected {
  border-color: white;
  box-shadow: 0 0 5px white;
}
.player-tag {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
  border: 1px solid rgba(0,0,0,0.5);
}
.notes-display-wrapper {
  position: absolute;
  top: -4px;
  left: -8px;
  z-index: 15;
}
.notes-display-icon {
  width: 24px;
  height: 24px;
  color: #a0aec0;
  cursor: pointer;
  background-color: rgba(45, 55, 72, 0.9);
  border-radius: 50%;
  padding: 2px;
  border: 1px solid rgba(74, 85, 104, 0.5);
}
.notes-display-wrapper .notes-tooltip {
  visibility: hidden;
  opacity: 0;
  width: 200px;
  background-color: #1a202c;
  color: #fff;
  text-align: left;
  border-radius: 6px;
  padding: 8px;
  position: absolute;
  z-index: 25;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  transition: opacity 0.3s;
  font-size: 0.9rem;
  font-weight: normal;
  white-space: pre-wrap;
  border: 1px solid var(--border-color);
  box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}
.notes-display-wrapper:hover .notes-tooltip {
  visibility: visible;
  opacity: 1;
}

/* Responsive design se mantiene igual */
</style>


-----------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/PlayingCard.vue ---

<template>
  <div class="playing-card" :class="suitDetails.colorClass">
    <span class="rank">{{ rank }}</span>
    <span class="suit-icon" v-html="suitDetails.icon"></span>
  </div>
</template>

<script setup>
import { computed } from 'vue';

const props = defineProps({
  cardId: {
    type: String,
    required: true,
  }
});

const rank = computed(() => props.cardId ? props.cardId.slice(0, -1) : '');
const suit = computed(() => props.cardId ? props.cardId.slice(-1) : '');

const suitDetails = computed(() => {
  switch (suit.value) {
    case 'S': return { icon: '&spades;', colorClass: 'black' };
    case 'H': return { icon: '&hearts;', colorClass: 'red' };
    case 'C': return { icon: '&clubs;', colorClass: 'green' };
    case 'D': return { icon: '&diams;', colorClass: 'blue' };
    default: return { icon: '', colorClass: 'disabled' };
  }
});
</script>



<style scoped>
.playing-card {
  width: 100%;
  height: 100%;
  border: 1px solid #4A5568;
  border-radius: 6px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-family: 'Arial Black', sans-serif;
  font-weight: bold;
  color: white;
  user-select: none;
  box-sizing: border-box;
}

.rank {
  font-size: 2.5rem;
  line-height: 1.1;
}

.suit-icon {
  font-size: 1.5rem;
  line-height: 1;
}

.playing-card.black { background-color: #2d3748; }
.playing-card.red { background-color: #c53030; }
.playing-card.green { background-color: #2f855a; }
.playing-card.blue { background-color: #2b6cb0; }
.playing-card.disabled { background-color: #4a5568; }
</style>

----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/PokerTable.vue ---

<template>
  <div class="poker-table-container">
    <div class="poker-table" :style="{ backgroundColor: tableColor }">
      
      <div class="center-content">
        <div class="pot">
          Bote: 
          <span v-if="!gameStore.displayInBBs">{{ gameStore.currency }}{{ gameStore.totalPot }}</span>
          <span v-else>{{ (gameStore.totalPot / gameStore.bigBlind).toFixed(1) }}</span>
        </div>

        <div class="board">
          <div 
            v-for="(card, index) in 5" 
            :key="`board-${index}`" 
            class="card-placeholder"
            :class="{ locked: !isBoardCardClickable(index) }"
            @click="handleBoardCardClick(index)"
          >
            <PlayingCard v-if="gameStore.board[index]" :cardId="gameStore.board[index]" />
            <svg v-else width="100%" height="100%" viewBox="0 0 100 140" fill="none" xmlns="http://www.w3.org/2000/svg">
              <rect width="100" height="140" rx="8" fill="#374151"/>
              <text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" fill="white" font-size="60" font-weight="bold">+</text>
            </svg>
          </div>
        </div>
      </div>

      <Player
        v-for="(player, index) in gameStore.players"
        :key="player.id"
        :player="player"
        :player-count="gameStore.players.length"
        :index="index"
        :hero-index="heroIndex" 
      />
    </div>

    <div class="controls-panel">
      <ActionPanel v-if="gameStore.gamePhase !== 'replay'" v-model:modelValue="tableColor" />
      <DisplayOptions v-else v-model:modelValue="tableColor" />
      <div class="game-controls">
        <template v-if="gameStore.gamePhase !== 'replay'">
          <button @click="gameStore.navigateHistory(-1)" title="Acción anterior">Anterior</button>
          <button @click="gameStore.navigateHistory(1)" title="Siguiente acción">Siguiente</button>
          <button class="save-btn" @click="handleSaveHand()">Guardar Mano</button>
          <button class="reset-btn" @click="confirmNewHand()">Nueva Mano</button>
        </template>
        <template v-if="gameStore.gamePhase === 'replay'">
          <button v-if="!gameStore.isReplaying" @click="gameStore.playReplay()" class="play-btn">Play</button>
          <button v-else @click="gameStore.pauseReplay()" class="pause-btn">Pause</button>
          <button @click="gameStore.restartReplay()">Reiniciar</button>
          <button @click="gameStore.navigateHistory(-1)" title="Acción anterior">Anterior</button>
          <button @click="gameStore.navigateHistory(1)" title="Siguiente acción">Siguiente</button>

          <!-- SELECTOR DE VELOCIDAD AÑADIDO -->
          <select
            :value="gameStore.replaySpeed"
            @change="gameStore.setReplaySpeed($event.target.value)"
            title="Velocidad de reproducción"
          >
            <option value="0.5">x0.5</option>
            <option value="1">x1</option>
            <option value="1.25">x1.25</option>
            <option value="1.5">x1.5</option>
            <option value="1.75">x1.75</option>
            <option value="2">x2</option>
            <option value="3">x3</option>
          </select>

          <button @click="goToHandConfig" title="Ir a Configuración de Mano" class="new-hand-btn">Nueva Mano</button>
          
        </template>
      </div>
    </div>

    <!-- Confirmation Modal for New Hand -->
    <div v-if="showNewHandModal" class="modal-overlay" @click="closeNewHandModal">
      <div class="modal-content" @click.stop>
        <h3>Confirmar Nueva Mano</h3>
        <p>¿Desea guardar los cambios?</p>
        <div class="modal-actions">
          <button class="cancel-btn" @click="justNewHand">No</button>
          <button class="confirm-btn" @click="saveAndNewHand">Sí</button>
        </div>
      </div>
    </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">¡Mano guardada con éxito!</div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useGameStore } from '../store/game';
import Player from './Player.vue';
import ActionPanel from './ActionPanel.vue';
import DisplayOptions from './DisplayOptions.vue';
import PlayingCard from './PlayingCard.vue';

const gameStore = useGameStore();
const tableColor = ref('#28563a');
const showToast = ref(false);
const showNewHandModal = ref(false);

const clickablePhases = computed(() => ['flop', 'turn', 'river', 'showdown']);

function isBoardCardClickable(index) {
  if (gameStore.gamePhase === 'replay' || gameStore.gamePhase === 'showdown') {
    return true;
  }
  if (index <= 2) {
    return clickablePhases.value.includes(gameStore.gamePhase);
  }
  if (index === 3) {
    return gameStore.gamePhase === 'turn' || gameStore.gamePhase === 'river';
  }
  if (index === 4) {
    return gameStore.gamePhase === 'river';
  }
  return false;
}

function handleBoardCardClick(index) {
  if (!isBoardCardClickable(index)) return;
  const target = { type: 'board', id: index };
  if (gameStore.board[index]) {
    gameStore.unassignCard(target);
  } else {
    gameStore.openCardPicker(target);
  }
}

const heroIndex = computed(() => {
  const index = gameStore.players.findIndex(p => p.name === 'Hero');
  return index !== -1 ? index : 0;
});

function handleSaveHand() {
  gameStore.saveCurrentHand();
  showToast.value = true;
  setTimeout(() => {
    showToast.value = false;
  }, 3000);
}

function confirmNewHand() {
  showNewHandModal.value = true;
}

function closeNewHandModal() {
  showNewHandModal.value = false;
}

function saveAndNewHand() {
  gameStore.saveCurrentHand();
  showToast.value = true;
  setTimeout(() => {
    showToast.value = false;
  }, 3000);
  gameStore.resetHand();
  closeNewHandModal();
}

function justNewHand() {
  gameStore.resetHand();
  closeNewHandModal();
}

function goToHandConfig() {
  gameStore.gamePhase = 'pre-action';
  gameStore.resetHand();
}
</script>

<style scoped>
.poker-table-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 40px;
  gap: 20px;
  /* CAMBIO: Aumentamos el margen superior para bajar toda la mesa */
  margin-top: 65px;
}
.poker-table {
  position: relative;
  width: 1000px;
  height: 480px; 
  border-radius: 240px;
  border: 15px solid #5a3a22;
  box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
  transition: background-color 0.3s ease;
}
.center-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}
.pot {
  font-size: 1.3rem;
  font-weight: bold;
  color: white;
  background-color: rgba(0, 0, 0, 0.4);
  padding: 5px 15px;
  border-radius: 8px;
}
.board {
  display: flex;
  gap: 10px;
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 10px;
  min-width: 420px;
  justify-content: center;
  z-index: 10;
}
.card-placeholder {
  width: var(--player-card-width);
  height: var(--player-card-height);
  background-color: transparent;
  border-radius: 6px;
  overflow: hidden;
  cursor: pointer;
}
.card-placeholder:hover {
  outline: 2px solid #f6e05e;
}
.controls-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 60px;
  margin-bottom: 150px;
}
.game-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: auto auto;
  gap: 6px;
  margin-top: 150px;
  align-self: flex-end;
  margin-right: -820px;
}
/* REGLA CSS MODIFICADA PARA INCLUIR EL SELECT */
.game-controls > button, .game-controls > select {
  padding: 12px 20px;
  font-size: 1.1rem;
  font-weight: bold;
  border-radius: 8px;
  border: 1px solid #000;
  background-color: #718096;
  color: white; /* Añadido para asegurar consistencia */
  cursor: pointer; /* Añadido para asegurar consistencia */
}
.game-controls > button:hover, .game-controls > select:hover {
  background-color: #4A5568;
}
.reset-btn { background-color: #e53e3e !important; }
.reset-btn:hover { background-color: #c53030 !important; }
.save-btn { background-color: #48bb78 !important; }
.save-btn:hover { background-color: #38a169 !important; }
.new-hand-btn { background-color: #48bb78 !important; }
.new-hand-btn:hover { background-color: #38a169 !important; }
.play-btn { background-color: #38a169 !important; }
.play-btn:hover { background-color: #2f855a !important; }
.pause-btn { background-color: #dd6b20 !important; }
.pause-btn:hover { background-color: #c05621 !important; }

.card-placeholder.locked {
  cursor: not-allowed;
  opacity: 0.6;
}
.card-placeholder.locked:hover {
  outline: none;
}

/* Toast Styles */
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}

.success-toast {
  background-color: #38a169;
  color: white;
}

.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}

.toast-message {
  font-size: 1rem;
  font-weight: bold;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
  text-align: center;
  border: 1px solid var(--border-color);
}

.modal-content h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  color: white;
}

.modal-content p {
  margin: 0 0 2rem 0;
  color: #a0aec0;
  font-size: 1.1rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.cancel-btn, .confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.cancel-btn {
  background-color: #4A5568;
  color: white;
}

.cancel-btn:hover {
  background-color: #2D3748;
}

.confirm-btn {
  background-color: #38a169;
  color: white;
}

.confirm-btn:hover {
  background-color: #2f855a;
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/components/SessionChart.vue ---

<template>
  <div>
    <!-- Renderizado condicional del tipo de gráfico. El :key fuerza el redibujado al cambiar -->
    <Line v-if="chartsStore.chartType === 'line'" :key="'line-' + chartsStore.timeRange" :data="lineChartData" :options="chartOptions" />
    <Bar v-else :key="'bar-' + chartsStore.timeRange" :data="barChartData" :options="chartOptions" />
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import { useChartsStore } from '../store/useChartsStore';
import { useI18n } from 'vue-i18n';
import { Line, Bar } from 'vue-chartjs';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  Filler,
} from 'chart.js';

ChartJS.register(
  CategoryScale, LinearScale, PointElement, LineElement, BarElement, Title, Tooltip, Legend, Filler
);

const sessionStore = useSessionStore();
const chartsStore = useChartsStore();
const { t } = useI18n();

const filteredSessions = computed(() => {
  const allSessions = sessionStore.savedSessions;
  const range = chartsStore.timeRange;
  
  if (range === 'all') {
    return allSessions;
  }

  const now = new Date();
  const cutoffDate = new Date();

  switch (range) {
    case '7d': cutoffDate.setDate(now.getDate() - 7); break;
    case '1m': cutoffDate.setMonth(now.getMonth() - 1); break;
    case '3m': cutoffDate.setMonth(now.getMonth() - 3); break;
    case '6m': cutoffDate.setMonth(now.getMonth() - 6); break;
    case '1y': cutoffDate.setFullYear(now.getFullYear() - 1); break;
  }

  return allSessions.filter(session => {
    const parts = session.date.split('/');
    const sessionDate = new Date(parts[2], parts[1] - 1, parts[0]);
    return sessionDate >= cutoffDate;
  });
});

const sessionsInChronologicalOrder = computed(() => {
  return [...filteredSessions.value].reverse();
});

const lineChartData = computed(() => {
  const sessions = sessionsInChronologicalOrder.value;
  const labels = sessions.map(s => s.date);
  let cumulativeProfit = 0;
  const dataPoints = sessions.map(s => {
    cumulativeProfit += s.result || 0; 
    return cumulativeProfit;
  });

  return {
    labels: ['Inicio', ...labels],
    datasets: [{
      label: t('charts.cumulativeProfit'),
      data: [0, ...dataPoints],
      borderColor: (context) => {
        const chart = context.chart;
        const { ctx, chartArea } = chart;
        if (!chartArea) return null;
        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
        gradient.addColorStop(0, '#c53030');
        gradient.addColorStop(0.5, '#718096');
        gradient.addColorStop(1, '#38a169');
        return gradient;
      },
      backgroundColor: (context) => {
         const chart = context.chart;
        const { ctx, chartArea } = chart;
         if (!chartArea) return null;
         const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
         gradient.addColorStop(0, 'rgba(197, 48, 48, 0.2)');
         gradient.addColorStop(0.5, 'rgba(74, 85, 104, 0.2)');
         gradient.addColorStop(1, 'rgba(56, 161, 105, 0.2)');
         return gradient;
      },
      borderWidth: 3,
      pointBackgroundColor: '#fff',
      pointBorderColor: '#fff',
      tension: 0.1,
      fill: true,
    }],
  };
});

const barChartData = computed(() => {
  const sessions = sessionsInChronologicalOrder.value;
  const labels = sessions.map(s => s.date);
  const dataPoints = sessions.map(s => s.result || 0);

  return {
    labels,
    datasets: [{
      label: 'Resultado de la Sesión',
      data: dataPoints,
      backgroundColor: dataPoints.map(val => val >= 0 ? 'rgba(56, 161, 105, 0.6)' : 'rgba(197, 48, 48, 0.6)'),
      borderColor: dataPoints.map(val => val >= 0 ? '#38a169' : '#c53030'),
      borderWidth: 1,
    }],
  };
});

const chartOptions = {
  responsive: true,
  maintainAspectRatio: true,
  plugins: {
    legend: { display: false },
    tooltip: {
      callbacks: {
        label: function (context) {
          if (context.dataIndex === 0 && context.dataset.label === t('charts.cumulativeProfit')) {
            return ` ${t('charts.cumulativeProfit')}: ${sessionStore.currency}0.00`;
          }

          let label = '';
          let value = 0;

          if (context.dataset.label === t('charts.cumulativeProfit')) {
            const session = sessionsInChronologicalOrder.value[context.dataIndex - 1];
            if (session) {
              label = 'Resultado de la Sesión: ';
              value = session.result;
            }
          } 
          else {
            label = 'Resultado de la Sesión: ';
            value = context.parsed.y;
          }

          if (value !== null) {
            const prefix = value >= 0 ? '+' : '';
            label += `${prefix}${new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(value)}`;
          }
          return label;
        },
        // --- FUNCIÓN AÑADIDA PARA EL COLOR DEL TEXTO ---
        labelColor: function(context) {
          let value = 0;
          // Si es el gráfico de líneas, obtenemos el resultado de la sesión individual
          if (context.dataset.label === t('charts.cumulativeProfit')) {
            // El índice de la sesión es dataIndex - 1 porque el gráfico tiene un punto extra de "Inicio"
            if (context.dataIndex > 0) {
              const session = sessionsInChronologicalOrder.value[context.dataIndex - 1];
              if (session) {
                value = session.result;
              }
            }
          } 
          // Si es el gráfico de barras, el valor ya es el resultado de la sesión
          else {
            value = context.parsed.y;
          }

          return {
            borderColor: value >= 0 ? '#68d391' : '#fc8181', // Verde para positivo, Rojo para negativo
            backgroundColor: value >= 0 ? '#68d391' : '#fc8181',
          };
        }
      },
      backgroundColor: 'rgba(26, 32, 44, 0.9)',
      titleFont: { size: 14, weight: 'bold' },
      bodyFont: { size: 12 },
      padding: 10,
      borderColor: 'rgba(74, 85, 104, 0.8)',
      borderWidth: 1,
      // Habilitar que el color de la etiqueta (label) cambie
      usePointStyle: true, 
      boxPadding: 4
    },
  },
  scales: {
    y: {
      ticks: { color: '#a0aec0', callback: (value) => `${sessionStore.currency}${value}` },
      grid: { color: 'rgba(74, 85, 104, 0.4)' },
    },
    x: {
      ticks: { color: '#a0aec0' },
      grid: { display: false },
    },
  },
};
</script>

-----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/i18n.js ---

import { createI18n } from 'vue-i18n';
import es from './locales/es.json';
import en from './locales/en.json';

// Puedes añadir más importaciones de idiomas aquí
// import fr from './locales/fr.json';
// import zh from './locales/zh.json';

const i18n = createI18n({
  legacy: false, // Importante para usarlo en Composition API
  locale: localStorage.getItem('locale') || 'es', // Carga el idioma guardado o usa español por defecto
  fallbackLocale: 'en', // Idioma de respaldo si una traducción no existe
  messages: {
    es,
    en,
    // fr,
    // zh,
  },
});

export default i18n;

---------------------------------------

--- INICIO DEL ARCHIVO: src/locales/en.json ---

{
  "nav": {
    "currentHand": "Current Hand",
    "savedHands": "Saved Hands",
    "liveSession": "Live Session",
    "savedSessions": "Saved Sessions",
    "charts": "Charts",
    "settings": "Settings",
    "summary": "Summary"
  },
  "currentHand": {
    "handConfiguration": "Hand Configuration",
    "playerCount": "Number of Players",
    "players": "Players",
    "smallBlind": "Small Blind",
    "bigBlind": "Big Blind",
    "currency": "Currency",
    "configurePlayers": "Configure Players",
    "playerName": "Name",
    "stack": "Stack",
    "startHand": "Start Hand",
    "selectPosition": "Select Your Position (Hero)",
    "confirmAndStart": "Confirm and Start Hand"
  },
  "actionPanel": {
    "turnOf": "Turn:",
    "fold": "FOLD",
    "check": "CHECK",
    "call": "CALL",
    "bet": "BET",
    "raise": "RAISE",
    "pot": "POT",
    "allIn": "ALL-IN"
  },
  "pokerTable": {
    "pot": "Pot"
  },
  "liveSession": {
    "title": "Live Session",
    "titleOnBreak": "On Break",
    "configTitle": "Game Configuration",
    "playerCount": "Players at table",
    "blindsLevel": "Blinds Level",
    "location": "Location / Casino",
    "currency": "Currency",
    "initialStack": "Initial Stack (Buy-in)",
    "startSession": "Start Session",
    "break": "Break",
    "endBreak": "End Break",
    "endSession": "End Session",
    "liveActionsTitle": "QUICK ACTIONS",
    "rebuyAmount": "Rebuy Amount",
    "addRebuy": "Add Rebuy",
    "tipAmount": "Tip",
    "addTip": "Tip Dealer",
    "expenseAmount": "Expense",
    "addExpense": "Add Expense"
  },
  "endSessionModal": {
    "title": "End Session",
    "initialBuyIn": "Initial Buy-in:",
    "rebuysAddOns": "Rebuys/Add-ons:",
    "expenses": "Expenses (tips, etc.):",
    "totalInvestment": "Total Investment:",
    "finalStackLabel": "Enter Your Final Stack:",
    "finalStackPlaceholder": "Stack at the end",
    "sessionResult": "Session Result",
    "cancel": "Cancel",
    "confirm": "Confirm & Save"
  },
  "savedSessions": {
    "title": "Saved Sessions",
    "noSessions": "You have no saved sessions yet.",
    "duration": "Duration:",
    "breaks": "Breaks:",
    "buyIn": "Buy-in:",
    "rebuys": "Rebuys:",
    "expenses": "Expenses:",
    "finalStack": "Final Stack:",
    "blinds": "Blinds:",
    "players": "Players:",
    "result": "Result",
    "delete": "Delete"
  },
  "charts": {
    "title": "Session Results Chart",
    "noData": "You need at least two saved sessions to generate a chart.",
    "cumulativeProfit": "Cumulative Profit"
  },
  "settings": {
    "title": "Settings",
    "language": "Application Language"
  },
  "summary": {
    "title": "Overall Summary",
    "totalProfit": "Total Profit",
    "avgBuyIn": "Avg Buy-in",
    "avgCashOut": "Avg Cash Out",
    "sessionsTitle": "Sessions",
    "sessionCount": "Sessions Played",
    "totalHours": "Hours Played"
  }
}

-----------------------------------------------

--- INICIO DEL ARCHIVO: src/locales/es.json ---

{
  "nav": {
    "currentHand": "Mano Actual",
    "savedHands": "Manos Guardadas",
    "liveSession": "Sesión en Vivo",
    "savedSessions": "Sesiones Guardadas",
    "charts": "Gráficas",
    "settings": "Configuración",
    "summary": "Sumario"
  },
  "currentHand": {
    "handConfiguration": "Configuración de la Mano",
    "playerCount": "Número de Jugadores",
    "players": "Jugadores",
    "smallBlind": "Ciega Pequeña",
    "bigBlind": "Ciega Grande",
    "currency": "Moneda",
    "configurePlayers": "Configurar Jugadores",
    "playerName": "Nombre",
    "stack": "Stack",
    "startHand": "Iniciar Mano",
    "selectPosition": "Selecciona tu Posición (Hero)",
    "confirmAndStart": "Confirmar e Iniciar Mano"
  },
  "actionPanel": {
    "turnOf": "Turno de:",
    "fold": "FOLD",
    "check": "CHECK",
    "call": "CALL",
    "bet": "BET",
    "raise": "RAISE",
    "pot": "POT",
    "allIn": "ALL-IN"
  },
  "pokerTable": {
    "pot": "Bote"
  },
  "liveSession": {
    "title": "Sesión en Vivo",
    "titleOnBreak": "En Descanso",
    "configTitle": "Configuración de la Partida",
    "playerCount": "Jugadores en la mesa",
    "blindsLevel": "Nivel de Ciegas",
    "location": "Lugar / Casino",
    "currency": "Moneda",
    "initialStack": "Stack Inicial (Buy-in)",
    "startSession": "Iniciar Sesión",
    "break": "Descanso",
    "endBreak": "Fin del Descanso",
    "endSession": "Finalizar Sesión",
    "liveActionsTitle": "ACCIONES RÁPIDAS",
    "rebuyAmount": "Monto Recarga",
    "addRebuy": "Añadir Recarga",
    "tipAmount": "Propina",
    "addTip": "Tip Dealer",
    "expenseAmount": "Gasto",
    "addExpense": "Consumición"
  },
  "endSessionModal": {
    "title": "Finalizar Sesión",
    "initialBuyIn": "Buy-in Inicial:",
    "rebuysAddOns": "Rebuys/Add-ons:",
    "expenses": "Gastos (propinas, etc.):",
    "totalInvestment": "Inversión Total:",
    "finalStackLabel": "Introduce tu Stack Final:",
    "finalStackPlaceholder": "Stack al finalizar",
    "sessionResult": "Resultado de la Sesión",
    "cancel": "Cancelar",
    "confirm": "Confirmar y Guardar"
  },
  "savedSessions": {
    "title": "Sesiones Guardadas",
    "noSessions": "No tienes sesiones guardadas todavía.",
    "duration": "Duración:",
    "breaks": "Descansos:",
    "buyIn": "Buy-in:",
    "rebuys": "Recargas:",
    "expenses": "Gastos:",
    "finalStack": "Stack Final:",
    "blinds": "Ciegas:",
    "players": "Jugadores:",
    "result": "Resultado",
    "delete": "Eliminar"
  },
  "charts": {
    "title": "Gráfica de Resultados de Sesiones",
    "noData": "Necesitas al menos dos sesiones guardadas para generar una gráfica.",
    "cumulativeProfit": "Beneficio Acumulado"
  },
  "settings": {
    "title": "Configuración",
    "language": "Idioma de la Aplicación"
  },
  "summary": {
    "title": "Sumario General",
    "totalProfit": "Total Profit",
    "avgBuyIn": "Avg Buy-in",
    "avgCashOut": "Avg Cash Out",
    "sessionsTitle": "Sesiones",
    "sessionCount": "Sesiones Jugadas",
    "totalHours": "Horas de Juego",
    "avgHours": "Media de Horas/Sesión",
    "avgBreak": "Duración media de descanso"
  }
}

-----------------------------------------------

--- INICIO DEL ARCHIVO: src/main.js ---

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import i18n from './i18n' // <-- IMPORTAR
import './styles.css'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.use(i18n) // <-- USAR
app.mount('#app')

---------------------------------------

--- INICIO DEL ARCHIVO: src/store/game.js ---

import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { v4 as uuidv4 } from 'uuid'

const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));

// --- LÓGICA DE EVALUACIÓN DE MANOS (PLACEHOLDER) ---
const evaluateHand = (playerCards, boardCards) => {
  const allCards = [...playerCards, ...boardCards].filter(c => c);
  if (allCards.length < 2) return { rank: 0, description: 'Nada' };
  const ranks = allCards.map(c => c.slice(0, -1));
  const rankCounts = ranks.reduce((acc, rank) => {
    acc[rank] = (acc[rank] || 0) + 1;
    return acc;
  }, {});
  const pairs = Object.keys(rankCounts).filter(r => rankCounts[r] === 2);
  const trips = Object.keys(rankCounts).filter(r => rankCounts[r] === 3);
  const quads = Object.keys(rankCounts).filter(r => rankCounts[r] === 4);
  if (quads.length > 0) return { rank: 7, description: `Poker de ${quads[0]}`};
  if (trips.length > 0 && pairs.length > 0) return { rank: 6, description: `Full House de ${trips[0]} y ${pairs[0]}`};
  if (trips.length > 0) return { rank: 3, description: `Trío de ${trips[0]}`};
  if (pairs.length === 2) return { rank: 2, description: `Doble pareja de ${pairs[0]} y ${pairs[1]}`};
  if (pairs.length === 1) return { rank: 1, description: `Pareja de ${pairs[0]}`};
  return { rank: 0, description: `Carta alta ${ranks[0]}` };
};

export const useGameStore = defineStore('game', () => {
  const players = ref([]);
  const heroPosition = ref(null);
  const smallBlind = ref(1);
  const bigBlind = ref(2);
  const currency = ref('$');
  const specialRule = ref('Ninguno');
  const bombPotBB = ref(2);
  const board = ref(['', '', '', '', '']);
  const pots = ref([]);
  const history = ref([]);
  const currentActionIndex = ref(-1);
  const savedHands = ref(JSON.parse(localStorage.getItem('pokerReplayerHands')) || []);
  const displayInBBs = ref(false);
  
  const replaySpeed = ref(1);
  const isReplaying = ref(false);
  let replayIntervalId = null;

  const gamePhase = ref('setup');
  const dealerPosition = ref(0);
  const activePlayerIndex = ref(null);
  const currentBet = ref(0);
  const minRaise = ref(0);
  const lastRaiserIndex = ref(null);
  const lastRaiseAmount = ref(0);
  const isCardPickerOpen = ref(false);
  const cardPickerTarget = ref(null);

  const isPreActionPhase = ref(true);
  const openNotesPanelPlayerId = ref(null);

  const totalPot = computed(() => pots.value.reduce((sum, pot) => sum + pot.amount, 0));

  const activePlayer = computed(() => {
    if (activePlayerIndex.value === null) return null;
    return players.value.find(p => p.id === activePlayerIndex.value);
  });

  const usedCards = computed(() => {
    const cards = new Set();
    players.value.forEach(p => {
      if (p.cards[0]) cards.add(p.cards[0]);
      if (p.cards[1]) cards.add(p.cards[1]);
    });
    board.value.forEach(c => {
      if (c) cards.add(c);
    });
    return cards;
  });

  function toggleDisplayMode() { displayInBBs.value = !displayInBBs.value; }
  
  function setReplaySpeed(newSpeed) {
    replaySpeed.value = parseFloat(newSpeed) || 1;
    if (isReplaying.value) {
      pauseReplay();
      playReplay();
    }
  }

  function playReplay() {
    if (isReplaying.value) return;
    isReplaying.value = true;
    
    const baseInterval = 1500;
    const intervalDuration = baseInterval / replaySpeed.value;

    replayIntervalId = setInterval(() => {
      if (currentActionIndex.value >= history.value.length - 1) {
        pauseReplay();
      } else {
        navigateHistory(1);
      }
    }, intervalDuration);
  }
  function pauseReplay() {
    clearInterval(replayIntervalId);
    isReplaying.value = false;
  }
  function restartReplay() {
    pauseReplay();
    currentActionIndex.value = 0;
    const stateToRestore = history.value[0];
    players.value = deepCopy(stateToRestore.players);
    board.value = deepCopy(stateToRestore.board);
    pots.value = deepCopy(stateToRestore.pots);
  }
  function setupNewHand(numPlayers, newHeroPosition, newCurrency, newSb, newBb, newSpecialRule, newBombPotBB = null) {
    pauseReplay();
    players.value = [];
    heroPosition.value = newHeroPosition;
    currency.value = newCurrency;
    smallBlind.value = newSb;
    bigBlind.value = newBb;
    specialRule.value = newSpecialRule;
    bombPotBB.value = newBombPotBB || 2;
    board.value = ['', '', '', '', ''];
    pots.value = [{ amount: 0, eligiblePlayers: [] }];
    history.value = [];
    currentActionIndex.value = -1;
    gamePhase.value = 'preflop';
    lastRaiseAmount.value = 0;
    displayInBBs.value = false;
    isPreActionPhase.value = true;
    const positions = getPositions(numPlayers);
    for (let i = 0; i < numPlayers; i++) {
      const isHero = positions[i] === newHeroPosition;
      players.value.push({
        id: i,
        name: isHero ? 'Hero' : `Jugador ${i + 1}`,
        stack: newBb * 100,
        cards: ['', ''],
        position: positions[i],
        inHand: true,
        isAllIn: false,
        hasActedThisRound: false,
        betThisRound: 0,
        totalBetInHand: 0,
        isDealer: false,
        isSB: false,
        isBB: false,
        isStraddle: false,
        isMississippi: false,
        isBombPot: false,
        // --- PROPIEDADES NUEVAS AÑADIDAS ---
        notes: '',
        tag: null,
      });
    }
    dealerPosition.value = players.value.find((p,i) => i === 0).id
    players.value[0].isDealer = true;
    let sbIndex, bbIndex;
    if (numPlayers === 2) {
      sbIndex = 0;
      bbIndex = 1;
      activePlayerIndex.value = players.value[sbIndex].id;
      lastRaiserIndex.value = players.value[bbIndex].id;
    } else {
      sbIndex = 1;
      bbIndex = 2;
      activePlayerIndex.value = players.value[(bbIndex + 1) % numPlayers].id;
      lastRaiserIndex.value = players.value[bbIndex].id;
    }

    // Handle Bomb Pot first (replaces blinds)
    if (specialRule.value === 'Bomb Pot') {
      // All players post the bomb pot amount as initial bet
      const bombAmount = bigBlind.value * bombPotBB.value;
      players.value.forEach(player => {
        postBet(player.id, bombAmount, true);
        player.isBombPot = true;
      });
      currentBet.value = bombAmount;
      minRaise.value = bombAmount * 2;
      lastRaiseAmount.value = bombAmount;
      // Action starts from the player to the left of BB (normal action)
      activePlayerIndex.value = players.value[(bbIndex + 1) % numPlayers].id;
      lastRaiserIndex.value = activePlayerIndex.value;
      recordState(`Bomb Pot: Todos los jugadores ponen ${bombPotBB.value} BB inicialmente.`);
    } else {
      // Normal blinds
      players.value[sbIndex].isSB = true;
      postBet(players.value[sbIndex].id, smallBlind.value, true);
      players.value[bbIndex].isBB = true;
      postBet(players.value[bbIndex].id, bigBlind.value, true);
      currentBet.value = bigBlind.value;
      minRaise.value = bigBlind.value * 2;
      lastRaiseAmount.value = bigBlind.value;
      recordState("Inicio de mano. Ciegas puestas.");

      // Handle Straddle
      if (specialRule.value === 'Straddle' && numPlayers > 2) {
        const straddleIndex = (bbIndex + 1) % numPlayers;
        players.value[straddleIndex].isStraddle = true;
        postBet(players.value[straddleIndex].id, bigBlind.value * 2, true);
        currentBet.value = bigBlind.value * 2;
        minRaise.value = bigBlind.value * 4;
        lastRaiseAmount.value = bigBlind.value * 2;
        lastRaiserIndex.value = players.value[straddleIndex].id;
        recordState(`Straddle puesto por ${players.value[straddleIndex].name}.`);
        // Adjust active player for straddle
        activePlayerIndex.value = players.value[(straddleIndex + 1) % numPlayers].id;
      }

      // Handle Mississippi
      if (specialRule.value === 'Mississippi') {
        const buttonIndex = players.value.findIndex(p => p.isDealer);
        players.value[buttonIndex].isMississippi = true;
        postBet(players.value[buttonIndex].id, bigBlind.value * 2, true);
        currentBet.value = Math.max(currentBet.value, bigBlind.value * 2);
        minRaise.value = bigBlind.value * 4;
        lastRaiseAmount.value = bigBlind.value * 2;
        lastRaiserIndex.value = players.value[buttonIndex].id;
        recordState(`Mississippi puesto por ${players.value[buttonIndex].name}.`);
        // Action starts from next to BB, already set
      }
    }
  }
  function performAction(action, amount = 0) {
    if (isPreActionPhase.value) {
      isPreActionPhase.value = false;
    }

    if (activePlayer.value === null) return;
    const player = activePlayer.value;
    player.hasActedThisRound = true;
    let actionDescription = '';
    switch (action) {
      case 'fold':
        player.inHand = false;
        actionDescription = `${player.name} se retira.`;
        break;
      case 'check':
        if (currentBet.value > player.betThisRound) return;
        actionDescription = `${player.name} pasa.`;
        break;
      case 'call':
        const callAmount = currentBet.value - player.betThisRound;
        postBet(player.id, callAmount);
        actionDescription = `${player.name} iguala.`;
        break;
      case 'all-in':
        const allInAmount = player.stack;
        const newTotalBet = player.betThisRound + allInAmount;
        postBet(player.id, allInAmount);
        actionDescription = `${player.name} va All-In por ${newTotalBet}.`;
        if (newTotalBet > currentBet.value) {
            players.value.forEach(p => { if(p.inHand && !p.isAllIn) p.hasActedThisRound = false; });
            const raiseDifference = newTotalBet - currentBet.value;
            lastRaiserIndex.value = player.id;
            minRaise.value = newTotalBet + raiseDifference;
            lastRaiseAmount.value = currentBet.value;
            currentBet.value = newTotalBet;
        }
        break;
      case 'bet':
      case 'raise':
        if (amount < minRaise.value && amount < player.stack + player.betThisRound) return;
        players.value.forEach(p => { if(p.inHand) p.hasActedThisRound = false; });
        const totalBet = amount;
        const raiseDifference = totalBet - currentBet.value;
        postBet(player.id, totalBet - player.betThisRound);
        lastRaiserIndex.value = player.id;
        minRaise.value = totalBet + raiseDifference;
        lastRaiseAmount.value = currentBet.value;
        currentBet.value = totalBet;
        actionDescription = `${player.name} ${action === 'bet' ? 'apuesta' : 'sube a'} ${totalBet}.`;
        break;
    }
    player.hasActedThisRound = true;
    recordState(actionDescription);
    checkHandOrRoundCompletion();
  }
  
  function checkHandOrRoundCompletion() {
    const playersInHand = players.value.filter(p => p.inHand);
    if (playersInHand.length === 1) {
      advanceRound();
      endHand(playersInHand[0]);
      return;
    }

    const playersAbleToAct = playersInHand.filter(p => !p.isAllIn);
    
    const roundIsOver = playersAbleToAct.every(p => {
      return p.hasActedThisRound && p.betThisRound === currentBet.value;
    });

    if (roundIsOver) {
      const isPreflopBbCheck = gamePhase.value === 'preflop' &&
        activePlayer.value.isBB &&
        currentBet.value === bigBlind.value;
      
      if (isPreflopBbCheck || playersAbleToAct.length < 2) {
        advanceRound();
      } else {
        advanceRound();
      }
    } else {
      advanceTurn();
    }
  }

  function runItOut() {
    advanceRound();
    if(gamePhase.value === 'showdown') return;
    recordState("--- Apuestas finalizadas, se reparten las cartas restantes ---");
    if (gamePhase.value === 'preflop') {
        gamePhase.value = 'flop';
        recordState("--- FLOP ---");
    }
    if (gamePhase.value === 'flop') {
        gamePhase.value = 'turn';
        recordState("--- TURN ---");
    }
    if (gamePhase.value === 'turn') {
        gamePhase.value = 'river';
        recordState("--- RIVER ---");
    }
    endHand();
  }
  function postBet(playerId, amount, isBlind = false) {
    const player = players.value.find(p => p.id === playerId);
    const bet = Math.min(amount, player.stack);
    player.stack -= bet;
    player.betThisRound += bet;

    if (player.stack === 0 && !isBlind) {
      player.isAllIn = true;
    }
  }
  function advanceTurn() {
    const currentIndex = players.value.findIndex(p => p.id === activePlayerIndex.value);
    let nextIndex = (currentIndex + 1) % players.value.length;
    while (!players.value[nextIndex].inHand || players.value[nextIndex].isAllIn) {
      nextIndex = (nextIndex + 1) % players.value.length;
    }
    activePlayerIndex.value = players.value[nextIndex].id;
  }
  function collectBetsAndCreatePots() {
      const playersInHand = players.value.filter(p => p.betThisRound > 0 || p.inHand);
      if (playersInHand.length === 0) return;
      playersInHand.forEach(p => p.totalBetInHand += p.betThisRound);
      while (true) {
          const playersWithMoney = playersInHand.filter(p => p.betThisRound > 0);
          if (playersWithMoney.length === 0) break;
          const allInPlayer = playersWithMoney.find(p => p.isAllIn);
          let currentPotContribution;
          if (allInPlayer) {
              const lowestAllInBet = Math.min(...playersWithMoney.filter(p => p.isAllIn).map(p => p.totalBetInHand));
              const lastTotalBetInPot = pots.value.reduce((sum, pot) => sum + (pot.betAmountPerPlayer || 0), 0);
              currentPotContribution = lowestAllInBet - lastTotalBetInPot;
          } else {
              currentPotContribution = Math.min(...playersWithMoney.map(p => p.betThisRound));
          }
          if (currentPotContribution <= 0) break;
          const newPot = { amount: 0, eligiblePlayers: [] };
          playersInHand.forEach(p => {
              if(p.totalBetInHand > 0) {
                  const contribution = Math.min(p.betThisRound, currentPotContribution);
                  p.betThisRound -= contribution;
                  newPot.amount += contribution;
                  if (!newPot.eligiblePlayers.includes(p.id)) {
                      newPot.eligiblePlayers.push(p.id);
                  }
              }
          });
          pots.value.push(newPot);
      }
      players.value.forEach(p => p.betThisRound = 0);
  }

  function advanceRound() {
    const betsOnTable = players.value.reduce((sum, p) => sum + p.betThisRound, 0);
    if(betsOnTable > 0) {
      if(pots.value.length === 1 && pots.value[0].amount === 0){
          pots.value[0].amount += betsOnTable;
          pots.value[0].eligiblePlayers = players.value.filter(p => p.inHand).map(p => p.id);
      } else {
         collectBetsAndCreatePots();
      }
    }
    players.value.forEach(p => { 
        p.betThisRound = 0;
        p.hasActedThisRound = false;
    });
    currentBet.value = 0;
    minRaise.value = bigBlind.value;
    lastRaiseAmount.value = 0;
    if (gamePhase.value === 'river') {
        endHand();
        return;
    }
    const playersAbleToAct = players.value.filter(p => p.inHand && !p.isAllIn);
    if (playersAbleToAct.length < 2) {
      runItOut();
      return;
    }

    let nextIndex;
    const dealerIndexInPlayersArray = players.value.findIndex(p => p.id === dealerPosition.value);

    if (players.value.length === 2) {
      nextIndex = (dealerIndexInPlayersArray + 1) % players.value.length;
    } else {
      nextIndex = (dealerIndexInPlayersArray + 1) % players.value.length;
    }

    while (!players.value[nextIndex].inHand || players.value[nextIndex].isAllIn) {
      nextIndex = (nextIndex + 1) % players.value.length;
    }
    activePlayerIndex.value = players.value[nextIndex].id;
    lastRaiserIndex.value = activePlayerIndex.value;

    switch (gamePhase.value) {
      case 'preflop': gamePhase.value = 'flop'; recordState("--- FLOP ---"); break;
      case 'flop': gamePhase.value = 'turn'; recordState("--- TURN ---"); break;
      case 'turn': gamePhase.value = 'river'; recordState("--- RIVER ---"); break;
    }
  }

  function endHand(winnerByFold = null) {
    gamePhase.value = 'showdown';
    activePlayerIndex.value = null;
    if(winnerByFold) {
      const winner = players.value.find(p => p.id === winnerByFold.id);
      winner.stack += totalPot.value;
      recordState(`La mano termina. ${winner.name} gana el bote de ${totalPot.value}.`);
      return;
    }
    recordState("--- SHOWDOWN --- Se muestran las cartas.");
    const playersToShowdown = players.value.filter(p => p.inHand);
    pots.value.forEach((pot, index) => {
        if(pot.amount === 0) return;
        const eligiblePlayers = playersToShowdown.filter(p => pot.eligiblePlayers.includes(p.id));
        if(eligiblePlayers.length === 1) {
            const winner = eligiblePlayers[0];
            winner.stack += pot.amount;
            recordState(`${winner.name} gana el bote ${index+1} de ${pot.amount}.`);
        } else if (eligiblePlayers.length > 1) {
            eligiblePlayers.forEach(p => { p.handResult = evaluateHand(p.cards, board.value); });
            eligiblePlayers.sort((a, b) => b.handResult.rank - a.handResult.rank);
            const bestRank = eligiblePlayers[0].handResult.rank;
            const winners = eligiblePlayers.filter(p => p.handResult.rank === bestRank);
            const potSplit = Math.floor(pot.amount / winners.length);
            winners.forEach(winner => { winner.stack += potSplit; });
            const winnerNames = winners.map(w => w.name).join(', ');
            recordState(`${winnerNames} gana${winners.length > 1 ? 'n' : ''} el bote ${index+1} de ${pot.amount} con ${winners[0].handResult.description}.`);
        }
    });
  }
  function resetHand() {
    pauseReplay();
    players.value = [];
    board.value = ['', '', '', '', ''];
    pots.value = [];
    history.value = [];
    currentActionIndex.value = -1;
    gamePhase.value = 'setup';
    isPreActionPhase.value = false;
    dealerPosition.value = 0;
    activePlayerIndex.value = null;
    currentBet.value = 0;
    minRaise.value = 0;
    lastRaiserIndex.value = null;
    lastRaiseAmount.value = 0;
  }
  function recordState(actionDescription) {
    const currentState = {
      players: deepCopy(players.value),
      board: deepCopy(board.value),
      pots: deepCopy(pots.value),
      description: actionDescription,
    };
    if(currentActionIndex.value < history.value.length - 1) {
      history.value.splice(currentActionIndex.value + 1);
    }
    history.value.push(currentState);
    currentActionIndex.value++;
  }
  function navigateHistory(direction) {
    const newIndex = currentActionIndex.value + direction;
    if (newIndex >= 0 && newIndex < history.value.length) {
      currentActionIndex.value = newIndex;
      const stateToRestore = history.value[newIndex];
      players.value = deepCopy(stateToRestore.players);
      board.value = deepCopy(stateToRestore.board);
      pots.value = deepCopy(stateToRestore.pots);
    }
  }
  function openCardPicker(target) {
    cardPickerTarget.value = target;
    isCardPickerOpen.value = true;
  }
  function closeCardPicker() {
    isCardPickerOpen.value = false;
    cardPickerTarget.value = null;
  }
  function assignCard(cardId) {
    if (!cardPickerTarget.value) return;
    const { type, id, cardIndex } = cardPickerTarget.value;
    if (type === 'player') {
      const player = players.value.find(p => p.id === id);
      if (player) player.cards[cardIndex] = cardId;
    } else if (type === 'board') {
      board.value[id] = cardId;
    }
    closeCardPicker();
    recordState(`Se asigna la carta ${cardId}.`);
  }
  function unassignCard(target) {
    const { type, id, cardIndex } = target;
    let cardToUnassign = '';
    if (type === 'player') {
      const player = players.value.find(p => p.id === id);
      if (player) {
        cardToUnassign = player.cards[cardIndex];
        player.cards[cardIndex] = '';
      }
    } else if (type === 'board') {
      cardToUnassign = board.value[id];
      board.value[id] = '';
    }
    if (cardToUnassign) {
      recordState(`Se desasigna la carta ${cardToUnassign}.`);
    }
  }
  function saveCurrentHand() {
    if (history.value.length === 0) return;
    const handToSave = {
      id: uuidv4(),
      date: new Date().toLocaleString(),
      heroPosition: heroPosition.value,
      numPlayers: players.value.length,
      history: deepCopy(history.value),
      smallBlind: smallBlind.value,
      bigBlind: bigBlind.value,
      currency: currency.value,
      specialRule: specialRule.value,
      bombPotBB: bombPotBB.value,
    };
    savedHands.value.push(handToSave);
    localStorage.setItem('pokerReplayerHands', JSON.stringify(savedHands.value));
  }
  function loadHand(handData) {
    pauseReplay();
    const initialState = handData.history[0];
    players.value = deepCopy(initialState.players);
    board.value = deepCopy(initialState.board);
    pots.value = deepCopy(initialState.pots);
    heroPosition.value = handData.heroPosition;
    smallBlind.value = handData.smallBlind;
    bigBlind.value = handData.bigBlind;
    currency.value = handData.currency;
    specialRule.value = handData.specialRule || 'Ninguno';
    bombPotBB.value = handData.bombPotBB || 2;
    history.value = deepCopy(handData.history);
    currentActionIndex.value = 0;
    gamePhase.value = 'replay';
    isPreActionPhase.value = false;
  }
  function deleteHand(handId) {
    savedHands.value = savedHands.value.filter(hand => hand.id !== handId);
    localStorage.setItem('pokerReplayerHands', JSON.stringify(savedHands.value));
  }
  function getPositions(numPlayers) {
    if (numPlayers === 2) { return ['BTN / SB', 'BB']; }
    if (numPlayers === 3) { return ['BTN', 'SB', 'BB']; }
    if (numPlayers === 4) { return ['BTN', 'SB', 'BB', 'CO']; }
    if (numPlayers === 5) { return ['BTN', 'SB', 'BB', 'MP', 'CO']; }
    if (numPlayers === 6) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'CO']; }
    if (numPlayers === 7) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'HJ', 'CO']; }
    if (numPlayers === 8) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'HJ', 'CO']; }
    if (numPlayers === 9) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'LJ', 'HJ', 'CO']; }
    const basePositions = ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP1', 'MP2', 'HJ', 'CO'];
    return basePositions.slice(0, numPlayers);
  }

  function updatePlayerName(playerId, newName) {
    if (!newName.trim()) return;
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.name = newName;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updatePlayerStack(playerId, newStack) {
    const stack = parseInt(newStack, 10);
    if (isNaN(stack) || stack < 0) return;
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.stack = stack;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  // --- NUEVAS ACCIONES PARA NOTAS Y TAGS ---
  function updatePlayerNotes(playerId, newNotes) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.notes = newNotes;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function updatePlayerTag(playerId, newTag) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      // Si se hace clic en el mismo tag, se deselecciona
      player.tag = player.tag === newTag ? null : newTag;
    }
    if (isPreActionPhase.value && history.value.length > 0) {
      history.value[0].players = deepCopy(players.value);
    }
  }

  function toggleNotesPanel(playerId) {
    if (openNotesPanelPlayerId.value === playerId) {
      openNotesPanelPlayerId.value = null;
    } else {
      openNotesPanelPlayerId.value = playerId;
    }
  }

  function closeNotesPanel() {
    openNotesPanelPlayerId.value = null;
  }


  return {
    players, heroPosition, smallBlind, bigBlind, currency, specialRule, bombPotBB, board, savedHands, pots,
    gamePhase, activePlayerIndex, currentBet, lastRaiseAmount,
    activePlayer, totalPot, displayInBBs,
    isReplaying, isCardPickerOpen, usedCards,
    replaySpeed, isPreActionPhase, openNotesPanelPlayerId,
    toggleDisplayMode,
    playReplay, pauseReplay, restartReplay, setReplaySpeed,
    setupNewHand, loadHand, saveCurrentHand, deleteHand, navigateHistory, recordState,
    performAction, resetHand,
    openCardPicker, closeCardPicker, assignCard, unassignCard,
    updatePlayerName, updatePlayerStack,
    updatePlayerNotes, updatePlayerTag, toggleNotesPanel, closeNotesPanel,
  }
});

---------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useChartsStore.js ---

import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useChartsStore = defineStore('charts', () => {
  // --- STATE ---
  const timeRange = ref('all');
  const chartType = ref('line'); // <-- NUEVO ESTADO: 'line' o 'bar'

  // --- ACTIONS ---
  function setTimeRange(newRange) {
    timeRange.value = newRange;
  }

  function toggleChartType() {
    chartType.value = chartType.value === 'line' ? 'bar' : 'line';
  }

  return {
    timeRange,
    chartType, // <-- Exportar nuevo estado
    setTimeRange,
    toggleChartType, // <-- Exportar nueva acción
  };
});

-------------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useSessionStore.js ---

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { v4 as uuidv4 } from 'uuid';

export const useSessionStore = defineStore('session', () => {
  // --- STATE ---
  const isActive = ref(false);
  const elapsedTime = ref(0);
  let sessionTimerInterval = null;
  const isOnBreak = ref(false);
  const breakElapsedTime = ref(0);
  let breakTimerInterval = null;
  const totalBreakTime = ref(0);
  const totalRebuys = ref(0);
  const totalExpenses = ref(0);
  const playerCount = ref(6);
  const blinds = ref('1/2');
  const location = ref('');
  const currency = ref('$');
  const initialStack = ref(200);
  const savedSessions = ref(JSON.parse(localStorage.getItem('pokerSavedSessions')) || []);
  
  // --- NUEVO ESTADO PARA EL FILTRO DEL SUMARIO ---
  const summaryDateFilter = ref('all');

  // --- NUEVA ACCIÓN PARA CAMBIAR EL FILTRO ---
  function setSummaryDateFilter(newFilter) {
    summaryDateFilter.value = newFilter;
  }

  // --- NUEVA COMPUTADA PARA FILTRAR SESIONES SEGÚN EL FILTRO SELECCIONADO ---
  const filteredSessionsForSummary = computed(() => {
    const filter = summaryDateFilter.value;
    if (filter === 'all') {
      return savedSessions.value;
    }

    const now = new Date();
    const cutoffDate = new Date();
    
    // El día de hoy a las 00:00 para que 'today' y 'last7days' funcionen correctamente
    cutoffDate.setHours(0, 0, 0, 0); 

    switch (filter) {
      case 'last7days': cutoffDate.setDate(now.getDate() - 7); break;
      case 'last1month': cutoffDate.setMonth(now.getMonth() - 1); break;
      case 'last3months': cutoffDate.setMonth(now.getMonth() - 3); break;
      case 'last6months': cutoffDate.setMonth(now.getMonth() - 6); break;
      case 'last1year': cutoffDate.setFullYear(now.getFullYear() - 1); break;
    }

    return savedSessions.value.filter(session => {
      // Usamos la misma lógica de parseo de fechas que en otras vistas
      const dateParts = session.date.split('/');
      const sessionDate = new Date(dateParts[2], dateParts[1] - 1, dateParts[0]);
      return sessionDate >= cutoffDate;
    });
  });

  // --- TODAS LAS COMPUTADAS SIGUIENTES AHORA USAN 'filteredSessionsForSummary' ---
  const totalNetProfit = computed(() => {
    return filteredSessionsForSummary.value.reduce((total, session) => total + (session.result || 0), 0);
  });

  const totalInvestment = computed(() => {
    return filteredSessionsForSummary.value.reduce((total, session) => {
      return total + (session.initialStack || 0) + (session.totalRebuys || 0);
    }, 0);
  });
  
  const roi = computed(() => {
    if (totalInvestment.value === 0) return 0;
    return (totalNetProfit.value / totalInvestment.value) * 100;
  });

  const winningDays = computed(() => {
    return filteredSessionsForSummary.value.filter(session => session.result > 0).length;
  });

  const losingDays = computed(() => {
    return filteredSessionsForSummary.value.filter(session => session.result < 0).length;
  });

  const bestDay = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const results = filteredSessionsForSummary.value.map(session => session.result || 0);
    return Math.max(...results);
  });

  const worstDay = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const results = filteredSessionsForSummary.value.map(session => session.result || 0);
    return Math.min(...results);
  });

  const winningStreak = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const chronologicalSessions = [...filteredSessionsForSummary.value].reverse();
    let maxStreak = 0;
    let currentStreak = 0;
    for (const session of chronologicalSessions) {
      if (session.result > 0) {
        currentStreak++;
      } else {
        maxStreak = Math.max(maxStreak, currentStreak);
        currentStreak = 0;
      }
    }
    maxStreak = Math.max(maxStreak, currentStreak);
    return maxStreak;
  });

  const averageBuyIn = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const totalInvest = filteredSessionsForSummary.value.reduce((total, session) => total + (session.initialStack || 0) + (session.totalRebuys || 0), 0);
    return totalInvest / filteredSessionsForSummary.value.length;
  });
  
  const averageCashOut = computed(() => {
    if (filteredSessionsForSummary.value.length === 0) return 0;
    const totalCashOut = filteredSessionsForSummary.value.reduce((total, session) => total + (session.finalStack || 0), 0);
    return totalCashOut / filteredSessionsForSummary.value.length;
  });

  const sessionCount = computed(() => filteredSessionsForSummary.value.length);

  const totalHoursPlayed = computed(() => {
    const totalSeconds = filteredSessionsForSummary.value.reduce((total, session) => total + (session.duration || 0), 0);
    return totalSeconds / 3600;
  });
  
  const averageHoursPlayed = computed(() => {
    if (sessionCount.value === 0) return 0;
    return totalHoursPlayed.value / sessionCount.value;
  });

  const averageBreakDuration = computed(() => {
    if (sessionCount.value === 0) return 0;
    const totalBreakSeconds = filteredSessionsForSummary.value.reduce((total, session) => total + (session.totalBreakTime || 0), 0);
    const sessionsWithBreaks = filteredSessionsForSummary.value.filter(s => s.totalBreakTime > 0).length;
    if (sessionsWithBreaks === 0) return 0;
    return (totalBreakSeconds / sessionsWithBreaks) / 60;
  });

  const winRatePerHour = computed(() => {
    if (totalHoursPlayed.value === 0) return 0;
    return totalNetProfit.value / totalHoursPlayed.value;
  });

  const averageRebuys = computed(() => {
    if (sessionCount.value === 0) return 0;
    const totalRebuysAmount = filteredSessionsForSummary.value.reduce((sum, session) => sum + (session.totalRebuys || 0), 0);
    return totalRebuysAmount / sessionCount.value;
  });

  const totalAllExpenses = computed(() => {
    return filteredSessionsForSummary.value.reduce((sum, session) => sum + (session.totalExpenses || 0), 0);
  });

  // --- ACTIONS --- (Sin cambios aquí)
  
  function startSession() {
    elapsedTime.value = 0;
    totalBreakTime.value = 0;
    totalRebuys.value = 0;
    totalExpenses.value = 0;
    isActive.value = true;
    isOnBreak.value = false;
    
    clearInterval(sessionTimerInterval);
    sessionTimerInterval = setInterval(() => {
      if (!isOnBreak.value) {
        elapsedTime.value++;
      }
    }, 1000);
  }

  function startBreak() {
    if (!isActive.value) return;
    isOnBreak.value = true;
    breakElapsedTime.value = 0;

    clearInterval(breakTimerInterval);
    breakTimerInterval = setInterval(() => {
      breakElapsedTime.value++;
    }, 1000);
  }

  function endBreak() {
    isOnBreak.value = false;
    totalBreakTime.value += breakElapsedTime.value;
    clearInterval(breakTimerInterval);
    breakTimerInterval = null;
  }

  function addRebuy(amount) {
    if (amount > 0) {
      totalRebuys.value += amount;
    }
  }

  function addExpense(amount) {
    if (amount > 0) {
      totalExpenses.value += amount;
    }
  }
  
  function stopAndSaveSession(finalStack) {
    if (isOnBreak.value) {
      totalBreakTime.value += breakElapsedTime.value;
    }

    const currentInvestment = initialStack.value + totalRebuys.value;
    const result = finalStack - currentInvestment - totalExpenses.value;

    const sessionSummary = {
      id: uuidv4(),
      date: new Date().toLocaleDateString(),
      duration: elapsedTime.value,
      totalBreakTime: totalBreakTime.value,
      playerCount: playerCount.value,
      blinds: blinds.value,
      location: location.value,
      currency: currency.value,
      initialStack: initialStack.value,
      totalRebuys: totalRebuys.value,
      totalExpenses: totalExpenses.value,
      finalStack: finalStack,
      result: result,
    };

    savedSessions.value.unshift(sessionSummary);
    localStorage.setItem('pokerSavedSessions', JSON.stringify(savedSessions.value));

    isActive.value = false;
    isOnBreak.value = false;
    clearInterval(sessionTimerInterval);
    clearInterval(breakTimerInterval);
    sessionTimerInterval = null;
    breakTimerInterval = null;
    elapsedTime.value = 0;
    breakElapsedTime.value = 0;
  }
  
  function deleteSession(sessionId) {
    savedSessions.value = savedSessions.value.filter(session => session.id !== sessionId);
    localStorage.setItem('pokerSavedSessions', JSON.stringify(savedSessions.value));
  }

  return {
    isActive, elapsedTime, isOnBreak, breakElapsedTime, playerCount, blinds, 
    location, currency, initialStack, savedSessions, totalRebuys, totalExpenses,
    summaryDateFilter, // <-- Exportar estado del filtro
    totalNetProfit,
    averageBuyIn,
    averageCashOut,
    sessionCount,
    totalHoursPlayed,
    averageHoursPlayed,
    averageBreakDuration,
    winRatePerHour,
    roi,
    winningDays,
    losingDays,
    bestDay,
    worstDay,
    winningStreak,
    averageRebuys,
    totalAllExpenses,
    startSession, startBreak, endBreak, stopAndSaveSession, deleteSession,
    addRebuy, addExpense,
    setSummaryDateFilter, // <-- Exportar acción del filtro
  };
});

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useSettingsStore.js ---

import { defineStore } from 'pinia';
import { ref, watch } from 'vue';
import i18n from '../i18n'; // Importamos la instancia de i18n

export const useSettingsStore = defineStore('settings', () => {
  const locale = ref(localStorage.getItem('locale') || 'es');

  function setLocale(newLocale) {
    locale.value = newLocale;
  }

  // Observador que actualiza la librería i18n y el localStorage cuando cambia el idioma
  watch(locale, (newLocale) => {
    i18n.global.locale.value = newLocale;
    localStorage.setItem('locale', newLocale);
  });

  return {
    locale,
    setLocale,
  };
});

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/store/useTripStore.js ---

import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { v4 as uuidv4 } from 'uuid';

export const useTripStore = defineStore('trip', () => {
  // --- STATE ---
  const savedTrips = ref(JSON.parse(localStorage.getItem('pokerSavedTrips')) || []);
  const currentTripId = ref(null); // Para saber si estamos editando un viaje existente

  // --- STATE DE PLANIFICACIÓN ---
  const playerCount = ref(4);
  const city = ref('');
  const casino = ref('');
  const players = ref([]);
  const currency = ref('$');
  const repartoType = ref('participation');

  // --- ESTADO DE SEGUIMIENTO ---
  const isTripActive = ref(false);
  const tripDays = ref([]);
  const dailyResults = ref({});

  // --- COMPUTED ---
  const collectiveBankroll = computed(() => {
    return players.value.reduce((sum, player) => sum + (player.individualBankroll || 0), 0);
  });

  const tripTotalProfit = computed(() => {
    return Object.values(dailyResults.value).reduce((total, dayResults) => {
      const dayTotal = Object.values(dayResults).reduce((daySum, playerData) => daySum + (playerData.result || 0), 0);
      return total + dayTotal;
    }, 0);
  });
  
  const totalParticipation = computed(() => {
    const sum = players.value.reduce((sum, player) => sum + (parseFloat(player.participation) || 0), 0);
    return parseFloat(sum.toFixed(2));
  });

  const playerTotalHours = computed(() => {
    const totals = {};
    players.value.forEach(player => { totals[player.id] = 0; });
    for (const day in dailyResults.value) {
      for (const playerId in dailyResults.value[day]) {
        if (totals[playerId] !== undefined) {
          totals[playerId] += dailyResults.value[day][playerId].hours || 0;
        }
      }
    }
    return totals;
  });

  const tripTotalHours = computed(() => {
    return Object.values(playerTotalHours.value).reduce((sum, hours) => sum + hours, 0);
  });

  const playerTotals = computed(() => {
    const totals = {};
    players.value.forEach(player => { totals[player.id] = 0; });
    for (const day in dailyResults.value) {
      for (const playerId in dailyResults.value[day]) {
        if (totals[playerId] !== undefined) {
          totals[playerId] += dailyResults.value[day][playerId].result || 0;
        }
      }
    }
    return totals;
  });
  
  const playerFinalShares = computed(() => {
    const finalBankroll = collectiveBankroll.value + tripTotalProfit.value;
    const shares = {};

    if (repartoType.value === 'hours') {
      if (tripTotalHours.value === 0) return shares; // Evitar división por cero
      players.value.forEach(player => {
        const playerHours = playerTotalHours.value[player.id] || 0;
        const hourPercentage = (playerHours / tripTotalHours.value) * 100;
        const shareAmount = (hourPercentage / 100) * finalBankroll;
        shares[player.id] = isNaN(shareAmount) ? 0 : shareAmount;
      });
    } else { // Reparto por participación
      players.value.forEach(player => {
        const participationPercent = parseFloat(player.participation) || 0;
        const shareAmount = (participationPercent / 100) * finalBankroll;
        shares[player.id] = isNaN(shareAmount) ? 0 : shareAmount;
      });
    }
    return shares;
  });

  const playerAverageWinRates = computed(() => {
    const rates = {};
    players.value.forEach(player => {
      const totalProfit = playerTotals.value[player.id];
      const totalHours = playerTotalHours.value[player.id];
      rates[player.id] = totalHours > 0 ? totalProfit / totalHours : 0;
    });
    return rates;
  });

  const tripAverageWinRate = computed(() => {
    return tripTotalHours.value > 0 ? tripTotalProfit.value / tripTotalHours.value : 0;
  });

  // --- ACTIONS ---
  
  function saveCurrentTrip() {
    const tripData = {
      city: city.value,
      casino: casino.value,
      players: players.value,
      currency: currency.value,
      repartoType: repartoType.value,
      isTripActive: isTripActive.value,
      tripDays: tripDays.value,
      dailyResults: dailyResults.value,
    };

    if (currentTripId.value) { // Actualizar un viaje existente
      const index = savedTrips.value.findIndex(t => t.id === currentTripId.value);
      if (index !== -1) {
        savedTrips.value[index] = { ...savedTrips.value[index], ...tripData };
      }
    } else { // Guardar un viaje nuevo
      const newTrip = { id: uuidv4(), date: new Date().toLocaleDateString(), ...tripData };
      currentTripId.value = newTrip.id;
      savedTrips.value.unshift(newTrip);
    }
    localStorage.setItem('pokerSavedTrips', JSON.stringify(savedTrips.value));
    alert('¡Viaje guardado con éxito!'); // Feedback para el usuario
  }
  
  function loadTrip(tripId) {
    const tripToLoad = savedTrips.value.find(t => t.id === tripId);
    if (!tripToLoad) return;
    
    currentTripId.value = tripToLoad.id;
    playerCount.value = tripToLoad.players.length;
    city.value = tripToLoad.city;
    casino.value = tripToLoad.casino;
    players.value = tripToLoad.players;
    currency.value = tripToLoad.currency;
    repartoType.value = tripToLoad.repartoType;
    isTripActive.value = tripToLoad.isTripActive;
    tripDays.value = tripToLoad.tripDays;
    dailyResults.value = tripToLoad.dailyResults;
  }

  function deleteTrip(tripId) {
    savedTrips.value = savedTrips.value.filter(t => t.id !== tripId);
    localStorage.setItem('pokerSavedTrips', JSON.stringify(savedTrips.value));
  }
  
  function resetCurrentTrip() {
    currentTripId.value = null;
    playerCount.value = 4;
    city.value = '';
    casino.value = '';
    players.value = [];
    currency.value = '$';
    repartoType.value = 'participation';
    isTripActive.value = false;
    tripDays.value = [];
    dailyResults.value = {};
    setPlayerCount(4);
  }

  function recalculateParticipations() {
    const totalBank = collectiveBankroll.value;
    if (totalBank === 0) {
      players.value.forEach(player => { player.participation = 0; });
      return;
    }
    players.value.forEach(player => {
      const bankroll = player.individualBankroll || 0;
      player.participation = parseFloat(((bankroll / totalBank) * 100).toFixed(2));
    });
    const currentTotal = totalParticipation.value;
    const difference = 100 - currentTotal;
    if (difference !== 0 && players.value.length > 0) {
      players.value[0].participation = parseFloat((players.value[0].participation + difference).toFixed(2));
    }
  }
  
  function setPlayerCount(newCount) {
    const currentCount = players.value.length;
    if (newCount > currentCount) {
      for (let i = currentCount; i < newCount; i++) {
        players.value.push({
          id: uuidv4(),
          name: `Jugador ${i + 1}`,
          individualBankroll: 1000,
          participation: 0,
        });
      }
    } else if (newCount < currentCount) {
      players.value.splice(newCount);
    }
    playerCount.value = newCount;
    recalculateParticipations();
  }

  function updatePlayerBankroll(playerId, value) {
    const player = players.value.find(p => p.id === playerId);
    if (player) {
      player.individualBankroll = parseFloat(value) || 0;
      recalculateParticipations();
    }
  }

  function startTrip() { isTripActive.value = true; }

  function addTripDay(dateString) {
    if (!dateString) return;
    if (!tripDays.value.includes(dateString)) {
      tripDays.value.push(dateString);
      tripDays.value.sort();
      dailyResults.value[dateString] = {};
      players.value.forEach(p => {
        dailyResults.value[dateString][p.id] = { result: 0, hours: 0, stake: '' };
      });
    }
  }

  function updatePlayerDailyData(day, playerId, field, value) {
    if (dailyResults.value[day]?.[playerId]) {
      const finalValue = (field === 'result' || field === 'hours') ? parseFloat(value) || 0 : value;
      dailyResults.value[day][playerId][field] = finalValue;
    }
  }

  return {
    savedTrips, currentTripId, playerCount, city, casino, players, currency, repartoType,
    isTripActive, tripDays, dailyResults,
    collectiveBankroll, tripTotalProfit, totalParticipation, playerFinalShares,
    playerTotalHours, tripTotalHours, playerAverageWinRates, tripAverageWinRate, playerTotals,
    saveCurrentTrip, loadTrip, deleteTrip, resetCurrentTrip,
    setPlayerCount, startTrip, addTripDay, updatePlayerDailyData, updatePlayerBankroll,
  };
});

-----------------------------------------------------

--- INICIO DEL ARCHIVO: src/styles.css ---

:root {
  --table-green: #28563a;
  --table-blue: #3a4c8a;
  --table-red: #8a3a3a;
  --bg-color: #1a202c;
  --text-color: #e2e8f0;
  --border-color: #4a5568;
  --primary-color: #4299e1;
  --card-bg: #ffffff;

  /* --- TAMAÑOS DE CARTAS --- */
  /* CAMBIO: Cartas del board igualadas a las del jugador */
  --board-card-width: 70px;
  --board-card-height: 98px;
  /* Cartas de los jugadores */
  --player-card-width: 70px;
  --player-card-height: 98px;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica,
    Arial, sans-serif;
  margin: 0;
  background-color: var(--bg-color);
  color: var(--text-color);
  overscroll-behavior: none;
}

#app {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
}

button {
  background-color: var(--primary-color);
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s;
}

button:hover {
  background-color: #2b6cb0;
}

button:disabled {
  background-color: #4a5568;
  cursor: not-allowed;
}

input,
select {
  padding: 8px;
  border-radius: 5px;
  border: 1px solid var(--border-color);
  background-color: #2d3748;
  color: var(--text-color);
}

------------------------------------------

--- INICIO DEL ARCHIVO: src/views/ChartsView.vue ---

<template>
  <div class="charts-container">
    <div class="header">
      <h2>{{ $t('charts.title') }}</h2>
      
      <div class="controls-wrapper">
        <!-- Selector de rango de tiempo -->
        <div class="filter-controls">
          <label for="time-range">Mostrar:</label>
          <select id="time-range" v-model="chartsStore.timeRange">
            <option value="all">Todo</option>
            <option value="7d">Última Semana</option>
            <option value="1m">Último Mes</option>
            <option value="3m">Últimos 3 Meses</option>
            <option value="6m">Últimos 6 Meses</option>
            <option value="1y">Último Año</option>
          </select>
        </div>

        <!-- ===== BOTÓN NUEVO PARA CAMBIAR TIPO DE GRÁFICO ===== -->
        <button @click="chartsStore.toggleChartType()" class="toggle-chart-btn" :title="`Cambiar a gráfico de ${chartsStore.chartType === 'line' ? 'barras' : 'líneas'}`">
          <!-- Icono de gráfico de barras (se muestra si el gráfico activo es el de líneas) -->
          <svg v-if="chartsStore.chartType === 'line'" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 013 19.875v-6.75zM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V8.625zM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 01-1.125-1.125V4.125z" />
          </svg>
          <!-- Icono de gráfico de líneas (se muestra si el gráfico activo es el de barras) -->
          <svg v-else xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 18L9 11.25l4.306 4.307a11.95 11.95 0 015.814-5.519l2.74-1.22m0 0l-3.75-2.25M21 12l-3.75 2.25" />
          </svg>
        </button>
      </div>
    </div>
    
    <div v-if="sessionStore.savedSessions.length < 2" class="no-data-message">
      {{ $t('charts.noData') }}
    </div>
    <div v-else class="chart-wrapper">
      <SessionChart />
    </div>
  </div>
</template>

<script setup>
import { useSessionStore } from '../store/useSessionStore';
import { useChartsStore } from '../store/useChartsStore';
import SessionChart from '../components/SessionChart.vue';

const sessionStore = useSessionStore();
const chartsStore = useChartsStore();
</script>

<style scoped>
.charts-container {
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  flex-wrap: wrap;
  gap: 1rem;
}
h2 {
  margin: 0;
  font-size: 2rem;
}
.controls-wrapper {
  display: flex;
  align-items: center;
  gap: 1.5rem;
}
.filter-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}
.filter-controls label {
  font-weight: bold;
  color: #a0aec0;
}
.filter-controls select {
  padding: 8px 12px;
  font-size: 1rem;
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: white;
}
.toggle-chart-btn {
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s;
}
.toggle-chart-btn:hover {
  background-color: #2D3748;
}
.toggle-chart-btn svg {
  width: 24px;
  height: 24px;
  color: white;
}
.no-data-message {
  text-align: center;
  font-size: 1.2rem;
  color: #a0aec0;
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
}
.chart-wrapper {
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
}
</style>

----------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/CommunityView.vue ---

<template>
  <div class="trip-planner-container">
    <!-- Panel de Planificación -->
    <div v-if="!tripStore.isTripActive" class="planner-panel">
      <h2>Planificador de Viajes de Poker</h2>
      <div class="form-grid">
        <div class="form-column">
          <div class="config-item"><label for="trip-city">Ciudad</label><input id="trip-city" type="text" v-model="tripStore.city" placeholder="Ej: Las Vegas"></div>
          <div class="config-item"><label for="trip-casino">Casino / Club</label><input id="trip-casino" type="text" v-model="tripStore.casino" placeholder="Ej: Bellagio"></div>
          
          <!-- SELECTOR DE MONEDA ACTUALIZADO CON LA LISTA COMPLETA -->
          <div class="config-item">
            <label for="trip-currency">Moneda</label>
            <select id="trip-currency" v-model="tripStore.currency">
              <option v-for="c in currencies" :key="c.symbol" :value="c.symbol">
                {{ c.symbol }} - {{ c.name }}
              </option>
            </select>
          </div>

          <div class="config-item"><label for="player-count">Número de Jugadores</label><select id="player-count" v-model.number="tripStore.playerCount" @change="tripStore.setPlayerCount(tripStore.playerCount)"><option v-for="n in 14" :key="n" :value="n + 1">{{ n + 1 }} Jugadores</option></select></div>
          <div class="config-item collective-bankroll"><label>Banca Colectiva (Total)</label><div class="calculated-value">{{ tripStore.collectiveBankroll }} {{ tripStore.currency }}</div></div>
        </div>
        <div class="form-column">
          <div class="config-item">
            <label for="reparto-type">Tipo de Reparto Final</label>
            <select id="reparto-type" v-model="tripStore.repartoType">
              <option value="participation">Reparto por Aportación</option>
              <option value="hours">Reparto por Horas Jugadas</option>
            </select>
          </div>
          <div class="config-item">
            <label>Nombres y Aportación</label>
            <div class="player-list">
              <div v-for="player in tripStore.players" :key="player.id" class="player-entry">
                <input type="text" v-model="player.name" class="player-name-input" placeholder="Nombre">
                <div v-if="tripStore.repartoType === 'participation'" class="participation-input-group">
                  <input type="number" :value="player.individualBankroll" @input="tripStore.updatePlayerBankroll(player.id, $event.target.value)" class="player-participation-input" min="0">
                  <span class="currency-symbol">{{ tripStore.currency }}</span>
                  <span class="participation-percentage">({{ player.participation.toFixed(2) }}%)</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="actions-footer"><button class="start-trip-btn" @click="tripStore.startTrip()">Iniciar Viaje</button></div>
    </div>

    <!-- Panel de Seguimiento por Días -->
    <div v-else class="tracking-panel">
      <header class="tracking-header">
        <h2>Seguimiento del Viaje</h2>
        <div class="trip-info"><span><strong>Destino:</strong> {{ tripStore.city || 'N/A' }}, {{ tripStore.casino || 'N/A' }}</span></div>
        <div class="trip-actions-header">
          <button @click="handleSaveTrip()" class="save-trip-btn">Guardar Viaje</button>
          <button @click="tripStore.resetCurrentTrip()" class="new-trip-btn">Nuevo Viaje</button>
        </div>
        <div class="add-day-form">
          <input type="date" v-model="newDayDateString" class="date-input">
          <button @click="confirmAddDay" class="add-day-btn">Añadir Día</button>
        </div>
      </header>
      
      <div class="days-container">
        <div v-for="day in tripStore.tripDays" :key="day" class="day-card">
          <h3>Día: {{ new Date(day + 'T12:00:00').toLocaleDateString() }}</h3>
          <div class="player-results-list">
            <div v-for="player in tripStore.players" :key="player.id" class="player-session-details">
              <span class="player-name">{{ player.name }}</span>
              <div class="player-inputs-grid">
                <div class="input-group"><label>Resultado ({{ tripStore.currency }})</label><input type="number" :value="tripStore.dailyResults[day]?.[player.id]?.result" @input="tripStore.updatePlayerDailyData(day, player.id, 'result', $event.target.value)"></div>
                <div class="input-group"><label>Horas</label><input type="number" :value="tripStore.dailyResults[day]?.[player.id]?.hours" @input="tripStore.updatePlayerDailyData(day, player.id, 'hours', $event.target.value)"></div>
                <div class="input-group"><label>Stake</label><input type="text" :value="tripStore.dailyResults[day]?.[player.id]?.stake" @input="tripStore.updatePlayerDailyData(day, player.id, 'stake', $event.target.value)" placeholder="1/2"></div>
                <div class="input-group calculated"><label>{{ tripStore.currency }} / Hora</label><span :class="getResultClass(calculateWinRate(tripStore.dailyResults[day]?.[player.id]))">{{ calculateWinRate(tripStore.dailyResults[day]?.[player.id]).toFixed(2) }}</span></div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <div v-if="tripStore.tripDays.length > 0" class="totals-section">
        <h3>Resultados Acumulados</h3>
        <div class="player-totals-list">
           <div v-for="player in tripStore.players" :key="player.id" class="player-total-item-detailed">
              <span class="player-name">
                {{ player.name }}
                <span v-if="tripStore.repartoType === 'participation'">({{ player.participation || 0 }}%)</span>
              </span>
              <div class="player-financials">
                <div class="financial-item"><label>Horas Totales</label><span class="value">{{ tripStore.playerTotalHours[player.id]?.toFixed(1) || '0.0' }} h</span></div>
                <div class="financial-item"><label>Media {{tripStore.currency}}/h</label><span class="value" :class="getResultClass(tripStore.playerAverageWinRates[player.id])">{{ tripStore.playerAverageWinRates[player.id]?.toFixed(2) || '0.00' }}</span></div>
                <div class="financial-item"><label>P/L Individual</label><span class="value" :class="getResultClass(tripStore.playerTotals[player.id])">{{ tripStore.playerTotals[player.id]?.toFixed(2) || '0.00' }} {{ tripStore.currency }}</span></div>
                <div class="financial-item"><label>{{ repartoLabel }}</label><span class="value">{{ tripStore.playerFinalShares[player.id]?.toFixed(2) || '0.00' }} {{ tripStore.currency }}</span></div>
              </div>
            </div>
        </div>
        <div class="trip-totals-summary">
          <div class="trip-total-item"><label>Horas Totales del Viaje</label><span class="trip-total-value">{{ tripStore.tripTotalHours.toFixed(1) }} h</span></div>
          <div class="trip-total-item"><label>Media {{tripStore.currency}}/h del Viaje</label><span class="trip-total-value" :class="getResultClass(tripStore.tripAverageWinRate)">{{ tripStore.tripAverageWinRate.toFixed(2) }}</span></div>
          <div class="trip-total-item main-total"><label>Beneficio Total del Viaje</label><span class="trip-total-value" :class="getResultClass(tripStore.tripTotalProfit)">{{ tripStore.tripTotalProfit.toFixed(2) }} {{ tripStore.currency }}</span></div>
        </div>
      </div>
    </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Viaje guardado con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { onMounted, ref, computed } from 'vue';
import { useTripStore } from '../store/useTripStore';

const tripStore = useTripStore();
const showToast = ref(false);

// --- LISTA AMPLIADA DE LAS 30 MONEDAS MÁS USADAS ---
const currencies = ref([
  { symbol: '$', name: 'USD - Dólar estadounidense' },
  { symbol: '€', name: 'EUR - Euro' },
  { symbol: '¥', name: 'JPY - Yen japonés' },
  { symbol: '£', name: 'GBP - Libra esterlina' },
  { symbol: 'A$', name: 'AUD - Dólar australiano' },
  { symbol: 'C$', name: 'CAD - Dólar canadiense' },
  { symbol: 'CHF', name: 'CHF - Franco suizo' },
  { symbol: 'CN¥', name: 'CNY - Yuan chino' },
  { symbol: 'SEK', name: 'SEK - Corona sueca' },
  { symbol: 'NZ$', name: 'NZD - Dólar neozelandés' },
  { symbol: 'Mex$', name: 'MXN - Peso mexicano' },
  { symbol: 'S$', name: 'SGD - Dólar de Singapur' },
  { symbol: 'HK$', name: 'HKD - Dólar de Hong Kong' },
  { symbol: 'NOK', name: 'NOK - Corona noruega' },
  { symbol: '₩', name: 'KRW - Won surcoreano' },
  { symbol: '₺', name: 'TRY - Lira turca' },
  { symbol: '₽', name: 'RUB - Rublo ruso' },
  { symbol: '₹', name: 'INR - Rupia india' },
  { symbol: 'R$', name: 'BRL - Real brasileño' },
  { symbol: 'R', name: 'ZAR - Rand sudafricano' },
  { symbol: 'zł', name: 'PLN - Zloty polaco' },
  { symbol: '฿', name: 'THB - Baht tailandés' },
  { symbol: 'Rp', name: 'IDR - Rupia indonesia' },
  { symbol: 'Ft', name: 'HUF - Forinto húngaro' },
  { symbol: 'Kč', name: 'CZK - Corona checa' },
  { symbol: '₪', name: 'ILS - Nuevo séquel israelí' },
  { symbol: 'CLP$', name: 'CLP - Peso chileno' },
  { symbol: '₱', name: 'PHP - Peso filipino' },
  { symbol: 'د.إ', name: 'AED - Dírham de los EAU' },
  { symbol: 'Col$', name: 'COP - Peso colombiano' }
]);

const newDayDateString = ref(new Date().toISOString().split('T')[0]);

const repartoLabel = computed(() => {
  return tripStore.repartoType === 'hours' ? 'Reparto Final (x Horas)' : 'Reparto Final (x Aport.)';
});

function getResultClass(result) {
  if (result === undefined || result === null || result === 0) return 'even';
  return result > 0 ? 'profit' : 'loss';
}

function calculateWinRate(playerData) {
  if (!playerData || !playerData.hours || playerData.hours <= 0) { return 0; }
  return playerData.result / playerData.hours;
}

function confirmAddDay() {
  if (newDayDateString.value) { tripStore.addTripDay(newDayDateString.value); }
}

function handleSaveTrip() {
  tripStore.saveCurrentTrip();
  showToast.value = true;
  setTimeout(() => {
    showToast.value = false;
  }, 3000);
}

onMounted(() => {
  if (tripStore.players.length !== tripStore.playerCount) { 
    tripStore.setPlayerCount(tripStore.playerCount); 
  }
});
</script>

<style scoped>
/* --- (Estilos existentes sin cambios) --- */
.trip-planner-container { display: flex; justify-content: center; padding: 3rem; }
.planner-panel, .tracking-panel { width: 100%; max-width: 1000px; background-color: #2d3748; border-radius: 12px; padding: 2.5rem; }
h2 { margin-top: 0; margin-bottom: 2rem; text-align: center; font-size: 2.2rem; }
h3 { font-size: 1.6rem; color: #cbd5e0; border-bottom: 1px solid #4a5568; padding-bottom: 0.75rem; margin-bottom: 1.5rem; }
.form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 3rem; }
.form-column { display: flex; flex-direction: column; gap: 1.5rem; }
.config-item { display: flex; flex-direction: column; gap: 10px; }
.config-item label { font-weight: bold; font-size: 1.2rem; color: #a0aec0; }
.config-item input, .config-item select { padding: 15px; font-size: 1.1rem; border-radius: 6px; }
.collective-bankroll .calculated-value { background-color: #1a202c; padding: 15px; font-size: 1.5rem; font-weight: bold; border-radius: 6px; text-align: center; color: #68d391; }
.player-list { display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto; padding-right: 10px; }
.actions-footer { margin-top: 2rem; display: flex; justify-content: center; }
.start-trip-btn { background-color: #38a169; color: white; font-size: 1.4rem; padding: 15px 40px; border-radius: 8px; font-weight: bold; }
.player-entry { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
.player-name-input { width: 100%; }
.participation-input-group { display: flex; align-items: center; background-color: #2d3748; border: 1px solid var(--border-color); border-radius: 6px; padding-left: 10px; }
.player-participation-input { border: none; background: transparent; width: 100px; -moz-appearance: textfield; font-size: 1.1rem; color: var(--text-color); }
.player-participation-input::-webkit-outer-spin-button, .player-participation-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.participation-input-group .currency-symbol { color: #a0aec0; padding: 0 5px; }
.participation-input-group .participation-percentage { color: #a0aec0; font-size: 0.9rem; padding-right: 10px; min-width: 60px; text-align: right;}
.tracking-header { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin-bottom: 2rem; }
.trip-info { font-size: 1.2rem; }
.trip-actions-header { display: flex; gap: 1rem; }
.save-trip-btn { background-color: #38a169; color: white; padding: 12px 25px; font-size: 1.1rem; font-weight: bold; border-radius: 6px; }
.new-trip-btn { background-color: #718096; padding: 12px 25px; font-size: 1.1rem; font-weight: bold; border-radius: 6px; }
.add-day-form { display: flex; align-items: center; gap: 1rem; background-color: #1a202c; padding: 1rem; border-radius: 8px; }
.date-input { padding: 12px; font-size: 1.1rem; border-radius: 6px; border: 1px solid var(--border-color); background-color: #2d3748; color: var(--text-color); color-scheme: dark; }
.add-day-btn { background-color: var(--primary-color); padding: 12px 25px; font-size: 1.1rem; font-weight: bold; border-radius: 6px; }
.days-container { display: flex; flex-direction: column; gap: 2rem; }
.day-card { background-color: #1a202c; padding: 1.5rem; border-radius: 8px; border: 1px solid #4a5568; }
.player-results-list { display: flex; flex-direction: column; gap: 1.5rem; }
.player-session-details { border-bottom: 1px solid #3a475c; padding-bottom: 1.5rem; }
.player-session-details:last-child { border-bottom: none; padding-bottom: 0; }
.player-name { font-size: 1.4rem; font-weight: bold; margin-bottom: 1rem; display: block; }
.player-inputs-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; align-items: flex-end; }
.input-group { display: flex; flex-direction: column; gap: 8px; }
.input-group label { font-size: 0.9rem; color: #a0aec0; font-weight: bold; }
.input-group input { width: 100%; padding: 10px; font-size: 1.1rem; border-radius: 4px; }
.input-group.calculated span { font-size: 1.4rem; font-weight: bold; padding: 8px 10px; text-align: center; }
.totals-section { margin-top: 3rem; background-color: #1a202c; padding: 1.5rem; border-radius: 8px; }
.player-totals-list { display: flex; flex-direction: column; gap: 1rem; margin-bottom: 2rem; }
.player-total-item-detailed { padding: 1rem; border: 1px solid #3a475c; border-radius: 6px; }
.player-total-item-detailed > .player-name { font-size: 1.3rem; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #3a475c; }
.player-financials { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
.financial-item { display: flex; flex-direction: column; }
.financial-item label { font-size: 0.9rem; color: #a0aec0; margin-bottom: 0.25rem; }
.financial-item .value { font-weight: bold; font-size: 1.2rem; }
.trip-totals-summary { display: flex; flex-direction: column; gap: 0.75rem; border-top: 2px solid #4a5568; padding-top: 1.5rem; }
.trip-total-item { display: flex; justify-content: space-between; font-size: 1.1rem; }
.trip-total-item.main-total { font-size: 1.6rem; font-weight: bold; }
.trip-total-value { font-weight: bold; }
.profit { color: #68d391; }
.loss { color: #fc8181; }
.even { color: #e2e8f0; }

/* Toast Styles */
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}

.success-toast {
  background-color: #38a169;
  color: white;
}

.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}

.toast-message {
  font-size: 1rem;
  font-weight: bold;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
</style>

-------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/CurrentHandView.vue ---

<template>
  <div class="view-container">
    <div v-if="!handIsActive" class="configuration-panel">
      <h2>Configuración de la Mano</h2>

      <div class="config-item">
        <label for="player-count">Número de Jugadores:</label>
        <select id="player-count" v-model.number="selectedPlayers">
          <option v-for="n in 8" :key="n" :value="n + 1">
            {{ n + 1 }} Jugadores
          </option>
        </select>
      </div>
      
      <div class="blinds-container">
        <div class="config-item">
          <label for="sb-input">Ciega Pequeña:</label>
          <input id="sb-input" type="number" v-model.number="sbInput" min="1">
        </div>
        <div class="config-item">
          <label for="bb-input">Ciega Grande:</label>
          <input id="bb-input" type="number" v-model.number="bbInput" min="1">
        </div>
      </div>
      
      <!-- SELECTOR DE MONEDA ACTUALIZADO CON 30 OPCIONES -->
      <div class="config-item">
        <label for="currency-select">Moneda:</label>
        <select id="currency-select" v-model="selectedCurrency">
          <option v-for="currency in currencies" :key="currency.symbol" :value="currency.symbol">
            {{ currency.symbol }} - {{ currency.name }}
          </option>
        </select>
      </div>

      <!-- SELECTOR DE REGLA ESPECIAL -->
      <div class="config-item">
        <label for="special-rule-select">Regla Especial:</label>
        <select id="special-rule-select" v-model="selectedSpecialRule">
          <option value="Ninguno">Ninguno</option>
          <option value="Straddle">Straddle</option>
          <option value="Mississippi">Mississippi</option>
          <option value="Bomb Pot">Bomb Pot</option>
        </select>
      </div>

      <!-- SELECTOR DE BOMB POT BB (solo visible cuando Bomb Pot está seleccionado) -->
      <div v-if="selectedSpecialRule === 'Bomb Pot'" class="config-item">
        <label for="bomb-pot-bb-select">Bomb Pot BB:</label>
        <select id="bomb-pot-bb-select" v-model="selectedBombPotBB">
          <option value="2">2bb</option>
          <option value="3">3bb</option>
          <option value="4">4bb</option>
          <option value="5">5bb</option>
        </select>
      </div>

      <button @click="loadHandClicked">Iniciar Mano</button>
    </div>

    <PokerTable v-else />

    <ConfigurationModal
      v-if="showPositionModal"
      :positions="availablePositions"
      @confirm="handlePositionSelected"
    />

    <CardPicker v-if="gameStore.isCardPickerOpen" />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue';
import { useGameStore } from '../store/game';
import PokerTable from '../components/PokerTable.vue';
import ConfigurationModal from '../components/ConfigurationModal.vue';
import CardPicker from '../components/CardPicker.vue';

const gameStore = useGameStore();
const handIsActive = computed(() => gameStore.gamePhase !== 'setup');

const selectedPlayers = ref(6);
const sbInput = ref(1);
const bbInput = ref(2);
const selectedCurrency = ref('$'); // Moneda por defecto
const selectedSpecialRule = ref('Ninguno'); // Regla especial por defecto
const selectedBombPotBB = ref(2); // Valor por defecto para Bomb Pot

// --- LISTA AMPLIADA DE LAS 30 MONEDAS MÁS USADAS ---
const currencies = ref([
  { symbol: '$', name: 'USD - Dólar estadounidense' },
  { symbol: '€', name: 'EUR - Euro' },
  { symbol: '¥', name: 'JPY - Yen japonés' },
  { symbol: '£', name: 'GBP - Libra esterlina' },
  { symbol: 'A$', name: 'AUD - Dólar australiano' },
  { symbol: 'C$', name: 'CAD - Dólar canadiense' },
  { symbol: 'CHF', name: 'CHF - Franco suizo' },
  { symbol: 'CN¥', name: 'CNY - Yuan chino' },
  { symbol: 'SEK', name: 'SEK - Corona sueca' },
  { symbol: 'NZ$', name: 'NZD - Dólar neozelandés' },
  { symbol: 'Mex$', name: 'MXN - Peso mexicano' },
  { symbol: 'S$', name: 'SGD - Dólar de Singapur' },
  { symbol: 'HK$', name: 'HKD - Dólar de Hong Kong' },
  { symbol: 'NOK', name: 'NOK - Corona noruega' },
  { symbol: '₩', name: 'KRW - Won surcoreano' },
  { symbol: '₺', name: 'TRY - Lira turca' },
  { symbol: '₽', name: 'RUB - Rublo ruso' },
  { symbol: '₹', name: 'INR - Rupia india' },
  { symbol: 'R$', name: 'BRL - Real brasileño' },
  { symbol: 'R', name: 'ZAR - Rand sudafricano' },
  { symbol: 'zł', name: 'PLN - Zloty polaco' },
  { symbol: '฿', name: 'THB - Baht tailandés' },
  { symbol: 'Rp', name: 'IDR - Rupia indonesia' },
  { symbol: 'Ft', name: 'HUF - Forinto húngaro' },
  { symbol: 'Kč', name: 'CZK - Corona checa' },
  { symbol: '₪', name: 'ILS - Nuevo séquel israelí' },
  { symbol: 'CLP$', name: 'CLP - Peso chileno' },
  { symbol: '₱', name: 'PHP - Peso filipino' },
  { symbol: 'د.إ', name: 'AED - Dírham de los EAU' },
  { symbol: 'Col$', name: 'COP - Peso colombiano' }
]);

const showPositionModal = ref(false);

const availablePositions = computed(() => {
  return getPositionsForCount(selectedPlayers.value);
});

function loadHandClicked() {
  showPositionModal.value = true;
}

function handlePositionSelected(heroPosition) {
  showPositionModal.value = false;
  gameStore.setupNewHand(
    selectedPlayers.value,
    heroPosition,
    selectedCurrency.value,
    sbInput.value,
    bbInput.value,
    selectedSpecialRule.value,
    selectedSpecialRule.value === 'Bomb Pot' ? selectedBombPotBB.value : null
  );
}

function getPositionsForCount(numPlayers) {
  if (numPlayers === 2) { return ['BTN / SB', 'BB']; }
  if (numPlayers === 3) { return ['BTN', 'SB', 'BB']; }
  if (numPlayers === 4) { return ['BTN', 'SB', 'BB', 'CO']; }
  if (numPlayers === 5) { return ['BTN', 'SB', 'BB', 'MP', 'CO']; }
  if (numPlayers === 6) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'CO']; }
  if (numPlayers === 7) { return ['BTN', 'SB', 'BB', 'UTG', 'MP', 'HJ', 'CO']; }
  if (numPlayers === 8) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'HJ', 'CO']; }
  if (numPlayers === 9) { return ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'MP', 'LJ', 'HJ', 'CO']; }
  return [];
}

function handleKeyDown(event) {
  if (!handIsActive.value) return;
  if (document.activeElement.tagName === 'INPUT' && (event.key === 'ArrowRight' || event.key === 'ArrowLeft')) {
    return;
  }
  if (event.key === 'ArrowRight') gameStore.navigateHistory(1);
  else if (event.key === 'ArrowLeft') gameStore.navigateHistory(-1);
}

onMounted(() => {
  window.addEventListener('keydown', handleKeyDown);
});

onUnmounted(() => {
  window.removeEventListener('keydown', handleKeyDown);
  gameStore.pauseReplay();
});
</script>

<style scoped>
.view-container {
  width: 100%;
}
.configuration-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 30px;
  padding: 3.5rem;
  max-width: 500px;
  margin: 5rem auto;
  background-color: #2d3748;
  border-radius: 12px;
}
h2 {
  font-size: 2.5rem;
  margin-bottom: 10px;
}
.config-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}
label {
  font-weight: bold;
  font-size: 1.2rem;
}
select, input[type="number"] {
  padding: 15px;
  font-size: 1.2rem;
  width: 250px;
  text-align: center;
  box-sizing: border-box;
  border-radius: 8px;
}
/* Aumentamos el ancho del selector de moneda para que quepa el texto */
#currency-select {
  width: 350px;
  text-align: left;
}
.blinds-container {
  display: flex;
  gap: 20px;
}
.blinds-container .config-item {
  width: auto;
}
.blinds-container input {
  width: 150px;
}
button {
  padding: 18px 35px;
  font-size: 1.4rem;
  font-weight: bold;
  border-radius: 8px;
  margin-top: 10px;
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/LiveSessionView.vue ---

<template>
  <div class="live-session-container">
    <div class="session-panel">

      <!-- WIDGET DEL TEMPORIZADOR -->
      <div class="widget timer-widget" :class="{ 'on-break': sessionStore.isOnBreak }">
        <div class="widget-header">
          <span class="status-indicator"></span>
          <span>{{ sessionStore.isOnBreak ? 'EN DESCANSO' : (sessionStore.isActive ? 'SESIÓN ACTIVA' : 'SESIÓN DETENIDA') }}</span>
        </div>
        <div class="timer-display">
          {{ formattedTime }}
        </div>
      </div>

      <!-- WIDGET DE ACCIONES RÁPIDAS (solo visible durante la sesión) -->
      <div v-if="sessionStore.isActive && !sessionStore.isOnBreak" class="widget actions-widget">
        <div class="widget-header">
          <span>ACCIONES RÁPIDAS</span>
        </div>
        <div class="live-actions">
          <div class="action-group">
            <input type="number" v-model.number="rebuyAmount" placeholder="Monto Recarga">
            <button @click="handleAddRebuy">Añadir Recarga</button>
          </div>
          <div class="action-group">
            <input type="number" v-model.number="tipAmount" placeholder="Propina">
            <button @click="handleAddTip">Tip Dealer</button>
          </div>
          <div class="action-group">
            <input type="number" v-model.number="expenseAmount" placeholder="Gasto">
            <button @click="handleAddExpense">Consumición</button>
          </div>
        </div>
      </div>

      <!-- WIDGET DE CONFIGURACIÓN -->
      <div class="widget config-widget">
         <div class="widget-header">
          <span>CONFIGURACIÓN DE LA PARTIDA</span>
        </div>
        <fieldset class="config-fieldset" :disabled="sessionStore.isActive">
          <div class="config-grid">
            <div class="config-item">
              <label for="player-count">Jugadores</label>
              <select id="player-count" v-model.number="sessionStore.playerCount">
                <option v-for="n in 8" :key="n" :value="n + 1">{{ n + 1 }} jugadores</option>
              </select>
            </div>
            <div class="config-item">
              <label for="blinds">Ciegas</label>
              <input type="text" id="blinds" v-model="sessionStore.blinds" placeholder="Ej: 1/2">
            </div>
            <div class="config-item">
              <label for="location">Lugar</label>
              <input type="text" id="location" v-model="sessionStore.location" placeholder="Ej: Casino Gran Vía">
            </div>
            <div class="config-item">
              <label for="currency">Moneda</label>
              <select id="currency" v-model="sessionStore.currency">
                <option>$</option><option>€</option><option>£</option>
              </select>
            </div>
            <div class="config-item">
              <label for="initial-stack">Buy-in</label>
              <input type="number" id="initial-stack" v-model.number="sessionStore.initialStack" placeholder="Ej: 200">
            </div>
          </div>
        </fieldset>
      </div>
      
      <!-- CONTROLES PRINCIPALES -->
      <div class="main-controls">
        <button v-if="!sessionStore.isActive" @click="sessionStore.startSession()" class="btn-play">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" /></svg>
          <span>INICIAR SESIÓN</span>
        </button>
        <template v-if="sessionStore.isActive">
          <button v-if="!sessionStore.isOnBreak" @click="sessionStore.startBreak()" class="btn-pause">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M14.25 9v6m-4.5 0V9M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            <span>DESCANSO</span>
          </button>
          <button v-else @click="sessionStore.endBreak()" class="btn-play">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" /></svg>
            <span>FIN DEL DESCANSO</span>
          </button>
          <button @click="showEndSessionModal = true" class="btn-stop">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 019 14.437V9.564z" /></svg>
            <span>FINALIZAR SESIÓN</span>
          </button>
        </template>
      </div>
    </div>
    <EndSessionModal v-if="showEndSessionModal" @confirm="handleConfirmEndSession" @cancel="showEndSessionModal = false" />
  </div>
</template>

<script setup>
import { computed, ref } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import EndSessionModal from '../components/EndSessionModal.vue';

const sessionStore = useSessionStore();
const showEndSessionModal = ref(false);

const rebuyAmount = ref(null);
const tipAmount = ref(null);
const expenseAmount = ref(null);

function handleAddRebuy() {
  if (rebuyAmount.value > 0) {
    sessionStore.addRebuy(rebuyAmount.value);
    rebuyAmount.value = null;
  }
}
function handleAddTip() {
  if (tipAmount.value > 0) {
    sessionStore.addExpense(tipAmount.value);
    tipAmount.value = null;
  }
}
function handleAddExpense() {
  if (expenseAmount.value > 0) {
    sessionStore.addExpense(expenseAmount.value);
    expenseAmount.value = null;
  }
}
function handleConfirmEndSession(finalStack) {
  sessionStore.stopAndSaveSession(finalStack);
  showEndSessionModal.value = false;
}

const formattedTime = computed(() => {
  const totalSeconds = sessionStore.isOnBreak ? sessionStore.breakElapsedTime : sessionStore.elapsedTime;
  const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
  const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
  const seconds = (totalSeconds % 60).toString().padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
});
</script>

<style scoped>
.live-session-container {
  display: flex;
  justify-content: center;
  padding: 3rem 1rem; /* Aumentamos padding vertical */
}
.session-panel {
  width: 100%;
  max-width: 950px; /* Ancho máximo aumentado */
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  grid-template-areas:
    "timer timer"
    "actions config"
    "controls controls";
  gap: 2rem; /* Espacio entre paneles aumentado */
}

/* --- Widgets --- */
.widget {
  background-color: #2d3748;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  padding: 2rem; /* Padding aumentado */
}
.widget-header {
  display: flex;
  align-items: center;
  gap: 12px; /* Espacio de header aumentado */
  font-size: 1rem; /* Tamaño de letra de header aumentado */
  font-weight: bold;
  color: #a0aec0;
  margin-bottom: 1.5rem; /* Margen inferior aumentado */
  letter-spacing: 1px;
}
.timer-widget { grid-area: timer; }
.actions-widget { grid-area: actions; }
.config-widget { grid-area: config; }

/* --- Timer Widget --- */
.status-indicator {
  width: 12px; /* Indicador más grande */
  height: 12px;
  border-radius: 50%;
  background-color: #718096;
  transition: background-color 0.3s ease;
}
.timer-widget:not(.on-break) .status-indicator {
  background-color: #68d391;
  animation: pulse 2s infinite;
}
.timer-widget.on-break .status-indicator {
  background-color: #63b3ed;
}
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(104, 211, 145, 0.7); }
  70% { box-shadow: 0 0 0 12px rgba(104, 211, 145, 0); } /* Sombra de pulso más grande */
  100% { box-shadow: 0 0 0 0 rgba(104, 211, 145, 0); }
}
.timer-display {
  font-family: 'Courier New', Courier, monospace;
  font-size: clamp(3.5rem, 10vw, 6rem); /* Reloj mucho más grande */
  font-weight: 700;
  color: #fff;
  text-align: center;
}
.timer-widget.on-break .timer-display {
  color: #63b3ed;
}

/* --- Actions Widget --- */
.live-actions {
  display: flex;
  flex-direction: column;
  gap: 1.5rem; /* Espacio entre acciones aumentado */
}
.action-group {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 1rem; /* Espacio entre input y botón aumentado */
}
.action-group input {
  padding: 15px; /* Inputs más grandes */
  font-size: 1.1rem; /* Texto de input más grande */
  text-align: center;
}
.action-group button {
  padding: 15px; /* Botones de acción más grandes */
  font-size: 1rem; /* Texto de botón de acción más grande */
  background-color: #4A5568;
}

/* --- Config Widget --- */
.config-fieldset {
  border: none; padding: 0; margin: 0;
  transition: opacity 0.3s ease;
}
.config-fieldset:disabled { opacity: 0.6; }
.config-grid {
  display: grid; grid-template-columns: 1fr 1fr; 
  gap: 1.5rem; /* Espacio entre items de config aumentado */
}
.config-item { display: flex; flex-direction: column; gap: 10px; }
.config-item label { 
  font-weight: bold; 
  font-size: 1.1rem; /* Labels más grandes */
  color: #a0aec0; 
}
.config-item input, .config-item select { 
  font-size: 1.1rem; /* Inputs de config más grandes */
  padding: 15px; /* Padding de inputs aumentado */
}

/* --- Main Controls --- */
.main-controls {
  grid-area: controls;
  display: flex;
  justify-content: center;
  gap: 1.5rem; /* Espacio entre botones principales aumentado */
  margin-top: 1rem;
}
.main-controls button {
  display: flex; align-items: center; justify-content: center; gap: 12px;
  font-size: 1.3rem; /* Texto de botones principales más grande */
  font-weight: bold; 
  padding: 18px 30px; /* Botones principales más grandes */
  border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s ease;
  flex-grow: 1; max-width: 300px; /* Ancho máximo de botones aumentado */
}
.main-controls button svg { 
  width: 28px; /* Iconos más grandes */
  height: 28px; 
}
.btn-play { background-color: #38a169; color: white; }
.btn-play:hover { background-color: #2f855a; }
.btn-pause { background-color: #dd6b20; color: white; }
.btn-pause:hover { background-color: #c05621; }
.btn-stop { background-color: #c53030; color: white; }
.btn-stop:hover { background-color: #9b2c2c; }

/* --- Media Queries for Responsiveness --- */
@media (max-width: 768px) {
  .session-panel {
    grid-template-columns: 1fr;
    grid-template-areas:
      "timer"
      "actions"
      "config"
      "controls";
  }
}
</style>

---------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SavedHandsView.vue ---

<template>
  <div class="saved-hands-container">
    <h2>Manos Guardadas</h2>

    <!-- SECCIÓN DE FILTROS AÑADIDA -->
    <div class="filters-container">
      <div class="filter-group">
        <label for="date-filter">Filtrar por Fecha:</label>
        <input id="date-filter" type="date" v-model="selectedDate">
        <button v-if="selectedDate" @click="selectedDate = ''" class="clear-btn">Limpiar</button>
      </div>
      <div class="filter-group">
        <button @click="toggleHandStrengthSort" class="sort-btn">
          {{ sortKey === 'strength' ? 'Ordenar por Fecha' : 'Ordenar por Mano de Héroe' }}
        </button>
      </div>
    </div>

    <div v-if="filteredAndSortedHands.length === 0" class="no-hands">
      No se encontraron manos que coincidan con los filtros.
    </div>
    <ul v-else class="hands-list">
      <!-- El v-for ahora usa la nueva propiedad computada -->
      <li v-for="hand in filteredAndSortedHands" :key="hand.id">
        <div class="hand-info">
          <span><strong>Fecha:</strong> {{ hand.date }}</span>
          <span><strong>Hero:</strong> {{ hand.heroPosition }}</span>
          <span><strong>Jugadores:</strong> {{ hand.numPlayers }}</span>
        </div>

        <div class="hand-preview">
          <!-- Se añade la clase 'hero-hand-preview' para aplicar el estilo -->
          <div class="card-group hero-hand-preview">
            <span class="group-label">Hero</span>
            <div class="cards-display">
              <template v-if="getHeroFromHand(hand)?.cards">
                <PlayingCard v-for="(card, index) in getHeroFromHand(hand).cards" :key="`hero-${card}-${index}`" :cardId="card" />
              </template>
            </div>
          </div>
          <div class="card-group">
            <span class="group-label">Board</span>
            <div class="cards-display">
              <template v-if="getBoardFromHand(hand).length > 0">
                <PlayingCard v-for="(card, index) in getBoardFromHand(hand)" :key="`board-${card}-${index}`" :cardId="card" />
              </template>
            </div>
          </div>
        </div>

        <div class="hand-actions">
          <button @click="loadHandForReplay(hand)">Cargar Replay</button>
          <button class="delete-btn" @click="confirmDelete(hand.id)">Eliminar</button>
        </div>
      </li>
    </ul>

    <!-- Confirmation Modal -->
    <div v-if="showModal" class="modal-overlay" @click="closeModal">
      <div class="modal-content" @click.stop>
        <h3>Confirmar Eliminación</h3>
        <p>¿Está seguro de que desea eliminar esta mano?</p>
        <div class="modal-actions">
          <button class="cancel-btn" @click="closeModal">No</button>
          <button class="confirm-btn" @click="deleteHand">Sí</button>
        </div>
      </div>
    </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Mano eliminada con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useGameStore } from '../store/game'
import PlayingCard from '../components/PlayingCard.vue';

const gameStore = useGameStore();
const emit = defineEmits(['switch-view']);

const selectedDate = ref('');
const sortKey = ref('date');

// --- ESTADO PARA EL MODAL Y TOAST ---
const showModal = ref(false);
const showToast = ref(false);
const selectedHandId = ref(null);

// --- LÓGICA DE RANKING DE MANOS CORREGIDA ---
const HAND_STRENGTH_MAP = {
  'AA': 1, 'KK': 2, 'QQ': 3, 'AKs': 4, 'JJ': 5, 'AQs': 6, 'KQs': 7, 'AJs': 8, 'KJs': 9, 'TT': 10, 'AKo': 11, 'ATs': 12, 'QJs': 13, 'KTs': 14, 'QTs': 15, 'JTs': 16, '99': 17, 'AQo': 18, 'A9s': 19, 'K9s': 20, 'Q9s': 21, 'J9s': 22, 'T9s': 23, 'A8s': 24, '88': 25, 'K8s': 26, 'Q8s': 27, 'J8s': 28, 'AJo': 29, 'A5s': 30, 'T8s': 31, '98s': 32, 'A7s': 33, 'A4s': 34, 'K7s': 35, '77': 36, 'A3s': 37, 'Q7s': 38, 'A6s': 39, 'KJo': 40, 'A2s': 41, 'K6s': 42, '87s': 43, 'T7s': 44, 'K5s': 45, '66': 46, 'ATo': 47, 'J7s': 48, 'Q6s': 49, 'K4s': 50, '97s': 51, '76s': 52, 'K3s': 53, 'Q5s': 54, '55': 55, 'K2s': 56, 'J6s': 57, 'T6s': 58, 'Q4s': 59, '86s': 60, 'Q3s': 61, '65s': 62, 'KTo': 63, 'A9o': 64, 'Q2s': 65, '44': 66, 'J5s': 67, '96s': 68, 'J4s': 69, '75s': 70, 'QJo': 71, 'A8o': 72, 'T5s': 73, 'J3s': 74, '54s': 75, '85s': 76, 'K9o': 77, 'Q9o': 78, '33': 79, 'J2s': 80, '64s': 81, 'T4s': 82, 'J9o': 83, 'T9o': 84, 'A7o': 85, 'K8o': 86, '95s': 87, '22': 88, '74s': 89, 'T3s': 90, '53s': 91, 'Q8o': 92, 'A5o': 93, '84s': 94, 'A4o': 95, 'K7o': 96, 'J8o': 97, 'T2s': 98, 'A6o': 99, '98o': 100, '43s': 101, 'A3o': 102, 'K6o': 103, '63s': 104, 'T8o': 105, 'A2o': 106, 'Q7o': 107, 'J7o': 108, 'K5o': 109, '87o': 110, '52s': 111, 'K4o': 112, 'T7o': 113, '76o': 114, 'Q6o': 115, '94s': 116, 'K3o': 117, 'J6o': 118, '83s': 119, 'K2o': 120, 'Q5o': 121, '97o': 122, '73s': 123, '42s': 124, 'T6o': 125, '65o': 126, 'Q4o': 127, 'J5o': 128, '86o': 129, 'Q3o': 130, 'J4o': 131, '96o': 132, '75o': 133, 'T5o': 134, 'Q2o': 135, '62s': 136, 'J3o': 137, '82s': 138, '54o': 139, '85o': 140, 'J2o': 141, '93s': 142, 'T4o': 143, '64o': 144, '95o': 145, '72s': 146, 'T3o': 147, '74o': 148, '53o': 149, '84o': 150, 'T2o': 151, '43o': 152, '92s': 153, '63o': 154, '83o': 155, '73o': 156, '52o': 157, '94o': 158, '42o': 159, '82o': 160, '62o': 161, '93o': 162, '72o': 163, '92o': 164
};
const RANK_ORDER = 'AKQJT98765432';

function getHandRank(cards) {
  if (!cards || cards.length < 2 || !cards[0] || !cards[1]) return 999;
  const rank1 = cards[0].charAt(0), suit1 = cards[0].charAt(1);
  const rank2 = cards[1].charAt(0), suit2 = cards[1].charAt(1);
  const isSuited = suit1 === suit2, isPair = rank1 === rank2;
  const [r1, r2] = [RANK_ORDER.indexOf(rank1), RANK_ORDER.indexOf(rank2)].sort((a,b) => a - b);
  const highRank = RANK_ORDER[r1], lowRank = RANK_ORDER[r2];
  let handKey;
  if (isPair) handKey = `${highRank}${lowRank}`;
  else if (isSuited) handKey = `${highRank}${lowRank}s`;
  else handKey = `${highRank}${lowRank}o`;
  return HAND_STRENGTH_MAP[handKey] || 999;
}

const filteredAndSortedHands = computed(() => {
  let hands = [...gameStore.savedHands];

  if (selectedDate.value) {
    hands = hands.filter(hand => {
      const dateString = hand.date.split(',')[0];
      const parts = dateString.split('/');
      const year = parts[2];
      const month = parts[1].padStart(2, '0');
      const day = parts[0].padStart(2, '0');
      const handDateYYYYMMDD = `${year}-${month}-${day}`;
      
      return handDateYYYYMMDD === selectedDate.value;
    });
  }

  if (sortKey.value === 'strength') {
    hands.sort((a, b) => {
      const heroA = getHeroFromHand(a);
      const heroB = getHeroFromHand(b);
      const rankA = getHandRank(heroA?.cards);
      const rankB = getHandRank(heroB?.cards);
      return rankA - rankB;
    });
  } else {
    // --- ÚNICO CAMBIO REALIZADO AQUÍ ---
    // Orden por defecto: las más nuevas primero.
    // Se asegura de parsear correctamente el formato DD/MM/YYYY para la comparación.
    hands.sort((a, b) => {
        const dateA = new Date(a.date.replace(/(\d+)\/(\d+)\/(\d+)/, '$2/$1/$3'));
        const dateB = new Date(b.date.replace(/(\d+)\/(\d+)\/(\d+)/, '$2/$1/$3'));
        return dateB - dateA;
    });
  }

  return hands;
});

function toggleHandStrengthSort() {
  sortKey.value = sortKey.value === 'strength' ? 'date' : 'strength';
}

function loadHandForReplay(hand) {
  gameStore.loadHand(hand);
  emit('switch-view', 'CurrentHandView');
}

function getHeroFromHand(hand) {
  if (!hand.history || hand.history.length === 0) return null;
  const finalState = hand.history[hand.history.length - 1];
  return finalState.players.find(p => p.name === 'Hero');
}

function getBoardFromHand(hand) {
  if (!hand.history || hand.history.length === 0) return [];
  const finalState = hand.history[hand.history.length - 1];
  return finalState.board.filter(card => card);
}

function confirmDelete(handId) {
  selectedHandId.value = handId;
  showModal.value = true;
}

function closeModal() {
  showModal.value = false;
  selectedHandId.value = null;
}

function deleteHand() {
  if (selectedHandId.value) {
    gameStore.deleteHand(selectedHandId.value);
    showToast.value = true;
    setTimeout(() => {
      showToast.value = false;
    }, 3000);
    closeModal();
  }
}
</script>

<style scoped>
.saved-hands-container {
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}
.no-hands {
  margin-top: 2rem;
  text-align: center;
  color: #a0aec0;
  font-size: 1.2rem;
}
.hands-list {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.hands-list li {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1.5rem;
}

/* --- NUEVOS ESTILOS PARA LOS FILTROS --- */
.filters-container {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1.5rem;
  margin-bottom: 2rem;
}
.filter-group {
  display: flex;
  align-items: center;
  gap: 10px;
}
.filter-group label {
  font-weight: bold;
  color: #a0aec0;
}
.filter-group input[type="date"] {
  padding: 8px;
  border-radius: 4px;
}
.sort-btn, .clear-btn {
  font-size: 1rem;
  padding: 8px 16px;
}
.clear-btn {
  background-color: #718096;
}

/* --- (Estilos existentes sin cambios) --- */
.hand-info { display: flex; flex-direction: column; align-items: flex-start; gap: 0.5rem; flex-basis: 200px; flex-shrink: 0; }
.hand-actions { display: flex; gap: 0.5rem; }
.hand-preview { display: flex; flex-grow: 1; justify-content: flex-start; align-items: center; gap: 2rem; }
.card-group { display: flex; align-items: center; gap: 10px; }
.group-label { font-weight: bold; font-size: 1.1rem; color: #a0aec0; }
.cards-display { display: flex; gap: 5px; }
.cards-display :deep(.playing-card) { width: 45px; height: 63px; border-radius: 4px; }
.cards-display :deep(.rank) { font-size: 1.5rem; }
.cards-display :deep(.suit-icon) { font-size: 1rem; }
.delete-btn { background-color: #c53030; }
.delete-btn:hover { background-color: #9b2c2c; }

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
  text-align: center;
  border: 1px solid var(--border-color);
}

.modal-content h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  color: white;
}

.modal-content p {
  margin: 0 0 2rem 0;
  color: #a0aec0;
  font-size: 1.1rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.cancel-btn, .confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.cancel-btn {
  background-color: #4A5568;
  color: white;
}

.cancel-btn:hover {
  background-color: #2D3748;
}

.confirm-btn {
  background-color: #c53030;
  color: white;
}

.confirm-btn:hover {
  background-color: #9b2c2c;
}

/* Toast Styles */
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}

.success-toast {
  background-color: #38a169;
  color: white;
}

.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}

.toast-message {
  font-size: 1rem;
  font-weight: bold;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* --- ESTILOS ADITIVOS PARA EL HALO DEL HERO EN LA LISTA --- */
.hero-hand-preview {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid #68d391; /* Color de borde verde */
  animation: hero-glow-list 2s infinite ease-in-out;
}

@keyframes hero-glow-list {
  0%, 100% {
    background-color: rgba(104, 211, 145, 0.05); /* Fondo verde muy sutil */
    box-shadow: 0 0 5px rgba(104, 211, 145, 0.5); /* Sombra verde */
  }
  50% {
    background-color: rgba(104, 211, 145, 0.15); /* Fondo verde más intenso */
    box-shadow: 0 0 12px rgba(104, 211, 145, 0.8); /* Sombra verde más intensa */
  }
}
</style>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SavedSessionsView.vue ---

<template>
  <div class="saved-sessions-container">
    <h2>Sesiones Guardadas</h2>

    <!-- SECCIÓN DE FILTROS AÑADIDA -->
    <div class="filters-container">
      <label for="date-range-filter">Mostrar Sesiones de:</label>
      <select id="date-range-filter" v-model="selectedFilter">
        <option value="all">Todo</option>
        <option value="today">Hoy</option>
        <option value="last7days">Última semana</option>
        <option value="last1month">Último mes</option>
        <option value="last3months">Últimos 3 meses</option>
        <option value="last6months">Últimos 6 meses</option>
        <option value="last1year">Último año</option>
      </select>
    </div>

    <!-- MENSAJE Y LISTA AHORA USAN LA PROPIEDAD COMPUTADA 'filteredSessions' -->
    <div v-if="filteredSessions.length === 0" class="no-sessions">
      No tienes sesiones guardadas que coincidan con el filtro seleccionado.
    </div>
    <ul v-else class="sessions-list">
      <li v-for="session in filteredSessions" :key="session.id">
        
        <div class="session-header">
          <span class="location">{{ session.location || 'Partida Privada' }}</span>
          <span class="date">{{ session.date }}</span>
        </div>
        
        <div class="session-result" :class="getResultClass(session.result)">
          <span>Resultado</span>
          <span class="result-amount">
            {{ formatResult(session.result, session.currency) }}
          </span>
        </div>

        <div class="session-details">
          <div class="session-stats">
            <div class="stat-item"><strong>Duración:</strong> <span>{{ formatDuration(session.duration) }}</span></div>
            <div class="stat-item"><strong>Descansos:</strong> <span>{{ formatDuration(session.totalBreakTime) }}</span></div>
            <div class="stat-item"><strong>Ciegas:</strong> <span>{{ session.blinds }}</span></div>
            <div class="stat-item"><strong>Jugadores:</strong> <span>{{ session.playerCount }}</span></div>
            <div class="stat-item"><strong>Buy-in:</strong> <span>{{ session.currency }}{{ session.initialStack }}</span></div>
            <div class="stat-item"><strong>Recargas:</strong> <span>{{ session.currency }}{{ session.totalRebuys || 0 }}</span></div>
            <div class="stat-item"><strong>Gastos:</strong> <span>-{{ session.currency }}{{ session.totalExpenses || 0 }}</span></div>
            <div class="stat-item"><strong>Stack Final:</strong> <span>{{ session.currency }}{{ session.finalStack !== undefined ? session.finalStack : 'N/A' }}</span></div>
          </div>
        </div>

        <div class="session-actions">
           <button class="notes-btn" @click="openNotesModal(session.id)" title="Añadir Notas">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
               <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
             </svg>
           </button>
           <button class="delete-btn" @click="confirmDelete(session.id)">Eliminar Sesión</button>
         </div>
      </li>
    </ul>

    <!-- Confirmation Modal -->
     <div v-if="showModal" class="modal-overlay" @click="closeModal">
       <div class="modal-content" @click.stop>
         <h3>Confirmar Eliminación</h3>
         <p>¿Estás seguro de que deseas eliminar esta sesión?</p>
         <div class="modal-actions">
           <button class="cancel-btn" @click="closeModal">No</button>
           <button class="confirm-btn" @click="deleteSession">Sí</button>
         </div>
       </div>
     </div>

     <!-- Notes Modal -->
     <div v-if="showNotesModal" class="modal-overlay" @click="closeNotesModal">
       <div class="modal-content notes-modal" @click.stop>
         <h3>Notas de la Sesión</h3>
         <textarea v-model="sessionNotes" placeholder="Escribe tus notas sobre esta sesión..." rows="6"></textarea>
         <div class="modal-actions">
           <button class="cancel-btn" @click="closeNotesModal">Cancelar</button>
           <button class="confirm-btn" @click="saveNotes">Guardar</button>
         </div>
       </div>
     </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Sesión eliminada con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'; // <-- IMPORTAR ref Y computed
import { useSessionStore } from '../store/useSessionStore';

const sessionStore = useSessionStore();

// --- NUEVO ESTADO LOCAL PARA EL FILTRO ---
const selectedFilter = ref('all');

// --- ESTADO PARA EL MODAL Y TOAST ---
const showModal = ref(false);
const showToast = ref(false);
const selectedSessionId = ref(null);

// --- ESTADO PARA EL MODAL DE NOTAS ---
const showNotesModal = ref(false);
const sessionNotes = ref('');
const notesSessionId = ref(null);

// --- NUEVA PROPIEDAD COMPUTADA PARA FILTRAR LAS SESIONES ---
const filteredSessions = computed(() => {
  const filter = selectedFilter.value;
  const allSessions = sessionStore.savedSessions;

  if (filter === 'all') {
    return allSessions;
  }

  const now = new Date();
  const cutoffDate = new Date();

  // Establecer la fecha de corte según el filtro seleccionado
  switch (filter) {
    case 'today':
      cutoffDate.setHours(0, 0, 0, 0);
      break;
    case 'last7days':
      cutoffDate.setDate(now.getDate() - 7);
      break;
    case 'last1month':
      cutoffDate.setMonth(now.getMonth() - 1);
      break;
    case 'last3months':
      cutoffDate.setMonth(now.getMonth() - 3);
      break;
    case 'last6months':
      cutoffDate.setMonth(now.getMonth() - 6);
      break;
    case 'last1year':
      cutoffDate.setFullYear(now.getFullYear() - 1);
      break;
  }

  return allSessions.filter(session => {
    // Parsea la fecha en formato DD/MM/YYYY para que sea comparable
    const parts = session.date.split('/');
    const sessionDate = new Date(parts[2], parts[1] - 1, parts[0]);
    return sessionDate >= cutoffDate;
  });
});

function formatDuration(totalSeconds) {
  if (!totalSeconds) return '0m';
  if (totalSeconds < 60) return `${totalSeconds}s`;
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  let result = '';
  if (hours > 0) result += `${hours}h `;
  if (minutes > 0) result += `${minutes}m`;
  return result.trim();
}

function getResultClass(result) {
  if (typeof result !== 'number') return 'even';
  if (result > 0) return 'profit';
  if (result < 0) return 'loss';
  return 'even';
}

function formatResult(result, currency) {
  if (typeof result !== 'number') {
    return 'N/A';
  }
  const prefix = result >= 0 ? '+' : '';
  return `${prefix}${currency}${result.toFixed(2)}`;
}

function confirmDelete(sessionId) {
  selectedSessionId.value = sessionId;
  showModal.value = true;
}

function closeModal() {
  showModal.value = false;
  selectedSessionId.value = null;
}

function deleteSession() {
  if (selectedSessionId.value) {
    sessionStore.deleteSession(selectedSessionId.value);
    showToast.value = true;
    setTimeout(() => {
      showToast.value = false;
    }, 3000);
    closeModal();
  }
}

function openNotesModal(sessionId) {
  notesSessionId.value = sessionId;
  sessionNotes.value = localStorage.getItem(`sessionNotes_${sessionId}`) || '';
  showNotesModal.value = true;
}

function closeNotesModal() {
  showNotesModal.value = false;
  sessionNotes.value = '';
  notesSessionId.value = null;
}

function saveNotes() {
  if (notesSessionId.value) {
    localStorage.setItem(`sessionNotes_${notesSessionId.value}`, sessionNotes.value);
    closeNotesModal();
  }
}
</script>

<style scoped>
.saved-sessions-container {
  padding: 2rem;
  max-width: 700px;
  margin: 0 auto;
}
.no-sessions {
  margin-top: 1rem;
  color: #a0aec0;
  font-size: 1.2rem;
  text-align: center;
}
.sessions-list {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

/* --- NUEVOS ESTILOS PARA LA BARRA DE FILTROS --- */
.filters-container {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  margin-bottom: 2rem;
}
.filters-container label {
  font-weight: bold;
  font-size: 1.1rem;
  color: #a0aec0;
}
.filters-container select {
  padding: 10px 15px;
  font-size: 1.1rem;
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: white;
}

/* --- (Estilos existentes sin cambios) --- */
.sessions-list li { background-color: #2d3748; padding: 1.5rem 2rem; border-radius: 12px; border: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 1.5rem; }
.session-header { display: flex; justify-content: space-between; align-items: baseline; border-bottom: 1px solid #4a5568; padding-bottom: 1rem; }
.location { font-size: 1.8rem; font-weight: 700; }
.date { font-size: 1rem; color: #a0aec0; flex-shrink: 0; margin-left: 1rem; }
.session-result { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1.5rem; border-radius: 8px; text-align: center; }
.session-result span:first-child { font-size: 1.1rem; opacity: .8; margin-bottom: .5rem; text-transform: uppercase; letter-spacing: 1px; }
.result-amount { font-size: 2.8rem; font-weight: 700; }
.profit { background-color: rgba(47, 133, 90, .3); color: #68d391; }
.loss { background-color: rgba(197, 48, 48, .3); color: #fc8181; }
.even { background-color: rgba(74, 85, 104, .3); color: #a0aec0; }
.session-stats { display: grid; grid-template-columns: 1fr; gap: 1rem; }
.stat-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.3rem; padding: 0.5rem 0; border-bottom: 1px solid #3c485e; }
.stat-item:last-child { border-bottom: none; }
.stat-item strong { color: #a0aec0; margin-right: 1rem; }
.stat-item span { font-weight: bold; }
.session-actions { display: flex; justify-content: space-between; margin-top: 1rem; }
.notes-btn { background-color: #48bb78; padding: 12px; font-size: 1.1rem; border: none; border-radius: 6px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; }
.notes-btn:hover { background-color: #38a169; }
.notes-btn svg { width: 20px; height: 20px; }
.delete-btn { background-color: #c53030; padding: 12px 25px; font-size: 1.1rem; width: 100%; max-width: 300px; }
.delete-btn:hover { background-color: #9b2c2c; }

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
  text-align: center;
  border: 1px solid var(--border-color);
}

.modal-content h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  color: white;
}

.modal-content p {
  margin: 0 0 2rem 0;
  color: #a0aec0;
  font-size: 1.1rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.cancel-btn, .confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.cancel-btn {
  background-color: #4A5568;
  color: white;
}

.cancel-btn:hover {
  background-color: #2D3748;
}

.confirm-btn {
  background-color: #c53030;
  color: white;
}

.confirm-btn:hover {
  background-color: #9b2c2c;
}

.notes-modal textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  background-color: #1a202c;
  color: white;
  font-family: inherit;
  font-size: 1rem;
  resize: vertical;
  margin-bottom: 1rem;
}

.notes-modal .confirm-btn {
  background-color: #48bb78;
}

.notes-modal .confirm-btn:hover {
  background-color: #38a169;
}

/* Toast Styles */
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}

.success-toast {
  background-color: #38a169;
  color: white;
}

.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}

.toast-message {
  font-size: 1rem;
  font-weight: bold;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
</style>

-----------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SavedTripsView.vue ---

<template>
  <div class="saved-trips-container">
    <h2>Viajes Guardados</h2>
    <div v-if="tripStore.savedTrips.length === 0" class="no-trips">
      No tienes viajes guardados todavía.
    </div>
    <ul v-else class="trips-list">
      <li v-for="trip in tripStore.savedTrips" :key="trip.id">
        <div class="trip-header">
          <div class="trip-info">
            <span class="trip-destination">{{ trip.city || 'Viaje sin ciudad' }}, {{ trip.casino || 'Sin casino' }}</span>
            <span class="trip-date">Guardado el: {{ trip.date }}</span>
          </div>
          <div class="trip-actions">
            <button @click="loadTripForEditing(trip.id)">Cargar y Editar</button>
            <button class="delete-btn" @click="confirmDelete(trip.id)">Eliminar</button>
          </div>
        </div>

        <div class="trip-stats">
          <div class="stat-item">
            <label>Jugadores</label>
            <span class="value">{{ trip.players.length }}</span>
          </div>
          <div class="stat-item">
            <label>Horas Totales</label>
            <span class="value">{{ calculateTripHours(trip).toFixed(1) }} h</span>
          </div>
          <div class="stat-item">
            <label>Beneficio Total</label>
            <span class="value" :class="getResultClass(calculateTripProfit(trip))">
              {{ calculateTripProfit(trip).toFixed(2) }} {{ trip.currency }}
            </span>
          </div>
          <div class="stat-item">
            <label>Media {{ trip.currency }}/h</label>
            <span class="value" :class="getResultClass(calculateTripWinRate(trip))">
              {{ calculateTripWinRate(trip).toFixed(2) }}
            </span>
          </div>
        </div>
      </li>
    </ul>

    <!-- Confirmation Modal -->
    <div v-if="showModal" class="modal-overlay" @click="closeModal">
      <div class="modal-content" @click.stop>
        <h3>Confirmar Eliminación</h3>
        <p>¿Está seguro de que desea eliminar este viaje?</p>
        <div class="modal-actions">
          <button class="cancel-btn" @click="closeModal">No</button>
          <button class="confirm-btn" @click="deleteTrip">Sí</button>
        </div>
      </div>
    </div>

    <!-- Success Toast -->
    <div v-if="showToast" class="toast success-toast">
      <div class="toast-icon">✓</div>
      <div class="toast-message">Viaje eliminado con éxito</div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useTripStore } from '../store/useTripStore';

const tripStore = useTripStore();

const emit = defineEmits(['switch-view']);

// --- ESTADO PARA EL MODAL Y TOAST ---
const showModal = ref(false);
const showToast = ref(false);
const selectedTripId = ref(null);
function loadTripForEditing(tripId) {
  tripStore.loadTrip(tripId);
  emit('switch-view', 'CommunityView');
}

function calculateTripProfit(trip) {
  if (!trip.dailyResults) return 0;
  return Object.values(trip.dailyResults).reduce((total, dayResults) => {
    const dayTotal = Object.values(dayResults).reduce((daySum, playerData) => daySum + (playerData.result || 0), 0);
    return total + dayTotal;
  }, 0);
}

function calculateTripHours(trip) {
  if (!trip.dailyResults) return 0;
  return Object.values(trip.dailyResults).reduce((total, dayResults) => {
    const dayTotal = Object.values(dayResults).reduce((daySum, playerData) => daySum + (playerData.hours || 0), 0);
    return total + dayTotal;
  }, 0);
}

function calculateTripWinRate(trip) {
  const totalProfit = calculateTripProfit(trip);
  const totalHours = calculateTripHours(trip);
  if (totalHours === 0) {
    return 0;
  }
  return totalProfit / totalHours;
}

function getResultClass(result) {
  if (result > 0) return 'profit';
  if (result < 0) return 'loss';
  return 'even';
}

function confirmDelete(tripId) {
  selectedTripId.value = tripId;
  showModal.value = true;
}

function closeModal() {
  showModal.value = false;
  selectedTripId.value = null;
}

function deleteTrip() {
  if (selectedTripId.value) {
    tripStore.deleteTrip(selectedTripId.value);
    showToast.value = true;
    setTimeout(() => {
      showToast.value = false;
    }, 3000);
    closeModal();
  }
}
</script>

<style scoped>
.saved-trips-container {
  padding: 2rem;
  max-width: 900px;
  margin: 0 auto;
}
h2 {
  text-align: center;
  margin-bottom: 2rem;
}
.no-trips {
  margin-top: 1rem;
  color: #a0aec0;
  text-align: center;
  font-size: 1.2rem;
}
.trips-list {
  list-style: none;
  padding: 0;
  margin-top: 1rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}
.trips-list li {
  background-color: #2d3748;
  padding: 1.5rem;
  border-radius: 12px;
  border: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

.trip-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  flex-wrap: wrap;
  gap: 1rem;
}
.trip-info {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.5rem;
}
.trip-destination {
  font-size: 1.5rem;
  font-weight: bold;
}
.trip-date {
  font-size: 0.9rem;
  color: #a0aec0;
}
.trip-actions {
  display: flex;
  gap: 0.5rem;
  flex-shrink: 0;
}

.trip-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 1rem;
  background-color: #1a202c;
  padding: 1rem;
  border-radius: 8px;
}
.stat-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0.5rem;
}
.stat-item label {
  font-size: 0.9rem;
  color: #a0aec0;
  margin-bottom: 0.25rem;
  font-weight: bold;
}
.stat-item .value {
  font-size: 1.5rem;
  font-weight: bold;
}

.delete-btn {
  background-color: #c53030;
}
.delete-btn:hover {
  background-color: #9b2c2c;
}
.profit { color: #68d391; }
.loss { color: #fc8181; }
.even { color: #e2e8f0; }

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
  max-width: 400px;
  width: 90%;
  text-align: center;
  border: 1px solid var(--border-color);
}

.modal-content h3 {
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
  color: white;
}

.modal-content p {
  margin: 0 0 2rem 0;
  color: #a0aec0;
  font-size: 1.1rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.cancel-btn, .confirm-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.cancel-btn {
  background-color: #4A5568;
  color: white;
}

.cancel-btn:hover {
  background-color: #2D3748;
}

.confirm-btn {
  background-color: #c53030;
  color: white;
}

.confirm-btn:hover {
  background-color: #9b2c2c;
}

/* Toast Styles */
.toast {
  position: fixed;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 15px 20px;
  border-radius: 8px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  animation: slideIn 0.3s ease-out;
}

.success-toast {
  background-color: #38a169;
  color: white;
}

.toast-icon {
  font-size: 1.5rem;
  font-weight: bold;
}

.toast-message {
  font-size: 1rem;
  font-weight: bold;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}
</style>

--------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SettingsView.vue ---

<template>
  <div class="settings-container">
    <div class="settings-panel">
      <h2>{{ $t('settings.title') }}</h2>
      <div class="setting-item">
        <label for="language-select">{{ $t('settings.language') }}</label>
        <select id="language-select" v-model="settingsStore.locale">
          <option value="es">Español</option>
          <option value="en">English</option>
          <!-- Aquí puedes añadir más idiomas cuando crees sus archivos .json -->
        </select>
      </div>

      <!-- AVISO DE COPYRIGHT AÑADIDO -->
      <div class="copyright-notice">
        © {{ new Date().getFullYear() }} Tracker de Poker en Vivo. Protegido con Copyright. Todos los derechos reservados.
      </div>

    </div>
  </div>
</template>

<script setup>
import { useSettingsStore } from '../store/useSettingsStore';
const settingsStore = useSettingsStore();
</script>

<style scoped>
.settings-container {
  display: flex;
  justify-content: center;
  padding: 3rem;
}
.settings-panel {
  width: 100%;
  max-width: 500px;
  background-color: #2d3748;
  border-radius: 12px;
  padding: 2rem;
}
h2 {
  margin-top: 0;
  text-align: center;
}
.setting-item {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.setting-item label {
  font-weight: bold;
}
.setting-item select {
  padding: 12px;
  font-size: 1.1rem;
}

/* --- ESTILOS ADITIVOS PARA EL AVISO DE COPYRIGHT --- */
.copyright-notice {
  margin-top: 2rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border-color);
  text-align: center;
  font-size: 0.9rem;
  color: #a0aec0;
}
</style>

------------------------------------------------------

--- INICIO DEL ARCHIVO: src/views/SummaryView.vue ---

<template>
  <div class="summary-container">
    <h2>{{ $t('summary.title') }}</h2>

    <!-- FILTRO DE FECHA AÑADIDO -->
    <div class="filters-container">
      <label for="summary-date-filter">Mostrar datos de:</label>
      <select 
        id="summary-date-filter"
        :value="sessionStore.summaryDateFilter" 
        @change="sessionStore.setSummaryDateFilter($event.target.value)"
      >
        <option value="all">Todo</option>
        <option value="last7days">Última semana</option>
        <option value="last1month">Último mes</option>
        <option value="last3months">Últimos 3 meses</option>
        <option value="last6months">Últimos 6 meses</option>
        <option value="last1year">Último año</option>
      </select>
    </div>

    <div v-if="sessionStore.sessionCount === 0" class="no-data-message">
      No hay sesiones guardadas para el período seleccionado.
    </div>
    <template v-else>
      <div class="stats-grid">
        <div class="stat-card">
          <span class="stat-title">{{ $t('summary.totalProfit') }}</span>
          <span class="stat-value" :class="getResultClass(sessionStore.totalNetProfit)">{{ formatCurrency(sessionStore.totalNetProfit) }}</span>
        </div>
        <div class="stat-card">
          <span class="stat-title">ROI</span>
          <span class="stat-value" :class="getResultClass(sessionStore.roi)">{{ sessionStore.roi.toFixed(2) }}%</span>
        </div>
        <div class="stat-card">
          <span class="stat-title">{{ $t('summary.avgBuyIn') }}</span>
          <span class="stat-value">{{ formatCurrency(sessionStore.averageBuyIn, false) }}</span>
        </div>
        <div class="stat-card">
          <span class="stat-title">{{ $t('summary.avgCashOut') }}</span>
          <span class="stat-value">{{ formatCurrency(sessionStore.averageCashOut, false) }}</span>
        </div>
      </div>
      
      <div class="detailed-summary-panel">
        <h3>{{ $t('summary.sessionsTitle') }}</h3>
        <div class="detailed-stats-grid">
          <div class="detail-item">
            <span>{{ $t('summary.sessionCount') }}</span>
            <span>{{ sessionStore.sessionCount }}</span>
          </div>
           <div class="detail-item">
            <span>Manos guardadas</span>
            <span>{{ gameStore.savedHands.length }}</span>
          </div>
          <div class="detail-item">
            <span>Días ganadores</span>
            <span class="profit-text">{{ sessionStore.winningDays }}</span>
          </div>
           <div class="detail-item">
            <span>Días perdedores</span>
            <span class="loss-text">{{ sessionStore.losingDays }}</span>
          </div>
          <div class="detail-item">
            <span>Mejor día</span>
            <span class="profit-text">{{ formatCurrency(sessionStore.bestDay) }}</span>
          </div>
           <div class="detail-item">
            <span>Peor día</span>
            <span class="loss-text">{{ formatCurrency(sessionStore.worstDay) }}</span>
          </div>
           <div class="detail-item">
            <span>Racha ganadora</span>
            <span>{{ sessionStore.winningStreak }} días</span>
          </div>
          <div class="detail-item">
            <span>Ganancias/Hora</span>
            <span :class="getResultClass(sessionStore.winRatePerHour)">{{ formatCurrency(sessionStore.winRatePerHour) }}/h</span>
          </div>
           <div class="detail-item">
            <span>BB/100</span>
            <span :class="getResultClass(bbPer100)">{{ bbPer100.toFixed(2) }}</span>
          </div>
          <div class="detail-item">
            <span>Media de rebuys</span>
            <span>{{ formatCurrency(sessionStore.averageRebuys, false) }}</span>
          </div>
          <div class="detail-item">
            <span>Propinas y Consumiciones</span>
            <span>{{ formatCurrency(sessionStore.totalAllExpenses, false) }}</span>
          </div>
          <div class="detail-item">
            <span>{{ $t('summary.totalHours') }}</span>
            <span>{{ sessionStore.totalHoursPlayed.toFixed(2) }}h</span>
          </div>
          <div class="detail-item">
            <span>{{ $t('summary.avgHours') }}</span>
            <span>{{ sessionStore.averageHoursPlayed.toFixed(2) }}h</span>
          </div>
          <div class="detail-item">
            <span>{{ $t('summary.avgBreak') }}</span>
            <span>{{ sessionStore.averageBreakDuration.toFixed(0) }}min</span>
          </div>
        </div>
      </div>
    </template>
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { useSessionStore } from '../store/useSessionStore';
import { useGameStore } from '../store/game';

const sessionStore = useSessionStore();
const gameStore = useGameStore();

const bbPer100 = computed(() => {
  const totalHands = gameStore.savedHands.length;
  if (totalHands === 0) {
    return 0;
  }
  
  const totalProfit = sessionStore.totalNetProfit;

  const totalBigBlindValue = gameStore.savedHands.reduce((sum, hand) => sum + (hand.bigBlind || 0), 0);
  const averageBigBlind = totalBigBlindValue / totalHands;

  if (averageBigBlind === 0) {
    return 0;
  }
  
  const profitInBB = totalProfit / averageBigBlind;
  const winRate = (profitInBB / totalHands) * 100;
  
  return winRate;
});


function formatCurrency(value, showSign = true) {
  if (typeof value !== 'number') return `${sessionStore.currency}0.00`;
  const prefix = value >= 0 ? '+' : '';
  if (showSign) {
     return `${prefix}${sessionStore.currency}${value.toFixed(2)}`;
  }
  return `${sessionStore.currency}${value.toFixed(2)}`;
}

function getResultClass(result) {
  if (typeof result !== 'number' || result === 0) return 'even-text';
  if (result > 0) return 'profit-text';
  if (result < 0) return 'loss-text';
  return 'even-text';
}
</script>

<style scoped>
.summary-container {
  padding: 1rem;
  max-width: 1200px;
  margin: 0 auto;
}
h2 {
  text-align: center;
  margin-bottom: 2rem;
  font-size: 2rem;
}

/* --- ESTILOS PARA EL FILTRO --- */
.filters-container {
  background-color: #2d3748;
  padding: 1rem 1.5rem;
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  margin-bottom: 2rem;
}
.filters-container label {
  font-weight: bold;
  font-size: 1.1rem;
  color: #a0aec0;
}
.filters-container select {
  padding: 10px 15px;
  font-size: 1.1rem;
  background-color: #4A5568;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: white;
}

.no-data-message {
  text-align: center;
  font-size: 1.2rem;
  color: #a0aec0;
  background-color: #2d3748;
  padding: 2rem;
  border-radius: 12px;
}

.stats-grid {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}
.stat-card {
  background-color: #2d3748;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}
.stat-title {
  font-size: 1.1rem;
  color: #a0aec0;
  font-weight: bold;
  text-transform: uppercase;
}
.stat-value {
  font-size: 2.5rem;
  font-weight: bold;
}
.detailed-summary-panel {
  background-color: #2d3748;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  padding: 1.5rem;
  margin-top: 2rem;
}
.detailed-summary-panel h3 {
  margin: 0 0 1.5rem 0;
  font-size: 1.5rem;
  text-align: center;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 1rem;
}
.detailed-stats-grid {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}
.detail-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 1.1rem;
  padding: 0.75rem 0;
  border-bottom: 1px solid #3c485e;
}
.detail-item:last-child { border-bottom: none; }
.detail-item span:first-child { color: #a0aec0; }
.detail-item span:last-child { font-weight: bold; }
.profit-text { color: #68d391; }
.loss-text { color: #fc8181; }
.even-text { color: #e2e8f0; }

@media (min-width: 768px) {
  .summary-container { padding: 2rem; }
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }
  .detailed-stats-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem 2rem;
  }
  .detail-item { font-size: 1.2rem; }
}
@media (min-width: 1024px) {
  .stats-grid {
    grid-template-columns: repeat(4, 1fr);
  }
}
</style>

-----------------------------------------------------

--- INICIO DEL ARCHIVO: vite.config.js ---

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { VitePWA } from 'vite-plugin-pwa'
import path from 'path' // <-- PASO 1: AÑADIR ESTA LÍNEA

export default defineConfig({
  // --- PASO 2: AÑADIR ESTA SECCIÓN 'resolve' COMPLETA ---
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  // ----------------------------------------------------------
  plugins: [
    vue(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'apple-touch-icon.png', 'masked-icon.svg'],
      manifest: {
        name: 'Poker Replayer Interactivo',
        short_name: 'Poker Replayer',
        description: 'Una herramienta para configurar, registrar y reproducir manos de poker para su estudio.',
        theme_color: '#1a202c',
        background_color: '#1a202c',
        start_url: '.',
        display: 'standalone',
        icons: [
          {
            src: 'icons/icon-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: 'icons/icon-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
        ],
      },
    }),
  ],
})

------------------------------------------

